<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReentrantLock源码分析]]></title>
    <url>%2Fposts%2Fef6a0c58.html</url>
    <content type="text"><![CDATA[本文主要对ReentrantLock的源码进行了简单的分析，具体包括ReentrantLock的初始化(公平锁和非公平锁)，加锁过程和解锁过程等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. AbstractQueuedSynchronizerReentrantLock的实现依赖于AbstractQueuedSynchronizer所以需要了解一下AQS。 1.1 简介类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，是java.util.concurrent的核心，CountDownLatch、FutureTask、Semaphore、ReentrantLock等都有一个内部类是这个抽象类的子类。 AQS定义两种资源共享方式： Exclusive: 独占，只有一个线程能执行,如ReentrantLock Share: 共享，多个线程可同时执行，如Semaphore/CountDownLatch 1.2 AQS的4个属性12345678910// 头结点，大概可以看做是当前持有锁的线程private transient volatile Node head;// 阻塞的尾节点，每个新的节点进来，都插入到最后private transient volatile Node tail;//当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁 //是可重入锁 每次获取都活加1private volatile int state;// 代表当前持有独占锁的线程 锁重入时用这个来判断当前线程是否已经拥有了锁//继承自AbstractOwnableSynchronizerprivate transient Thread exclusiveOwnerThread; 1.3 阻塞队列Node节点的属性 Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已。 12345678910111213141516171819202122232425262728293031323334353637383940414243static final class Node &#123; /** Marker to indicate a node is waiting in shared mode */ // 标识节点当前在共享模式下 static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ // 标识节点当前在独占模式下 static final Node EXCLUSIVE = null; // ======== 下面的几个int常量是给waitStatus用的 =========== /** waitStatus value to indicate thread has cancelled */ // 表示此线程取消了争抢这个锁 static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ //被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消， //将会通知该后继结点的线程执行。 //就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。 static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ //该标识的结点处于等待队列中，结点的线程等待在Condition上,等待其他线程唤醒 //当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将 //从等待队列转移到同步队列中，等待获取同步锁。 static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ // 与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。 static final int PROPAGATE = -3; // ===================================================== // 节点的等待状态 // 取值为上面的1、-1、-2、-3，或者0 // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待， // 也许就是说半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的 //AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。 volatile int waitStatus; // 前驱节点的引用 volatile Node prev; // 后继节点的引用 volatile Node next; // 这个就是线程对象 volatile Thread thread;&#125; 2. ReentrantLock的使用123456789101112131415161718192021222324/** * Server层 * 模拟ReentrantLock使用 * * @author illusoryCloud */public class UserServer &#123; /** * 默认是非公平锁 传入参数true则创建的是公平锁 */ private static ReentrantLock reentrantLock = new ReentrantLock(true); public void updateUser() &#123; //加锁 同一时刻只能有一个线程更新User reentrantLock.lock(); try &#123; //do something &#125; finally &#123; //释放锁放在finally代码块中 保证出现异常等情况也能释放锁 reentrantLock.unlock(); &#125; &#125;&#125; 3. ReentrantLock源码分析1. 初始化ReentrantLock reentrantLock = new ReentrantLock(true); 12345678910/** *默认是非公平锁 */public ReentrantLock() &#123; sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 2. 加锁过程reentrantLock.lock(); 公平锁实现如下(JDK1.8)： 1234567891011121314151617181920212223242526272829303132333435 /** * Sync object for fair locks */ static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L;//争锁 final void lock() &#123; //1 acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; 1. acquire(1); 1234567891011121314/** * 尝试获取锁 */public final void acquire(int arg) &#123; //tryAcquire(1) 首先尝试获取一下锁 //若成功则不需要进入等待队列了 //1.1 if (!tryAcquire(arg) &amp;&amp; //1.2 // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //1.3 selfInterrupt();&#125; 1.1 tryAcquire(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. * 尝试直接获取锁，返回值是boolean，代表是否获取到锁 * 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取 */protected final boolean tryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //查看锁的状态 int c = getState(); //state == 0 此时此刻没有线程持有锁 可以直接获取锁 if (c == 0) &#123; //由于是公平锁 则在获取锁之前先看一下队列中还有没有其他等待的线程 //讲究先来后到 所以是公平锁 这也是和非公平锁的差别 //非公平锁在这里会直接尝试获取锁 //1.1.1 if (!hasQueuedPredecessors() &amp;&amp; // 如果没有线程在等待，那就用CAS尝试获取一下锁 // 不成功的话，只能说明几乎同一时刻有个线程抢先获取到了锁 //因为刚才hasQueuedPredecessors判断是前面没有线程在等待的 //1.1.2 compareAndSetState(0, acquires)) &#123; //获取到锁后把当前线程设置为锁的拥有者 //1.1.3 setExclusiveOwnerThread(current); //获取锁成功直接返回true return true; &#125; &#125; //到这里说明当前锁已经被占了 //然后判断如果当前线程就是持有锁的线程 //那么这次就是锁的重入 else if (current == getExclusiveOwnerThread()) &#123; //把state加1 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); //1.1.4 setState(nextc); return true; &#125; //上面两个条件都不满足就返回false //获取锁失败了 回到上一个方法继续看 return false;&#125; 1.1.1 hasQueuedPredecessors() 1234567891011121314/** * 通过判断"当前线程"是不是在CLH队列的队首 * 来返回AQS中是不是有比“当前线程”等待更久的线程 */public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; 1.1.2 compareAndSetState(0, acquires)) 1234567/** * 通过CAS设置锁的状态 */ protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; 1.1.3 setExclusiveOwnerThread(current) 123456/** * 设置锁的拥有者 */ protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread; &#125; 1.1.4 setState(nextc) 123456/** * 设置锁的状态 */ protected final void setState(int newState) &#123; state = newState; &#125; 回到前面的方法 123456789101112131415/** * 尝试获取锁 */public final void acquire(int arg) &#123; //tryAcquire(1) 首先尝试获取一下锁 //若成功则不需要进入等待队列了 //1.1 if (!tryAcquire(arg) &amp;&amp; //1.2 // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。 //addWaiter(Node.EXCLUSIVE) 1.2.1 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //1.3 selfInterrupt();&#125; 1.1tryAcquire返回false则继续执行后面的 1.2acquireQueued(addWaiter(Node.EXCLUSIVE), arg) 1.2.1 addWaiter(Node.EXCLUSIVE) 12345678910111213141516171819202122232425262728293031/** * 此方法的作用是把线程包装成node，同时进入到队列中 * 参数mode此时是Node.EXCLUSIVE，代表独占模式 */ private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后 Node pred = tail; // tail!=null --&gt; 队列不为空 if (pred != null) &#123; // 设置自己的前驱 为当前的队尾节点 node.prev = pred; // 用CAS把自己设置为队尾, 如果成功后，tail == node了 //1.2.1.1 if (compareAndSetTail(pred, node)) &#123; // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连， // 上面已经有 node.prev = pred // 加上下面这句，也就实现了和之前的尾节点双向连接了 pred.next = node; // 线程入队了，可以返回了 return node; &#125; &#125; // 仔细看看上面的代码，如果会到这里， // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队) //1.2.1.2 enq(node); return node; &#125; 1.2.1.1 compareAndSetTail(pred, node) 123456/** * 使用CAS设置队列的Tail */private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update); &#125; 1.2.1.2enq(node) 1234567891011121314151617181920212223242526272829303132/** * 进入这个方法只有两种可能：1.等待队列为空 2.有线程竞争入队 * 采用自旋的方式入队 * CAS设置tail过程中，竞争一次竞争不到，多次竞争，总会排到的 */ private Node enq(final Node node) &#123; //无限循环 for (;;) &#123; Node t = tail; // 如果队列是空的就去初始化 if (t == null) &#123; // Must initialize // CAS初始化head节点 //1.2.1.2.1 if (compareAndSetHead(new Node())) // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了 // 这个时候有了head，但是tail还是null，设置一下， // 设置完了以后，继续for循环，下次就到下面的else分支了 tail = head; &#125; else &#123; // 下面几行，和上一个方法 addWaiter 是一样的， // 通过CAS将当前线程排到队尾，有线程竞争的话排不上重复排 // 直到成功了才return // 这里return后前面的addWaiter()方法也返回 // 接下来进入acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; 1.2 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 123456789101112131415161718192021222324252627282930313233343536373839/** * 参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列 * 如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话 * 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false * * 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了 */final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //这里无线循环 直到下面的条件满足 //获取当前节点的前一个节点 设置为p final Node p = node.predecessor(); //p=head说明当前节点是队列的第一个 // 所以当前节点可以去试抢一下锁 // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程 // 也就是说，当前的head可能不属于任何一个线程，所以作为队头，可以去试一试， // tryAcquire已经分析过了,就是简单用CAS试操作一下state if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 到这里，说明上面的if分支没有成功 //要么当前node本来就不是队头 // 要么就是tryAcquire(arg)没有抢赢别人 //1.2.2 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //1.2.3 parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 1.2.2 shouldParkAfterFailedAcquire(p, node) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 进入这里说明抢到锁，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？" * 第一个参数是前驱节点，第二个参数代表当前线程的节点 这里一共有三个规则 * 1.如果前继的节点状态为SIGNAL，表明当前节点需要unpark，则返回true 将导致线程阻塞 * 2.如果前继节点状态为CANCELLED(ws&gt;0)，说明前置节点已经被放弃，则找到一个非取消的前驱节点 * 返回false，acquireQueued方法的无限循环将递归调用该方法，直至规则1返回true * 3.如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL * 返回false后进入acquireQueued的无限循环，与规则2同 */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; // 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。 // 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。 // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点， // 就是为当前节点找一个正常的前驱节点 毕竟当前节点需要等着前驱节点来唤醒 if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ // 这里就在循环直到找到一个waitStatus 不大于 0的前驱节点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ // 仔细想想，如果进入到这个分支意味着什么 // 前驱节点的waitStatus不等于-1也不大于0，那也就是只可能是0，-2，-3 // 这里说明一下：每个新的node入队时，waitStatu都是0 // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1) compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 1.2.3 parkAndCheckInterrupt() 12345678/** *这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的 *这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒 */ private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125; 3. 解锁过程reentrantLock.unlock() 解锁的代码比较相比加锁的要简单不少 1234567/** * 解锁 */public void unlock() &#123; //1 sync.release(1);&#125; 1. sync.release(1) 12345678910111213141516171819202122/** * 释放锁 * */public final boolean release(int arg) &#123; //1.1 //这里尝试释放锁如果成功则进入if里面 if (tryRelease(arg)) &#123; // h赋值为当前的head节点 Node h = head; //如果head节点不是null //并且head节点的waitStatus不等于0 即head节点不是刚初始化的 //因为刚初始化是waitStatus是等于0的 if (h != null &amp;&amp; h.waitStatus != 0) //1.2 //唤醒后继节点 unparkSuccessor(h); return true; &#125; return false;&#125; 1.1 tryRelease(1) 1234567891011121314151617181920212223/** * 尝试释放锁 */protected final boolean tryRelease(int releases) &#123; //可重入锁 所以state可以大于1 每次释放时state减1 int c = getState() - releases; //如果当前线程不是拥有锁的线程直接抛出异常 这肯定嘛 都没获取到锁你释放什么 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); // 是否完全释放锁 boolean free = false; // state==0了 说明可以完全释放锁了 if (c == 0) &#123; free = true; //把锁的拥有者设置为null setExclusiveOwnerThread(null); &#125; //锁的状态设置为0 即没有被获取 setState(c); //到这里 锁已经释放了 //回到上边的release(1)方法 return free;&#125; 1.2 unparkSuccessor(h) 12345678910111213141516171819202122232425262728293031323334353637/** * Wakes up node's successor, if one exists. * 唤醒后继节点 如果有的话 * @param node the node 参数node是head头结点 */private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; // 如果head节点当前waitStatus&lt;0, 将其修改为0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1） Node s = node.next; //如果直接后继节点是null或者 waitStatus &gt; 0即取消了等待 //那么就直接从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从后往前找，不必担心中间有节点取消(waitStatus==1)的情况 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //如果直接后继节点不是空的就直接唤醒 if (s != null) // 唤醒线程 LockSupport.unpark(s.thread);&#125; 唤醒线程以后，被唤醒的线程将从以下代码中继续往前走： 12345private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); // 刚刚线程被挂起在这里了 return Thread.interrupted();&#125;// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了 4. 参考https://javadoop.com/post/AbstractQueuedSynchronizer#toc0 https://blog.csdn.net/chen77716/article/details/6641477 https://www.cnblogs.com/waterystone/p/4920797.html]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea下打包SpringBoot项目并部署到Linux服务器]]></title>
    <url>%2Fposts%2F144a69f9.html</url>
    <content type="text"><![CDATA[本文主要记录了如何在idea下打包SpringBoot项目并部署到云服务器，包括jar包和war包两种方式。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 创建项目首先简单创建一个hello word 代码如下： 1234567891011121314151617181920212223242526/** * 简单的controller * * @author illusoryCloud */@RestControllerpublic class HelloController &#123; @RequestMapping(value = "/hello") public String showHello() &#123; return "hello illusoryCloud"; &#125;&#125;/** * SpringBoot启动类 * * @author illusoryCloud */@SpringBootApplicationpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 2. 打包2.1 jar包和war包区别 SpringBoot默认支持很多模板引擎，但是JSP只能够在War中使用 无论是Jar还是War都能够使用嵌套容器，java -jar来独立运行 但只有war才能部署到外部容器中 2.2 jar包SpringBoot官方推荐打成jar包，服务器上有JDK 1.8以上环境就可以直接运行 1.修改pom.xml文件选择打包方式为jar 123456&lt;groupId&gt;com.illusory&lt;/groupId&gt;&lt;artifactId&gt;hello&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!--版本号--&gt;&lt;name&gt;hello&lt;/name&gt; &lt;!--打出来的包的名字 hello-0.0.1-SNAPSHOT.jar--&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--打包方式jar/war--&gt; 2. 打包然后用maven打包。 1234567891011[INFO] --- maven-jar-plugin:3.1.1:jar (default-jar) @ hello ---[INFO] Building jar: D:\lillusory\MyProjects\hello\target\hello-0.0.1-SNAPSHOT.jar[INFO] [INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ hello ---[INFO] Replacing main artifact with repackaged archive[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 23.922 s[INFO] Finished at: 2019-02-22T20:35:40+08:00[INFO] ------------------------------------------------------------------------ 日志中可以看到打出来的包在D:\lillusory\MyProjects\hello\target\hello-0.0.1-SNAPSHOT.jar 3. 测试SpringBoot内置了一个Tomcat，可以直接java -jar jarName运行。 浏览器访问http://localhost:8080/hello出现hello illusoryCloud说明运行起来了。 这里的端口号是application.yml全局配置文件中配置的端口号。 2.3 war包同时也可以打成war包然后用服务器上的Tomcat启动。 1.修改pom.xml123456789101112 &lt;groupId&gt;com.illusory&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!--版本号--&gt; &lt;name&gt;hello&lt;/name&gt; &lt;!--打出来的包的名字 hello-0.0.1-SNAPSHOT.jar--&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!--打包方式jar/war--&gt;&lt;!--外置tomcat启动--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; maven中的&lt;scope&gt;provided&lt;/scope&gt;表示这个jar包在编译测试等地方是需要的，但是打包不会一起打包进去，这也避免了此类构件当部署到目标容器后产生包依赖冲突。由于SpringBoot内置了Tomcat所以这里需要重新配置一下，防止冲突。 2.改造启动类SpringBoot 内置的Tomcat能认识自己的启动项,而外部tomcat是不认识的 所以需要修改启动类。即继承SpringBootServletInitializer类实现configure方法 1234567891011121314151617181920/** * SpringBoot启动类 * 打成war包时需要改造 继承SpringBootServletInitializer实现configure方法 * 打jar包则不需要 * * @author illusoryCloud */@SpringBootApplicationpublic class HelloApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; //这里的HelloApplication是SpringBoot的启动类 return builder.sources(HelloApplication.class); &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 3. 打包和上面打包的方式一样的 12345678910111213[INFO] Packaging webapp[INFO] Assembling webapp [hello] in [D:\lillusory\MyProjects\hello\target\hello-0.0.1-SNAPSHOT][INFO] Processing war project[INFO] Webapp assembled in [472 msecs][INFO] Building war: D:\lillusory\MyProjects\hello\target\hello-0.0.1-SNAPSHOT.war[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ hello ---[INFO] Replacing main artifact with repackaged archive[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 01:00 min[INFO] Finished at: 2019-02-22T21:10:10+08:00[INFO] ------------------------------------------------------------------------ 可以看到打出来的war包在D:\lillusory\MyProjects\hello\target\hello-0.0.1-SNAPSHOT.war 4. 测试先在电脑上测试一下(Windows环境下) 将war包复制到Tomcat的webapps文件夹下 然后找到bin目录下的startup.bat启动Tomcat，项目就会自动启动了。 浏览器访问http://localhost:8080/hello-0.0.1-SNAPSHOT/hello 出现hello illusoryCloud说明ok的。 这里hello-0.0.1-SNAPSHOT就是war包的名称，Tomcat启动时会自动解压war包然后启动项目。 这里的端口号和application.yml全局配置文件中配置的端口号没有关系，是Tomcat中配置的。 在Tomcat\conf\server.xml这个文件中，默认也是8080。 问题 我这里启动的时候出现了一个问题 Caused by: java.lang.NoClassDefFoundError: javax/el/ELManager 最后找到原因是tomcat提供的el-api.jar 和项目里面的el-api.jar冲突; 这时候你需要去找到自己电脑上用的el-api的版本,copy到tomcat的lib目录下,覆盖原来的jar包. 我的在IntelliJ IDEA 2018.3\lib\rt\jasper2.1\el-api.jar这个目录下 我看网上说是和Tomcat版本有关系，我这里是7.0.52 Tomcat日志 若是还有其他问题的话可以查看Tomcat日志。在tomcat\logs\catalina.2019-02-22.log这个文件中。 3. 部署3.1 jar包首先将文件上传到服务器上，服务器上有安装JDK8及以上的版本就可以直接运行。 Linux下JDK的安装及配置点这里 1. 前台运行1$ java -jar hello-0.0.1-SNAPSHOT.jar 但是这样运行的话是在前台运行，当前窗口关闭后就停止了,或者是运行时没法切出去执行其他任务. 2. 后台运行123456$ nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt;temp.txt &amp;//nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行//这种方法会把日志文件输入到你指定的文件中(temp.txt)//在哪个目录下运行的该日志文件就会在哪个目录下，没有指定具体文件则会自动创建(nohup.out)//&amp; 表示后台运行 3. 问题执行以上命令后出现下面的提示 12nohup: ignoring input and redirecting stderr to stdout忽略输出 将错误输出重定向到标准输出 原因 Linux中0、1和2分别表示标准输入、标准输出和标准错误信息输出，可以用来指定需要重定向的标准输入或输出。在一般使用时，默认的是标准输出，即1。 例如：2&gt;temp.txt 就是将错误信息写入temp.txt 标准输出还是显示在屏幕上。 另外，也可以实现0，1，2之间的重定向。2&gt;&amp;1：将错误信息重定向到标准输出。 Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。 如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如： 1&gt;/dev/null 2&gt;/dev/null 解决办法 所以最后的命令就是 1nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt;temp.txt 2&gt;&amp;1&amp; 123[root@localhost software]# nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt;temp.txt 2&gt;&amp;1&amp;[1] 22804// 成功启动 pid为22804 4. 测试首先查看服务器的IP 12345678910111213141516171819[root@localhost software]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:8a:48:7d brd ff:ff:ff:ff:ff:ff inet 192.168.1.111/24 brd 192.168.1.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe8a:487d/64 scope link valid_lft forever preferred_lft forever3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 52:54:00:8e:d5:31 brd ff:ff:ff:ff:ff:ff inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0 valid_lft forever preferred_lft forever4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000 link/ether 52:54:00:8e:d5:31 brd ff:ff:ff:ff:ff:ff 然后浏览器访问http://192.168.1.111:8080/hello出现hello illusoryCloud说明成功了。 记得关闭防火墙或者开放8080端口 5. 相关Linux命令 jobs命令和 fg命令 123456$ jobs//那么就会列出所有后台执行的作业，并且每个作业前面都有个编号。[root@localhost software]# jobs[1]+ Running nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt; temp.txt 2&gt;&amp;1 &amp;//如果想将某个作业调回前台控制，只需要 fg + 编号即可。$ fg 1 查看某端口占用的线程的pid 1netstat -nlp |grep :8080 kill 1kill pid 3.2 war包war包运行和在windows上运行其实一样的，也是先将war包copy到Tomcat的webapps目录下，然后启动Tomcat，如果上面测试出现jar包冲突的话这里也需要替换。 Linux下Tomcat安装及配置点这里 启动Tomcat进入Tomcat\bin目录执行./startup.sh即可 1234567[root@localhost bin]# ./startup.sh Using CATALINA_BASE: /usr/local/tomcatUsing CATALINA_HOME: /usr/local/tomcatUsing CATALINA_TMPDIR: /usr/local/tomcat/tempUsing JRE_HOME: /usr/local/jdk8Using CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jarTomcat started. 浏览器访问http://192.168.1.111:8080/hello-0.0.1-SNAPSHOT/hello出现hello illusoryCloud说明是没问题的。 4. 参考https://blog.csdn.net/qq_22638399/article/details/81506448 https://blog.csdn.net/c1481118216/article/details/53010963 https://blog.csdn.net/qq_14853889/article/details/80026885]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门教程]]></title>
    <url>%2Fposts%2F498941.html</url>
    <content type="text"><![CDATA[​ 本文主要记录了Git常用的一些命令，和Git基本使用教学，包括了版本库的创建、代码提交、推送、拉取、版本回退、撤销等操作。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 简介1.1 Git简介Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 1.2 Git工作区概念Git本地有四个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、版本库(Repository或Commit History)、远程仓库(Remote Directory)。文件在这四个区域之间的转换关系如下： Working Directory： 工作区，就是你平时存放项目代码的地方，大概就是一个文件夹。 Index / Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 1.3 工作流程git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) 1.4 文件的四种状态版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用 SHA-1算法计算文件的校验和。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. ​ 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, ​ 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ​ Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, ​ 文件状态为Modified 下面的图很好的解释了这四种状态的转变： 新建文件后 —&gt;Untracked 使用add命令将新建的文件加入到暂存区—&gt;Staged 使用commit命令将暂存区的文件提交到本地仓库—&gt;Unmodified 如果对Unmodified状态的文件进行修改—&gt; modified 如果对Unmodified状态的文件进行remove操作—&gt;Untracked 2. 使用2.1 git配置使用之前首先要设置账号的。 12git config --global user.name //git中你的用户名 在查看提交历史等地方用到 一般为真实姓名 xxxgit config --global user.email //你的邮箱 一般为公司邮箱xxx@xxx.com 查看Git配置信息 1git config --list 2.2 创建git仓库git init用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。执行后会在当前文件夹中多出一个.git文件夹，Git相关信息都在里面。 12$ git initInitialized empty Git repository in C:/Users/13452/Desktop/gitte/.git/ git clone当然，也可以在远程服务器上拉取代码，拷贝一个 Git 仓库到本地 123git clone [url]例如git clone git@github.com:illusorycloud/design-pattern.git 2.3 代码提交假如已经通过git clone从远程服务器上拉取了一下git仓库到本地了，然后在本地新增了一个test.txt文件 git status可以通过git status 查看当前文件的状态 由于是新增的文件，还未加入git追踪，所以当前test.txt为Untracked状态 1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txtnothing added to commit but untracked files present (use "git add" to track) git diff执行git diff命令来查看文件与之前的区别。 1234git diff //查看本地工作区和index区域的文件的区别git diff --cached // 查看Index区域与Repository区域的区别git diff HEAD //查看所有文件与本地仓库的区别git diff --stat //只显示摘要而不是全部显示 git add在本地将文件修改完成后(Working Directory)使用git add命令可将该文件添加到缓存 (Index) 1234git add 文件名 //添加单个文件git add . //添加所有文件git add test.txt //将test.txt文件添加到Index git commit在使用 git add命令将想要快照的内容写入缓存区， 而执行git commit将缓存区内容添加到本地仓库中。(Repository) 1234git commit //提交Index中的文件 执行后会进入写注释的界面git commit -m"注释" //提交时直接写注释git commit -m"新增test.txt文件" git push在执行git commit将缓存区内容添加到本地仓库中后，可以使用git push将本地的修改推送到服务器上的远程仓库中，这样其他人就可以同步了。 12git push [主机名] [分支名]git push origin master //推送到Orinoco主机的master分支 其中默认的主机名是origin git reset撤销命令，git中比较重要的命令之一了。 1git reset [恢复等级] [commitId] soft/mixed/hardgit reset有三个参数，可以看做是三个恢复等级。 git reset –soft 仅仅将commit回退到了指定的提交 ，只修改Repository区域git reset –mixed用指定的commit覆盖Repository区域和Index区，之前所有暂存的内容都变为未暂存的状态 (默认为该参数) git reset –hard使用指定的commit的内容覆盖Repository区域、Index区和工作区。(危险！！！ 此操作会丢弃工作区所做的修改！需谨慎！！！) commidID表示将要恢复到哪个版本。有如下几种表示法 HEAD:表示当前最新的一次提交,(HEAD^)表示倒数第二次提交,(HEAD^^)表示倒数第三次提交，倒数第100次提交则是HEAD^^...^^^ 100个^,当然不会这么傻，还有另外一种写法HEAD~100 就是倒数第100次了。 当然还可以使用具体的commitID: 使用git log可以查看到提交历史，其中就包含了commitID 1234567891011121314151617181920212223$ git log ////这个是最新的一次提交的commitIdcommit 06f1cd144f57c38d6fdbed07616af8ed5d69a9ea(HEAD -&gt; hexo, origin/hexo, origin/HEAD)Author: lillusory &lt;xueduanli@163.com&gt;Date: Sat Feb 16 17:51:18 2019 +0800 添加Git工作区概念详解commit 8f8908ff3edbba0d24d7eee7682e09d002faee6f //这个就是commitIdAuthor: lillusory &lt;xueduanli@163.com&gt;Date: Fri Feb 15 19:10:06 2019 +0800 fix建造者模式两种写法commit 71a44acd12d427f694f554df1d2f26ad59df5978 //这个就是commitIdAuthor: lillusory &lt;xueduanli@163.com&gt;Date: Fri Feb 15 00:31:33 2019 +0800 fix 单例模式+Git 常用命令commit 099675715979832baa107f9da080bfd38d3d63e0 //这个就是commitIdAuthor: lillusory &lt;xueduanli@163.com&gt;Date: Thu Feb 14 23:26:10 2019 +0800 所以git reset有多种写法 12345git reset HEAD //Repository和Index恢复到最后一次提交的状态 不影响工作区git reset HEAD test.txt //只恢复test.txt 文件git reset --soft HEAD //Repository恢复到最后一次提交的状态git reset --hard HEAD //Repository、Index和工作区都恢复到最后一次提交的状态 丢弃工作区所有内容git reset 099675715979832baa107f9da080bfd38d3d63e0 //恢复到commitID版本 一般不用写完整的commitid 写前几位git就可以分辨出来了 git reflog前面的git reset可以恢复到各个版本，但是若恢复到前面的版本了，那么在使用git log查看是就找不到后面的提交了，想要恢复到后面的版本时就可以使用git reflog查看，该命令可以看到所有的版本改动信息。 1234567891011$ git logcommit 86a08a6fbacffcf93f7b4dd94be4a21ca31682c4 (HEAD -&gt; master)Author: lillusory &lt;xueduanli@163.com&gt;Date: Sat Feb 16 18:29:48 2019 +0800 新增test.txt $ git reflog86a08a6 HEAD@&#123;1&#125;: reset: moving to HEAD^b9802c7 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 添加内容111186a08a6 HEAD@&#123;3&#125;: commit (initial): 新增test.txt git pull在其他人提交代码后，可以通过git pull命令拉取服务器代码到本地。 12git pull [主机名] [分支名]git pull origin master //推送到Orinoco主机的master分支 其中默认的主机名是origin 2.4 分支操作创建项目后默认在master分支 即主分支 应保证master分支代码永远是正确的，稳定的，可运行的 创建分支实际开发时一般会根据功能创建多个分支 123git branch branchName //创建分支branchNamegit checkout branchName //切换到分支branchNamegit checkout -b branchName //创建并切换到分支branchName 合并分支在新建的分支开发完后需要进行合并，将新的功能代码合并搭到master分支. 12341.切换到master分支 git checkout master2.把新分支代码合并 git merge branchName 删除分支合并完成后即可删除开发时创建的分 1git branch -d branchName //删除分支branchName 3. 常用命令12345678910111213141516171819202122232425# 新建仓库git initgit clone [url]# 代码提交git add &lt;filename&gt;git commit -m"注释"git push # 版本恢复git reset# 代码拉取git pull# 分支操作git branch &lt;branchName&gt;git checkout &lt;branchName&gt;git merge &lt;branchName&gt;# 信息查看git statusgit loggit refloggit config -l 最后附上一张网上找到的Git常用命令速查表 4. 参考http://www.runoob.com/git/git-basic-operations.html https://www.cnblogs.com/qdhxhz/p/9757390.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储过程入门教程及实例详解]]></title>
    <url>%2Fposts%2F38c0d2ef.html</url>
    <content type="text"><![CDATA[存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。 本文主要介绍了MySQL的存储过程，通过语法教学及实例演示详细的叙述了MySQL存储过程的基本使用。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 存储过程简介存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式。 SQL语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。 简单的说，就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法； 存储过程跟触发器有点类似，都是一组SQL集，但是存储过程是主动调用的，且功能比触发器更加强大，触发器是某件事触发后自动调用； 2. 存储过程的优缺点2.1 优点 1.增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 2.标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。 3.较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 4.减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。 5.作为一种安全机制来充分利用： 通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 2.2 缺点 1.可移植性差 2.对于很简单的sql语句， 存储过程没有优势 3.如果存储过程中不一定会减少网络传输（包含的sql数量并不多， 并且执行很快，就没必要了） 4.如果只有一个用户使用数据库， 那么存储过程对于安全也没什么影响 5.团队开发时需要先统一标准， 否则后期维护是个麻烦 6.在大并发量访问的情况下， 不宜写过多涉及运算的存储过程 7.业务逻辑复杂时， 特别是涉及到对很大的表进行操作的时候， 不如在前端先简化业务逻辑 3. 存储过程语法3.1 基本语法1CREATE PROCEDURE 过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体 例如： 123456789101112131415161718-- 存储过程-- 将语句的结束符号从分号;临时改为两个//(可以是自定义) 让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码DELIMITER // -- 创建存储过程 名称为 add_sumCREATE PROCEDURE add_sum(IN a INT,IN b INT,OUT c INT)-- 过程体开始BEGIN-- SET 赋值 SET c=a+b;-- 过程体结束END// -- 存储过程结束DELIMITER ; -- 将分隔符还原为分号 ；-- 调用存储过程SET @a=1;SET @b=2;CALL add_sum(@a,@b,@c);SELECT @c AS SUM; -- 输出为3 MySQL默认以”;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错。 所以要事先用DELIMITER //声明当前的分隔符，可以自定义。让编译器把两个//之间的内容当做存储过程的代码，不会执行这些代码；结束后使用DELIMITER ;把分隔符还原。 MYSQL 存储过程中的关键语法 声明语句结束符，可以自定义: 123DELIMITER $$或DELIMITER // 声明存储过程: 1CREATE PROCEDURE demo_in_parameter(IN p_in int) 存储过程开始和结束符号: 1BEGIN .... END 变量赋值: 1SET @p_in=1 变量定义: 1DECLARE l_int int unsigned default 4000000; 创建mysql存储过程、存储函数: 1create procedure 存储过程名(参数) 存储过程体: 1create function 存储函数名(参数) 调用存储过程： 1call sp_name[(传参)]; 3.2 存储过程体过程体的开始与结束使用BEGIN与END进行标识。 ①如果过程没有参数，也必须在过程名后面写上小括号 例：CREATE PROCEDURE sp_name ([proc_parameter[,...]]) …… ②确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理 存储过程体包含了在过程调用时必须执行的语句，例如：dml、ddl语句，if-then-else和while-do语句、声明变量的declare语句等 过程体格式：以begin开始，以end结束(可嵌套) 1234567BEGIN BEGIN BEGIN statements; END ENDEND 注意： 每个嵌套块及其中的每条语句，必须以分号结束，表示过程体结束的begin-end块(又叫做复合语句compound statement)，则不需要分号。 为语句块贴标签: 123[begin_label:] BEGIN [statement_list]END [end_label] 例如： 1234567label1: BEGIN label2: BEGIN label3: BEGIN statements; END label3 ; END label2;END label1 标签有两个作用： 1、增强代码的可读性 2、在某些语句(例如:leave和iterate语句)，需要用到标签 3.3 参数存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT: IN：参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值 OUT: 该值可在存储过程内部被改变，并可返回 INOUT: 调用时指定，并且可被改变和返回 1.IN参数例子12345678910111213DELIMITER // CREATE PROCEDURE in_param(IN p_in int) BEGIN SELECT p_in; SET p_in=2; SELECT p_in; END; //DELIMITER ;-- 调用SET @p_in=1; -- 这里@p_in为1CALL in_param(@p_in); -- 这里 修改@p_in值为2SELECT @p_in; -- 查询@p_in值依旧为1 p_in 在存储过程中被修改，但并不影响 @p_id 的值，因为前者为局部变量、后者为全局变量。 12-- 此语句的意思就是根据where条件uid=1查询user表，得到的行数存入变量u_count中（给变量赋值）select count(*) into u_count from user where uid=1; 2.OUT参数例子123456789101112#存储过程DELIMITER // -- 将语句的结束符号从分号;临时改为两个//(可以是自定义) 让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码CREATE PROCEDURE out_param(OUT p_out INT)BEGINSELECT p_out ; SET p_out =999;END// -- 存储过程结束DELIMITER ; -- 将分隔符还原为分号 ；SET @p_out=111;CALL out_param(@p_out); -- 因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为nullSELECT @p_out; -- 调用了out_param存储过程，输出参数，改变了p_out变量的值 3.INOUT输入参数12345678910111213-- 存储过程DELIMITER // -- 将语句的结束符号从分号;临时改为两个//(可以是自定义) 让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码CREATE PROCEDURE inout_param(INOUT p_inout INT)BEGIN SELECT p_inout ; SET p_inout =999; SELECT p_inout ;END// -- 存储过程结束DELIMITER ; -- 将分隔符还原为分号 ；SET @p_inout=111;CALL inout_param(@p_inout); -- 能接受输入的值 查询结果为111SELECT @p_inout; -- 存储过程修改了值 所以结果为999 注意： 1、如果过程没有参数，也必须在过程名后面写上小括号例： 1CREATE PROCEDURE sp_name ([proc_parameter[,...]]) …… 2、确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理 建议： 输入值使用in参数。 返回值使用out参数。 inout参数就尽量的少用。 3.4 变量1变量定义局部变量声明一定要放在存储过程体的开始： 1DECLAREvariable_name [,variable_name...] datatype [DEFAULT value]; 其中，datatype 为 MySQL 的数据类型，如: int, float, date,varchar(length) 例如: 12345DECLARE l_int int unsigned default 4000000; DECLARE l_numeric number(8,2) DEFAULT 9.95; DECLARE l_date date DEFAULT '1999-12-31'; DECLARE l_datetime datetime DEFAULT '1999-12-31 23:59:59'; DECLARE l_varchar varchar(255) DEFAULT 'This will not be padded';` 2 变量赋值1SET 变量名 = 表达式值 [,variable_name = expression ...] 3 用户变量123SET @ValueName=value; SET @uid=123; 注意: 1、用户变量名一般以@开头 2、滥用用户变量会导致程序难以理解及管理 3.5 存储过程控制语句1. 变量作用域内部的变量在其作用域范围内享有更高的优先权，当执行到 end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储过程外再也不能找到这个申明的变量，但是你可以通过 out 参数或者将其值指派给会话变量来保存其值。 2.条件语句1.if-then-else 语句123456789101112131415161718DROP PROCEDURE IF EXISTS myif; -- 删除存储过程myif 如果存在DELIMITER //CREATE PROCEDURE myif(IN a INT)BEGINDECLARE msg VARCHAR(30);IF a = 0 THEN SET msg='a is 0';ELSEIF a = 1 THEN SET msg='a is 1';ELSE SET msg='a is others,not 0 or 1';END IF;SELECT msg;END//DELIMITER ;CALL myif(2); -- 调用 2.case语句：12345678910111213141516171819DROP PROCEDURE IF EXISTS mycase;DELIMITER //CREATE PROCEDURE mycase(IN a INT)BEGINDECLARE msg VARCHAR(30); -- 定义变量CASE aWHEN 0 THEN SET msg='a is 0';WHEN 1 THEN SET msg='a is 1';ELSE -- 相当于switch中的default SET msg='a is others,not 0 or 1';SELECT msg;END CASE;END //DELIMITER ;CALL mycase(1); -- 调用 3.循环语句1.while ···· end while123456789101112131415DROP PROCEDURE IF EXISTS mywhile;DELIMITER //CREATE PROCEDURE mywhile(IN a INT)BEGINDECLARE msg VARCHAR(30);WHILE a&gt;1 DOINSERT INTO user2 VALUES(NULL,a); -- 循环往表中插入数据SET a=a-1; -- 每次执行结束a减1END WHILE;END//DELIMITER ;DROP PROCEDURE mywhile;CALL mywhile(5); 123while 条件 do --循环体endwhile 2.repeat···· end repea它在执行操作后检查结果，而 while 则是执行前进行检查。 1234567891011121314DROP PROCEDURE IF EXISTS myrepeat;DELIMITER //CREATE PROCEDURE myrepeat(IN a INT)BEGINREPEAT INSERT INTO user2 VALUES(NULL,a); SET a=a-1; UNTIL a&lt;1 END REPEAT; END //DELIMITER ; CALL myrepeat(10); 1234repeat -- 循环体until 循环条件 end repeat; 3.loop ·····endloop– loop 与 leave,iterate 实现循环– loop 标志位无条件循环，leave 类似于break 语句，跳出循环，跳出 begin end，iterate 类似于continue ，结束本次循环 12345678910111213141516DROP PROCEDURE IF EXISTS myloop;DELIMITER //CREATE PROCEDURE myloop(IN a INT)BEGINloop_label: LOOPINSERT INTO user2 VALUES(NULL,a);SET a=a-1;IF a&lt;1 THEN LEAVE loop_label;END IF;END LOOP;END//DELIMITER ;CALL myloop(10); 4.LABLES 标号标号可以用在 begin repeat while 或者 loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。 ITERATE 通过引用复合语句的标号,来从新开始复合语句: 1234567891011121314151617181920DROP PROCEDURE IF EXISTS myiterate;DELIMITER //CREATE PROCEDURE myiterate(IN a INT)BEGINloop_label: LOOPIF a&lt;3 THEN SET a=a+1;ITERATE loop_label; -- 退出这次循环 继续下一次循环 类似于continueEND IF;INSERT INTO user2 VALUES(NULL,a);SET a=a+1;IF a&gt;=5 THEN LEAVE loop_label;END IF;END LOOP;END//DELIMITER ;CALL myiterate(1); 4. 存储过程操作语法4.1 存储过程查询查看某个数据库下面的存储过程 12345678-- 查询数据库中的存储过程SELECT * FROM mysql.proc WHERE db='数据库名'; -- MySQL存储过程和函数的信息存储在information_schema数据库下的Routines表中。通过查询该表的记录查询信息SELECT * FROM information_schema.routines WHERE routine_schema='数据库名';-- 这个语句是MySQL的扩展，它返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。PROCEDURE和FUNCTION分别表示查看存储过程和函数SHOW PROCEDURE STATUS WHERE db='数据库名'; 查看详细的存储过程 1SHOW CREATE PROCEDURE 数据库.存储过程名; -- 它返回一个可用来重新创建已命名子程序的确切字符串 4.2 修改删除12345678910-- 修改ALTER &#123;PROCEDURE | FUNCTION&#125; proc_or_func [characterustic...]ALTER PROCEDURE 存储过程名字 ALTER PROCEDURE inout_param -- 删除DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] proc_nameDROP PROCEDURE inout_param;DROP PROCEDURE IF EXISTS inout_param; 5. 参考http://www.runoob.com/w3cnote/mysql-stored-procedure.html https://www.2cto.com/database/201805/746743.html https://www.cnblogs.com/mark-chan/p/5384139.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种常见排序算法的Java实现]]></title>
    <url>%2Fposts%2F82240bb6.html</url>
    <content type="text"><![CDATA[本文主要记录了几种常见的排序算法的Java实现，如冒泡排序、快速排序、直接插入排序、希尔排序、选择排序等等。在学数据结构与算法时的部分记录，感觉很难╮(╯▽╰)╭，还需继续努力。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 冒泡排序将序列中所有元素两两比较，将最大的放在最后面。 将剩余序列中所有元素两两比较，将最大的放在最后面。 重复第二步，直到只剩下一个数。 123456789101112131415161718/** * 冒泡排序：两两比较，大者交换位置,则每一轮循环结束后最大的数就会移动到最后. * 时间复杂度为O(n²) 空间复杂度为O(1) */private static void bubbleSort(int[] arr) &#123; //外层循环length-1次 for (int i = 0; i &lt; arr.length-1; i++) &#123; //外层每循环一次最后都会排好一个数 //所以内层循环length-1-i次 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 2. 快速排序快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列. 具体步骤 快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。 ①. 从数列中挑出一个元素，称为”基准”（pivot）。 ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 123456789101112131415161718192021222324252627282930313233/** * 快速排序 * 时间复杂度为O(nlogn) 空间复杂度为O(1) */ public static void quickSort(int[] arr, int start, int end) &#123; if (start &lt; end) &#123; int baseNum = arr[start];//选基准值 int midNum;//记录中间值 int left = start;//左指针 int right = end;//右指针 while(left&lt;right)&#123; while ((arr[left] &lt; baseNum) &amp;&amp; left &lt; end) &#123; left++; &#125; while ((arr[right] &gt; baseNum) &amp;&amp; right &gt; start) &#123; right--; &#125; if (left &lt;= right) &#123; midNum = arr[left]; arr[left] = arr[right]; arr[right] = midNum; left++; right--; &#125; &#125; if (start &lt; right) &#123; quickSort(arr, start, right); &#125; if (end &gt; left) &#123; quickSort(arr, left, end); &#125; &#125; &#125; 3. 直接插入排序直接插入排序（Straight Insertion Sorting）的基本思想：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。 首先设定插入次数，即循环次数，for(int i=1;i&lt;length;i++)，1个数的那次不用插入。 设定插入数和得到已经排好序列的最后一个数的位数。insertNum和j=i-1。 从最后一个数开始向前循环，如果插入数小于当前数，就将当前数向后移动一位。 将当前数放置到空着的位置，即j+1。 12345678910111213141516/** * 直接插入排序 * 时间复杂度O(n²) 空间复杂度O(1) */public static void straightInsertion(int[] arr) &#123; int current;//要插入的数 for (int i = 1; i &lt; arr.length; i++) &#123; //从1开始 第一次一个数不需要排序 current = arr[i]; int j = i - 1;//序列元素个数 while (j &gt;= 0 &amp;&amp; arr[j] &gt; current) &#123;//从后往前循环，将大于当前插入数的向后移动 arr[j + 1] = arr[j];//元素向后移动 j--; &#125; arr[j + 1] = current;//找到位置，插入当前元素 &#125;&#125; 4. 希尔排序是插入排序的一种高速而稳定的改进版本。 希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 123456789101112131415161718192021/** * 希尔排序 * 时间复杂度O(n²) 空间复杂度O(1) */public static void shellSort(int[] arr) &#123; int gap = arr.length / 2; for (; gap &gt; 0; gap = gap / 2) &#123; //不断缩小gap，直到1为止 for (int j = 0; (j + gap) &lt; arr.length; j++) &#123; //使用当前gap进行组内插入排序 for (int k = 0; (k + gap) &lt; arr.length; k += gap) &#123; if (arr[k] &gt; arr[k + gap]) &#123; //交换操作 int temp = arr[k]; arr[k] = arr[k + gap]; arr[k + gap] = temp; &#125; &#125; &#125; &#125;&#125; 5. 选择排序遍历整个序列，将最小的数放在最前面。 遍历剩下的序列，将最小的数放在最前面。 重复第二步，直到只剩下一个数。 12345678910111213141516171819/** * 选择排序 * 时间复杂度O(n²) 空间复杂度O(1) */public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //循环次数 int min = arr[i];//等会用来放最小值 int index = i;//用来放最小值的索引 for (int j = i + 1; j &lt; arr.length; j++) &#123; //找到最小值 if (arr[j] &lt; min) &#123; min = arr[j]; index = j; &#125; &#125; //内层循环结束后进行交换 arr[index] = arr[i];//当前值放到最小值所在位置 arr[i] = min;//当前位置放最小值 &#125;&#125; 6. 堆排序对简单选择排序的优化。 将序列构建成大顶堆。 将根节点与最后一个节点交换，然后断开最后一个节点。 重复第一、二步，直到所有节点断开。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void heapSort(int[] a)&#123; int len=a.length; //循环建堆 for(int i=0;i&lt;len-1;i++)&#123; //建堆 buildMaxHeap(a,len-1-i); //交换堆顶和最后一个元素 swap(a,0,len-1-i); &#125; &#125; //交换方法 private void swap(int[] data, int i, int j) &#123; int tmp=data[i]; data[i]=data[j]; data[j]=tmp; &#125; //对data数组从0到lastIndex建大顶堆 private void buildMaxHeap(int[] data, int lastIndex) &#123; //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125; &#125; 7. 归并排序速度仅次于快速排序，内存少的时候使用，可以进行并行计算的时候使用。 选择相邻两个数组成一个有序序列。 选择相邻的两个有序序列组成一个有序序列。 重复第二步，直到全部组成一个有序序列。 1234567891011121314151617181920212223242526272829303132333435363738public void mergeSort(int[] a, int left, int right) &#123; int t = 1;// 每组元素个数 int size = right - left + 1; while (t &lt; size) &#123; int s = t;// 本次循环每组元素个数 t = 2 * s; int i = left; while (i + (t - 1) &lt; size) &#123; merge(a, i, i + (s - 1), i + (t - 1)); i += t; &#125; if (i + (s - 1) &lt; right) merge(a, i, i + (s - 1), right); &#125; &#125; private static void merge(int[] data, int p, int q, int r) &#123; int[] B = new int[data.length]; int s = p; int t = q + 1; int k = p; while (s &lt;= q &amp;&amp; t &lt;= r) &#123; if (data[s] &lt;= data[t]) &#123; B[k] = data[s]; s++; &#125; else &#123; B[k] = data[t]; t++; &#125; k++; &#125; if (s == q + 1) B[k++] = data[t++]; else B[k++] = data[s++]; for (int i = p; i &lt;= r; i++) data[i] = B[i]; &#125; 8. 基数排序用于大量数，很长的数进行排序时。 将所有的数的个位数取出，按照个位数进行排序，构成一个序列。 将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。 123456789101112131415161718192021222324252627282930313233343536373839404142public void baseSort(int[] a) &#123; //首先确定排序的趟数; int max = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; &#125; int time = 0; //判断位数; while (max &gt; 0) &#123; max /= 10; time++; &#125; //建立10个队列; List&lt;ArrayList&lt;Integer&gt;&gt; queue = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; ArrayList&lt;Integer&gt; queue1 = new ArrayList&lt;Integer&gt;(); queue.add(queue1); &#125; //进行time次分配和收集; for (int i = 0; i &lt; time; i++) &#123; //分配数组元素; for (int j = 0; j &lt; a.length; j++) &#123; //得到数字的第time+1位数; int x = a[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i); ArrayList&lt;Integer&gt; queue2 = queue.get(x); queue2.add(a[j]); queue.set(x, queue2); &#125; int count = 0;//元素计数器; //收集队列元素; for (int k = 0; k &lt; 10; k++) &#123; while (queue.get(k).size() &gt; 0) &#123; ArrayList&lt;Integer&gt; queue3 = queue.get(k); a[count] = queue3.get(0); queue3.remove(0); count++; &#125; &#125; &#125; &#125; 9. 总结 排序法 平均时间 最小时间 最大时间 稳定度 额外空间 备注 冒泡排序 O(n2) O(n) O(n2) 稳定 O(1) n小时较好 选择排序 O(n2) O(n2) O(n2) 不稳定 O(1) n小时较好 插入排序 O(n2) O(n) O(n2) 稳定 O(1) 大部分已排序时较好 基数排序 O(logRB) O(n) O(logRB) 稳定 O(n) B是真数(0-9)，R是基数(个十百) Shell排序 O(nlogn) - O(ns) 1&lt;s&lt;2 不稳定 O(1) s是所选分组 快速排序 O(nlogn) O(n2) O(n2) 不稳定 O(logn) n大时较好 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 O(n) 要求稳定性时较好 堆排序 O(nlogn) O(nlogn) O(nlogn) 不稳定 O(1) n大时较好 参考https://www.cnblogs.com/shixiangwan/p/6724292.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运行时数据区]]></title>
    <url>%2Fposts%2F9806100a.html</url>
    <content type="text"><![CDATA[本文主要讲的是Java运行时数据区，包括线程私有的程序计数器，虚拟机栈，本地方法栈和线程共享的堆，方法区等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 线程私有的：程序计数器 、虚拟机栈、本地方法栈 线程共享的： 堆、方法区 1.1 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 程序计数器主要有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 1.2 虚拟机栈Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。 Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口。 每个方法在执行时都会创建一个栈帧,每一个方法从调用到执行完成的过程就是一个栈帧在虚拟机中的入栈到出栈的过程。 局部变量表存放了编译时期可知的各种基本类型（Boolean，byte，char,short,int.float.long,double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令的地址）。局部变量表的创建是在方法被执行的时候,随着栈帧的创建而创建.而且,局部变量表的大小在编译时期就可以确定下来了,在创建的时候只需要分配实现规定好的大小即可.此外,在方法运行过程中局部变量表的大小是不会发生改变的。 操作数栈后进先出LIFO，最大深度由编译期确定。栈帧刚建立时，操作数栈为空，执行方法操作时，操作数栈用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。操作数栈可以存放一个jvm中定义的任意数据类型的值。在任意时刻，操作数栈都一个固定的栈深度，基本类型除了long、double占用两个深度，其它占用一个深度. 动态链接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。 方法返回地址当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。 Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。 Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 1.3 本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。 1.4 堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java虚拟机规范中说的是：所有的对象实例以及数组都要在堆上分配内存。但是随着JIT(just in time)编译器的发展与逃逸分析技术的成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化，所有对象都分配在堆上也变得不是那么绝对了。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor空间、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。** 1.5 方法区方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。 相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。 1.6 常量池全局字符串池全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。 静态常量池也叫class文件常量池（class constant pool）,Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是常量池,用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。 字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 运行时常量池运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是常量池,用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。 既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 JDK1.8后放在一个独立空间里面，叫做“元空间” jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。 小结 1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。 2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。 3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 1.7 直接内存直接内存并不是虚拟机运行时数据区的一部分，但是也频繁被用到，也可能导致OOM,虚拟机内存+直接内存超过物理内存时。 在JDK1.4出现的NIO类中引入了一个基于Channel和Buffer的IO方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，能在一些场合中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 参考《深入理解Java虚拟机》 https://blog.csdn.net/qq_26222859/article/details/73135660]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装RabbitMQ]]></title>
    <url>%2Fposts%2Fb84a2c6c.html</url>
    <content type="text"><![CDATA[本章主要讲了如何通过解压方式在Linux下安装RabbitMQ和Erlang，超级详细的安装过程，和安装过程中遇到的一些问题。 更多文章欢迎访问我的个人博客–&gt;幻境云图 软件统一放在/usr/software下 解压后放在单独的文件夹下/usr/locac/opt/rabbitmq,/usr/local/opt/erlang RabbitMQ0. 环境准备1.版本问题Erlang和RabbitMQ版本必须对应才行，不然可能会出错。 官网信息如下 RabbitMQ Erlang Version Requirements Erlang/OTP versions older than 20.3 are not supported by RabbitMQ versions released in 2019. RabbitMQ versions prior to 3.7.7 do not support Erlang/OTP 21 or newer. RabbitMQ version3.7.7–3.7.10 需要的Erlang版本最低为20.3.X,最高为21.X RabbitMQ version Minimum required Erlang/OTP Maximum supported Erlang/OTP 3.7.7—3.7.10 20.3.X 21.X 3.7.0–3.7.6 19.3 20.3.X 具体信息在这里http://www.rabbitmq.com/which-erlang.html 这里选择的版本是 Erlang:21.2,RabbitMQ3.7.10,Linux:CentOS 7 2. 依赖下载安装rabbitmq需要下载以下依赖，这里可以提前下载上。 # yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel # yum install xmlto -y 1. Erlang安装1.1 下载安装RabbitMQ之前需要先安装Erlang. 下载地址：http://www.erlang.org/downloads 文件otp_src_21.2.tar.gz 1.2 解压将压缩包上传到虚拟机中，我是放在/usr/software目录下的 # tar xvf otp_src_21.2.tar.gz 解压文件 复制一份到/usr/local/opt/erlang-software # cp otp_src_21.2 /usr/local/opt/erlang-software -r 创建erlang安装目录： /usr/local/opt/erlang 1.3 编译进入到/usr/local/opt/erlang-software目录下 # cd /usr/local/opt/erlang-software 配置安装路径编译代码：# ./configure --prefix=/usr/local/opt/erlang # make &amp;&amp; make install 执行编译 1.4 环境变量配置配置Erlang环境变量,# vi /etc/profile 添加以下内容 1export PATH=$PATH:/usr/local/opt/erlang/bin # source /etc/profile使得文件生效 1.5 验证验证erlang是否安装成功：# erl 进入如下界面就说明 配置好了 123456[root@localhost bin]# erlErlang/OTP 21 [erts-10.2] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]Eshell V10.2 (abort with ^G)1&gt; ` 2. RabbitMQ安装2.1 下载官网：http://www.rabbitmq.com/releases/rabbitmq-server 这里下载3.7.10 :http://www.rabbitmq.com/install-generic-unix.html 文件：rabbitmq-server-generic-unix-3.7.10.tar.xz 2.2 解压文件是xz格式的，解压后得到tar格式文件。 # xz -d rabbitmq-server-generic-unix-3.7.10.tar.xz # tar -xvf rabbitmq-server-generic-unix-3.7.10.tar 复制到/usr/local/opt/rabbitmq目录下# cp -r rabbitmq_server-3.7.10/ /usr/local/opt/rabbitmq 2.3 环境变量配置配置rabbitmq环境变量,# vi /etc/profile 添加以下内容 export PATH=$PATH:/usr/local/opt/rabbitmq/sbin 环境变量生效：source /etc/profile 2.4 使用进入/usr/local/opt/rabbitmq/sbin目录 启动服务：# ./rabbitmq-server -detached 查看服务状态：# ./rabbitmqctl status 关闭服务：# ./rabbitmqctl stop 2.5 配置网页插件首先创建目录，否则可能报错：# mkdir /etc/rabbitmq 启用插件：# ./rabbitmq-plugins enable rabbitmq_management 启动mq：# ./rabbitmq-server -detached 配置linux 端口： 15672 网页管理， 5672 AMQP端口 然后访问http://192.168.5.154:15672/ 这里是需要登录了。 rabbitmq默认会创建guest账号，只能用于localhost登录页面管理员，需要自己创建账号。 2.6 添加账户查看mq用户：# rabbitmqctl list_users 查看用户权限：# rabbitmqctl list_user_permissions guest 新增用户： # rabbitmqctl add_user root root 用户名root,密码root 赋予管理员权限： rabbitmqctl set_user_tags root administrator rabbitmqctl set_permissions -p &quot;/&quot; root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 3. 问题1.启动报错 1234567891011121314151617181920212223242526[root@localhost sbin]# ./rabbitmq-server startBOOT FAILED============INFO REPORT==== 21-Jan-2019::20:49:29.302765 ===Error description: noproc Log files (may contain more information): /usr/local/opt/rabbitmq/var/log/rabbitmq/rabbit@localhost.log /usr/local/opt/rabbitmq/var/log/rabbitmq/rabbit@localhost-sasl.logStack trace: [&#123;gen,do_for_proc,2,[&#123;file,"gen.erl"&#125;,&#123;line,228&#125;]&#125;, &#123;gen_event,rpc,2,[&#123;file,"gen_event.erl"&#125;,&#123;line,239&#125;]&#125;, &#123;rabbit,ensure_working_log_handlers,0, [&#123;file,"src/rabbit.erl"&#125;,&#123;line,856&#125;]&#125;, &#123;rabbit,'-boot/0-fun-0-',0,[&#123;file,"src/rabbit.erl"&#125;,&#123;line,288&#125;]&#125;, &#123;rabbit,start_it,1,[&#123;file,"src/rabbit.erl"&#125;,&#123;line,424&#125;]&#125;, &#123;init,start_em,1,[]&#125;, &#123;init,do_boot,3,[]&#125;]&#123;"init terminating in do_boot",noproc&#125;init terminating in do_boot (noproc)Crash dump is being written to: erl_crash.dump...done 这个问题网上查了一下，有的说是权限问题，也有说是erlang和rabbitmq版本对应不上，暂时没解决。 以解决，确实是版本问题，erlang版本和rabbitmq的版本对应不上，最前面单独写了这个关于版本的问题。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法与小技巧]]></title>
    <url>%2Fposts%2F9b0e40a3.html</url>
    <content type="text"><![CDATA[本文主要介绍了关于markdown的一些常用语法和技巧，让大家更好的写文章。自从17年前开始在 GitHub 玩耍，接触到 Markdown 之后，就感觉很有意思。不过也仅仅是了解一下基本语法，所以找了一下Markdown的语法用法来学习学习。 更多文章欢迎访问我的个人博客–&gt;幻境云图 如下： 注：如下技巧大多是利用 Markdown 兼容部分 HTML 标签的特性来完成，不一定在所有网站和软件里都完全支持，主要以 GitHub 支持为准。 标题123# This is an &lt;h1&gt; tag## This is an &lt;h2&gt; tag###### This is an &lt;h6&gt; tag 重点1234567*This text will be italic*_This will also be italic_**This text will be bold**__This will also be bold___You **can** combine them_ This text will be italicThis will also be italic This text will be boldThis will also be bold You can combine them 清单无序1234* Item 1* Item 2 * Item 2a * Item 2b Item 1 Item 2 Item 2a Item 2b 有序123451. Item 11. Item 21. Item 3 1. Item 3a 1. Item 3b Item 1 Item 2 Item 3 Item 3a Item 3b 图片12![GitHub Logo](/images/logo.png)Format: ![Alt Text](url) 链接12http://github.com - automatic![GitHub](http://github.com) http://github.com - automatic!GitHub 引用文字1234As Kanye West said:&gt; We&apos;re living the future so&gt; the present is our past. As Kanye West said: We’re living the future sothe present is our past. 内联代码12I think you should use an`&lt;addr&gt;` element here instead. I think you should use an&lt;addr&gt; element here instead. 删除线用两个波浪线（如~~this~~）包裹的任何单词都会显示为划掉。 这是被删除的内容 在表格单元格里换行借助于 HTML 里的 &lt;br /&gt; 实现。 示例代码： 123| Header1 | Header2 ||---------|----------------------------------|| item 1 | 1. one&lt;br /&gt;2. two&lt;br /&gt;3. three | 示例效果： Header1 Header2 item 1 1. one2. two3. three 引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 * 都可以。 流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 12## 表格 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 123456789&gt; //语法：&gt;&gt; 1）|、-、:之间的多余空格会被忽略，不影响布局。&gt; 2）默认标题栏居中对齐，内容居左对齐。&gt; 3）-:表示内容和标题栏居右对齐，:-表示内容和标题栏居左对齐，:-:表示内容和标题栏居中对齐。&gt; 4）内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少有一个。表格在渲染之后很整洁好看，但是在文件源码里却可能是这样的： Header1 Header2 a a ab ab abc abc 1234不知道你能不能忍，反正我是不能忍。好在广大网友们的智慧是无穷的，在各种编辑器里为 Markdown 提供了表格格式化功能，比如我使用 Vim 编辑器，就有 [vim-table-mode](https://github.com/dhruvasagar/vim-table-mode) 插件，它能帮我自动将表格格式化成这样： Header1 Header2 a a ab ab abc abc 12345678910是不是看着舒服多了？如果你不使用 Vim，也没有关系，比如 Atom 编辑器的 [markdown-table-formatter](https://atom.io/packages/markdown-table-formatter) 插件，Sublime Text 3 的 [MarkdownTableFormatter](https://github.com/bitwiser73/MarkdownTableFormatter) 等等，都提供了类似的解决方案。## 使用 Emoji这个是 GitHub 对标准 Markdown 标记之外的扩展了，用得好能让文字生动一些。示例代码： 我和我的小伙伴们都笑了。:smile:123456789101112示例效果：我和我的小伙伴们都笑了。:smile:[Github支持的表情在这里哟](https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md)## 行首缩进直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，`&amp;ensp;` 代表半角空格，`&amp;emsp;` 代表全角空格。示例代码： &emsp;&emsp;春天来了，又到了万物复苏的季节。123456789101112131415161718示例效果：&amp;emsp;&amp;emsp;春天来了，又到了万物复苏的季节。## 展示数学公式如果是在 GitHub Pages，可以参考 &lt;http://wanguolin.github.io/mathmatics_rending/&gt; 使用 MathJax 来优雅地展示数学公式（非图片）。如果是在 GitHub 项目的 README 等地方，目前我能找到的方案只能是贴图了，以下是一种比较方便的贴图方案：1. 在 &lt;https://www.codecogs.com/latex/eqneditor.php&gt; 网页上部的输入框里输入 LaTeX 公式，比如 `$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$`；2. 在网页下部拷贝 URL Encoded 的内容，比如以上公式生成的是 `https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24`； ![](D:\lillusory\MyProject\lillusory.github.io\images\posts\Markdown\Markdown_latex_img)3. 在文档需要的地方使用以上 URL 贴图，比如 12345678910 示例效果： ![](https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24)## 任务列表在 GitHub 和 GitLab 等网站，除了可以使用有序列表和无序列表外，还可以使用任务列表，很适合要列出一些清单的场景。示例代码： 购物清单 一次性水杯 西瓜 豆浆 可口可乐 小茗同学` 示例效果： 购物清单 一次性水杯 西瓜 豆浆 可口可乐 小茗同学 自动维护目录有时候维护一份比较长的文档，希望能够自动根据文档中的标题生成目录（Table of Contents），并且当标题有变化时自动更新目录，能减轻工作量，也不易出错。比如 Atom 编辑器的 markdown-toc 插件，Sublime Text 的 MarkdownTOC 插件等。 后话希望自己，也希望大家在了解这些之后能有所收获，更好地排版，专注写作。 参考 https://raw.githubusercontent.com/matiassingers/awesome-readme/master/readme.md https://www.zybuluo.com/songpfei/note/247346 支持的表情]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装MySQL教程]]></title>
    <url>%2Fposts%2F1be8c408.html</url>
    <content type="text"><![CDATA[本章主要讲了如何通过解压方式在Linux下安装MySQL，以及如何设置让我们可以远程连接到服务器上的mysql. 更多文章欢迎访问我的个人博客–&gt;幻境云图 软件统一放在/usr/software下 解压后放在单独的文件夹下/usr/local/java//usr/local/mysql 其中：#为Linux命令，mysql则是mysql下的命令 软件统一放在/usr/software下 解压后放在单独的文件夹下/usr/local/java//usr/local/mysql 安装包下载mysql-5.7.24-linux-glibc2.12-x86_64.tar 网址https://dev.mysql.com/downloads/mysql/5.7.html#downloads 1. 安装依赖1# yum install -y cmake make gcc gcc-c++ libaio ncurses ncurses-devel 2. 解压文件压缩包上传到虚拟机/usr/software目录下,进入这个目录 解压文件 1# tar zxvf mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz 将解压后的文件移动到/usr/local/mysql 1# mv mysql-5.7.24-linux-glibc2.12-x86_64 /usr/local/mysql 3. 添加用户和赋权1.添加用户和用户组 给mysql赋权的用户必须对当前目录具有读写权限，但是一般不用root账户，所以创建一个用户mysql。 执行命令：创建用户组mysqlgroupadd mysql` 创建用户也叫mysql 12// 命令中第一个mysql是用户，第二个mysql是用户组。# useradd -r -g mysql mysql 2.给用户赋权限 一定保证当前是在/usr/local/mysql 目录下 给用户组赋权限 12//mysql是用户组名# chgrp -R mysql. 给用户赋权限 12//这个mysql是用户名# chown -R mysql. 4. 数据库初始化安装数据库 : 12// 这里会生成临时密码，后边有用# bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data 执行以下命令创建RSA private key ： 1# bin/mysql_ssl_rsa_setup --datadir=/usr/local/mysql/data 5. 配置my.cnf1# vim /etc/my.cnf 内容如下： 12345678910[mysqld]character_set_server=utf8init_connect='SET NAMES utf8'basedir=/usr/local/mysqldatadir=/usr/local/mysql/datasocket=/tmp/mysql.sock#不区分大小写 (sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 这个简单来说就是sql语句是否严格)lower_case_table_names = 1log-error=/var/log/mysqld.logpid-file=/usr/local/mysql/data/mysqld.pid 12# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld# vim /etc/init.d/mysqld 添加以下内容，在46行 12basedir=/usr/local/mysqldatadir=/usr/local/mysql/data 6. 修改密码启动mysql 1# service mysqld start 加入开机起动 1# chkconfig --add mysqld 登录修改密码 1# mysql -uroot -p 上面初始化时的密码 如果出现错误 需要添加软连接 1# ln -s /usr/local/mysql/bin/mysql /usr/bin 如果出现Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)应该是密码错了，直接强行修改密码好了。先停掉mysql. 1# service mysql stop 然后修改配置文件 1# vim /etc/my.cnf 在[mysqld]后面任意一行添加skip-grant-tables用来跳过密码验证的过程 接下来我们需要重启MySQL 1# /etc/init.d/mysqld restart 重启之后输入命令mysql即可进入mysql了，然后开始修改密码。 12345mysql&gt; use mysql;# 这里修改密码的命令在5.7以上和5.7以下是不同的 需要注意mysql&gt; update user set authentication_string=passworD(&quot;你的密码&quot;) where user=&apos;root&apos;;flush privileges;mysql&gt; quit 完成后可以把配置文件中的跳过密码验证去掉。 然后就可以正常使用啦。 7. 外部访问首先进入mysql， 1# mysql -u root -p 接着创建远程连接 MySQL 的用户 mysql命令 1234-- 创建用户、密码及权限范围 第一个 roo t为用户名 @后为适用的主机，‘%’表示所有电脑都可以访问连接，第二个 root 为密码mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;192.168.1.3&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION; -- 立即生效mysql&gt; flush privileges; 查看数据库用户： 1234567-- 使用 mysql 库mysql&gt; use mysql;-- 查看用户mysql&gt; SELECT DISTINCT CONCAT(&apos;User: [&apos;, user, &apos;&apos;&apos;@&apos;&apos;&apos;, host, &apos;];&apos;) AS USER_HOST FROM user; -- 查看端口mysql&gt; show global variables like &apos;port&apos;;--mysql 默认端口为3306 解决防火墙问题 防火墙默认只开放了22端口，要访问数据库要么关掉防火墙要么修改配置文件，开放3306端口 修改防火墙配置： 命令 1# vim /etc/sysconfig/iptables 添加以下内容 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT 然后重启防火墙 1# service iptables restart 最后查看服务器IP 1# ip a 到这里应该就可以通过IP和端口号远程连接服务器上的MySQL了。 8. 问题mysql中执行命令出现以下错误： 1ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 解决： 修改用户密码 1mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;你的密码&apos;; 参考https://blog.csdn.net/z13615480737/article/details/80019881 https://www.cnblogs.com/goodcheap/p/7103049.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装jdk和Tomcat]]></title>
    <url>%2Fposts%2F54978294.html</url>
    <content type="text"><![CDATA[本章主要讲了如何通过解压方式在Linux下安装JDK和Tomcat等软件。 更多文章欢迎访问我的个人博客–&gt;幻境云图 软件统一放在/usr/software下 解压后放在单独的文件夹下/usr/local/java//usr/local/mysql 1.JDK安装包下载jdk-8u191-linux-x64.tar.gz 注意32位和64位的别下载错了。 命令uname -a 查看Linux系统位数。 网址：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 1.首先将压缩包传到虚拟机。放在/usr/software下 2.然后解压文件tar zxvf jdk-8u191-linux-x64.tar.gz 按tab会自动补全。 3.将解压得到的文件移动到/usr/local/java,命令`mv jdk1.8.0_191/ /usr/local/jdk8 4.配置环境变量 命令vim /etc/profile 添加以下内容 123 export JAVA_HOME=/usr/local/jdk8/ export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 5.解析该文件 命令source /etc/profile 6.测试 命令 java -version 输出版本信息就说明配好了。 2.Tomcat安装包下载apache-tomcat-8.5.37.tar.gz 网址https://tomcat.apache.org/download-80.cgi 1.压缩包上传到虚拟机/usr/software目录下 2.解压文件 tar zxvf apache-tomcat-8.5.37.tar.gz 3.将解压后的文件移动到/usr/local/tomcat,命令mv apache-tomcat-8.5.37 /usr/local/tomcat 4.配置环境变量 命令vim /etc/profile 添加以下内容 12export TOMCAT_HOME=/usr/local/tomcatexport CATANILA_HOME=/usr/local/tomcat 5.解析该文件 命令source /etc/profile]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的网络配置]]></title>
    <url>%2Fposts%2Fb0d13a6d.html</url>
    <content type="text"><![CDATA[本章主要讲了linux如何配置网络，让虚拟机能够连上外网，如何让虚拟机和主机联通，同时介绍了ssh客户端工具连接虚拟机。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. Xshell在安装好虚拟机后就可以正常使用了。但是在正常工作中不可能真的在服务器上操作，一般都是通过ssh客户端工具连接服务器进行操作。 这里用到的客户端工具是Xshell,通过该工具连上服务器后就可以在自己的电脑上操作了。而且还可以开多个窗口，比较方便。 这里新建连接时需要输入要连接的服务器的IP和端口号，账户和密码，端口号默认是22，一般不用改。 2. 网络配置2.1 桥接模式和NAT模式按照上面的方法就可以连上虚拟机了，但是现在虚拟机的IP是自动获取的，每次重启后都IP都会变，这肯定不行呀，所以我们需要为虚拟机设置静态IP. 由于我们这里使用的是NAT模式。这个模式下虚拟机可以上网，但是无法和主机联通。 桥接模式和NAT模式的区别： 桥接模式下虚拟机可以看做一台真正的独立的电脑，所以桥接模式下需要为虚拟机分配独立的IP，在家里到时无所谓，在公司的话由于IP和电脑绑定的，所以需要网络管理人员给你的虚拟机分配一个IP才行。 NAT模式下，虚拟机会动态获取IP,虽然有自己的IP但是最终上网还是通过主机上网的。所以NAT模式下不用分配独立的IP,但是NAT模式下主机和虚拟机无法联通。 为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。 为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。 为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。 2.2 设置静态IP在设置静态IP前我们需要知道主机的IP. windows下命令行输入 ipconfig 即可获取到本机IP. 然后通过VMware软件对网络进行配置。 接着在虚拟机中配置具体网络信息。 2.3 网络配置2.3.1 网卡配置网络配置文件在/etc/sysconfig/network-scripts/ifcfg-ens33目录下，一般是叫ifcfg-ens33 编辑配置文件 命令：vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置如下 ： 其中ip地址必须和主机在同一网段下，网关就是上边的那个网关。DNS可填可不填。 1234567BOOTPROTO="static" # 手动分配ipONBOOT="yes" # 该网卡是否随网络服务启动IPADDR="192.168.1.111" # 该网卡ip地址就是你要配置的固定IPGATEWAY="192.168.1.2" # 网关NETMASK="255.255.255.0" # 子网掩码 固定值DNS1="8.8.8.8" # DNS，8.8.8.8为Google提供的免费DNS服务器的IP地址DNS2="192.168.1.2" 2.3.2 网络配置命令：vi /etc/sysconfig/network 添加以下内容 1234NETWORKING=yes # 网络是否工作，此处一定不能为noNETWORKING_IPV6=noHOSTNAME=localhost.localdomainGATEWAY=192.168.1.2 2.3.3 配置公共DNS服务vi /etc/resolv.conf 123search localdomainnameserver 8.8.8.8nameserver 192.168.1.2 2.3.4 关闭防火墙12systemctl stop firewalld # 临时关闭防火墙systemctl disable firewalld # 禁止开机启动 2.3.5 重启网络服务service network restart 到此为止网络配置就完成了，现在虚拟机的IP重启后不会变了，也可以连上外网了，还可以和主机联通了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超详细的VMware虚拟机安装CentOS7教程]]></title>
    <url>%2Fposts%2F4d7cca6f.html</url>
    <content type="text"><![CDATA[这是一个十分详细的CentOS7的安装教程，对自己的安装过程做了一个记录。主要记录了如何通过VMware虚拟机安装Linux，从软件下载到虚拟机安装等等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 准备工作1.1 VMware下载百度网盘下载（内含注册机） 链接: https://pan.baidu.com/s/1wz4hdNQBikTvyUMNokSVYg提取码: yed7 怎么安装就不用写了吧。 1.2 CentOS下载http://mirrors.163.com/centos/7.6.1810/isos/x86_64/ 2. CentOS 7安装 创建虚拟机，这里我们选择自定义安装类型。 然后选择版本，需要注意兼容问题，一般是向下兼容，14上的虚拟机复制到15上可以用，15的复制到14上可能会用不了。 这里选择稍后再安装。 接着选择系统，这里是CentOS 7 64位。 这个是保存的文件名字。 这里一般默认的就行了,电脑配置好的可以调高点。 网络这里,如果仅仅是让虚拟机能上网，两种模式都可以的，用桥接的话只要你在局域网内有合法的地址，比如你的ADSL猫是带路由功能的，如果是在单位，那就要网络管理人员给你合法IP才行。NAT模式下，虚拟机从属于主机，也就是访问外部网络必须通过主机来访问，因此虚拟机的IP只有主机才能识别。而桥接模式下，虚拟机和主机是平行关系，共享一张网卡（使用网卡的多个接口），可以直接访问外部网络。 这些都默认的就行了。 这个是虚拟机文件的名字。 这里选择自定义硬件。 选择镜像文件。 到这里就结束了，点击开启虚拟机后会自动开始安装。 选择安装CentOS 7 语言选择 调一下时间和地区。 选择要安装的软件，新手还是安装一个GUI比较好。 查看一下网络连接 开始安装。 安装过程中可以设置一下账号密码，一个root账户，一个普通账户。 然后耐心等待安装完成就好了。 安装完成后重启就可以登录系统了。 3. 快照快照相当于windows中的还原点。在安装好后可以拍摄一张快照，方便恢复或者克隆虚拟机。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo搭建个人博客优化之（五）--压缩篇]]></title>
    <url>%2Fposts%2F70deabab.html</url>
    <content type="text"><![CDATA[本章主要记录了如何通过gulp工具压缩压缩博客静态文件以加快网站加载速度。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 更多文章欢迎访问我的个人博客–&gt;幻境云图 在本系列文章的第二章中也有类似静态资源压缩的教程，是用的hexo-neat插件，最近用着用着出现了一点点问题，无奈之下换用了gulp。这个工具也可以很方便的压缩静态资源。 1. 插件安装首先需要安装gulp工具 命令：npm install gulp 接着安装功能模块，包括 1234gulp-htmlclean // 清理htmlgulp-htmlmin // 压缩htmlgulp-minify-css // 压缩cssgulp-uglify // 混淆js 命令：npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save 2. 创建任务在站点根目录下，新建gulpfile.js文件，文件内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142var gulp = require('gulp');//Plugins模块获取var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');//压缩cssgulp.task('minify-css', function () &#123;return gulp.src('./public/**/*.css').pipe(minifycss()).pipe(gulp.dest('./public'));&#125;);//压缩htmlgulp.task('minify-html', function () &#123;return gulp.src('./public/**/*.html').pipe(htmlclean()).pipe(htmlmin(&#123;removeComments: true,minifyJS: true,minifyCSS: true,minifyURLs: true,&#125;)).pipe(gulp.dest('./public'))&#125;);//压缩js 不压缩min.jsgulp.task('minify-js', function () &#123;return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']).pipe(uglify()).pipe(gulp.dest('./public'));&#125;);//4.0以前的写法 //gulp.task('default', [ // 'minify-html', 'minify-css', 'minify-js'//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task('default', gulp.parallel('minify-html', 'minify-css', 'minify-js', function() &#123; // Do something after a, b, and c are finished.&#125;)); 3. 使用使用时按照以下顺序就可以了： 1234hexo clean //先清理文件hexo g //编译生成静态文件gulp //gulp插件执行压缩任务hexo s //开启服务 4. 问题刚开始弄这个的时候也是各种百度，Google，大部分的文章也是这么写的但是，第二部的js 代码却都有问题，也不能说有问题吧，大部分都是4.0以前的写法，导致现在gulp更新到4.0之后全都无法使用了。可能在看到这篇文章之前也试了各种办法。然后每次都出现这样的问题： 12345678assert.js:85 throw new assert.AssertionError(&#123; ^AssertionError: Task function must be specified at Gulp.set [as _setTask] (/home/hope/web/node_modules/undertaker/lib/set-task.js:10:3) at Gulp.task (/home/hope/web/node_modules/undertaker/lib/task.js:13:8)................. 在看了下gulp相关资料后才发现了问题，接着把js代码稍微改了改终于能用了。不过运行的时候好像也有点问题，不过不影响使用，对这些工具还是不太了解。 123[21:35:20] The following tasks did not complete: default, &lt;anonymous&gt;[21:35:20] Did you forget to signal async completion?//代码里也没这个任务呀]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronize和Volatile底层实现原理]]></title>
    <url>%2Fposts%2Fcf1a701a.html</url>
    <content type="text"><![CDATA[最近在看并发编程的艺术这本书，希望加深对并发这块的理解。毕竟并发相关还是十分重要的。本文主要是关于第二章Java并发机制的底层实现原理的相关笔记。主要包括volatile,synchronized,原子操作等实现原理的分析。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 上下文切换多线程 即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。 什么是上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。 所以任务从保存到再加载的过程就是一次上下文切换。 上下文切换也会影响多线程的执行速度 因为线程有创建和上下文切换的开销，所以有时候并发不一定比串行快。 减少上下文切换的办法 减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。 CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。 2. volatile关键字如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。 有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，其中就包括了Lock前缀.Lock前缀的指令在多核处理器下会引发了两件事情。 1）将当前处理器缓存行的数据写回到系统内存。 Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。 如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。 2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。 3. synchronized原理与应用Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。 Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象。当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 3.1 底层实现JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。 代码块同步是使用monitorenter和monitorexit指令实现的. 而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。 monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。 3.2 Java对象头synchronized用的锁是存在Java对象头里的。 java的对象头由以下三部分组成： 1，Mark Word 2，指向类的指针 3，数组长度（只有数组对象才有） 3.3 锁的升级与对比Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。 偏向锁 HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁解除 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程. 轻量级锁 （1）轻量级锁加锁线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。（2）轻量级锁解锁轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 优缺点比较 4. 原子操作的实现原理原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。 4.1 处理器如何实现原子操作处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 第一个机制是通过总线锁保证原子性。 所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 第二个机制是通过缓存锁定来保证原子性。 总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。 所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效. 4.2 Java如何实现原子操作使用循环CAS实现原子操作 JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。 CAS实现原子操作的三大问题 1.ABA问题 但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。 ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。 2.循环时间长开销大 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 3.只能保证一个共享变量的原子操作 操作多个共享变量时无法使用CAS操作，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。 使用锁机制实现原子操作 锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。 参考本文内容来自Java并发编程的艺术]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo搭建个人博客之（四）--管理篇]]></title>
    <url>%2Fposts%2F33469.html</url>
    <content type="text"><![CDATA[本章主要记录了如何通过使用Github的分支功能解决更换电脑后博客更新不方便的问题，让你的博客能在各个电脑上灵活切换。在也不用担心换电脑后博客配置丢失等问题了。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 更多文章欢迎访问我的个人博客–&gt;幻境云图 到此为止，我们已经完成了差不多所有的步骤。 1.搭建博客 2.优化主题 3.部署收录 新问题： ​ 现在博客只能在自己的电脑上更新，如果换电脑了就很麻烦。配置文件主题什么的都要重新弄。所以网上找了找多台电脑同时操作的办法，我们可以利用Github的分支功能。 ​ 将博客文件夹下所有文件全push到Github。这样换电脑后直接pull就可以了。 1. 新建分支 1.在Github的lillusory.github.io（hexo仓库）上新建一个分支，例如Hexo，并切换到该分支. 2.并在该仓库Settings-&gt;Branches-&gt;Default branch中将默认分支设为Hexo.Hexo分支是博客的开发环境，用来写博客，保存原始文件,master分支用于显示，保存生产的静态文件。 3.新建分支后将博客目录下的所有文件上传到该分支，注意由于一个git仓库中不能包含其他仓库，所以需要删除掉主题文件夹中的.git目录。 4.如果按照前面的博文添加了背景，则需要删掉站点目录\themes\next\source\lib\canvas-nest文件夹中的.git目录。以后需要更新主题时，可以先克隆到本地在复制到相应目录. 2. 写博客在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m &quot;这里写备注&quot;、git push origin 这里写分支名字指令将改动推送到GitHub（此时当前分支应为hexo）。 然后才执行hexo g -d发布网站到master分支上。 3. 博客迁移当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 克隆仓库 使用git clone git@github.com:illusorycloud/illusorycloud.github.io.git拷贝仓库（默认分支为hexo）；//修改成自己的 安装插件 在前面克隆下的项目中安装插件 执行命令npm install hexo、npm install、npm install hexo-deployer-git 4. 参考如何在多台电脑上更新博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android平台自动发送邮件demo]]></title>
    <url>%2Fposts%2F9a79dc9b.html</url>
    <content type="text"><![CDATA[一个Android平台自动发送邮件的小demo，记录了一下实现的过程。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 导包使用邮件发送功能,需要导入3个jar包. 123456789101112additional.jarmail.jaractivation.jar//用的是AndroidStudio //1.切换到Project视图 //2.将这3个jar包放到app下的lib文件夹中 //3.选择这个三个jar包右键 Add As Library //4.如果导入成功 在Module 的build.gradle中就能看到这个 和平常引入第三方库一样 implementation files('libs/activation.jar') implementation files('libs/additionnal.jar') implementation files('libs/mail.jar') 2. 创建Helper工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package lillusory.com.androidemail;import android.os.AsyncTask;import android.util.Log;import java.util.Date;import java.util.List;import java.util.Properties;import javax.activation.CommandMap;import javax.activation.MailcapCommandMap;import javax.mail.Authenticator;import javax.mail.Message;import javax.mail.Multipart;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;public class MyEmailHelper &#123; private static final String TAG = MyEmailHelper.class.getSimpleName(); private int port = 25; //smtp协议使用的端口 private String host = "smtp.163.com"; // 发件人邮件服务器 //TODO 需要改成自己的账号和授权密码 private String user = "xxx@163.com"; // 使用者账号 private String password = "xxx"; //使用者SMTP授权密码 private List&lt;String&gt; emailTos; private List&lt;String&gt; emailCCs; private String title; private String context; private List&lt;String&gt; paths; public enum SendStatus &#123; SENDING, UNDO, SENDOK, SENDFAIL, BADCONTEXT &#125; private SendStatus sendStatus; public interface EmailInfterface &#123; void startSend(); void SendStatus(SendStatus sendStatus); &#125; private EmailInfterface EmailInfterface; public void setJieEmailInfterface(EmailInfterface EmailInfterface) &#123; this.EmailInfterface = EmailInfterface; &#125; public MyEmailHelper() &#123; sendStatus = SendStatus.UNDO; &#125; //构造发送邮件帐户的服务器，端口，帐户，密码 public MyEmailHelper(String host, int port, String user, String password) &#123; this.port = port; this.user = user; this.password = password; this.host = host; sendStatus = SendStatus.UNDO; &#125; /** * @param emailTos 主要接收人的电子邮箱列表 * @param emailCCs 抄送人的电子邮箱列表 * @param title 邮件标题 * @param context 正文内容 * @param paths 发送的附件路径集合 */ public void setParams(List&lt;String&gt; emailTos, List&lt;String&gt; emailCCs, String title, String context, List&lt;String&gt; paths) &#123; this.emailTos = emailTos; this.emailCCs = emailCCs; this.title = title; this.context = context; this.paths = paths; &#125; public void sendEmail() &#123; new MyAsynTask().execute(); &#125; private void sendEmailBg() throws Exception &#123; Properties properties = new Properties(); properties.put("mail.smtp.host", host); properties.put("mail.smtp.port", port); properties.put("mail.smtp.auth", "true");//true一定要加引号 properties.put("mail.transport.protocol", "smtp"); MyAuthenticator jieAuth = new MyAuthenticator(user, password); Session session = Session.getInstance(properties, jieAuth); //创建一个消息 MimeMessage msg = new MimeMessage(session); //设置发送人 msg.setFrom(new InternetAddress(user)); //设置主要接收人 if (emailTos != null &amp;&amp; !emailTos.isEmpty()) &#123; int size = emailTos.size(); InternetAddress[] addresses = new InternetAddress[size]; for (int i = 0; i &lt; size; i++) &#123; addresses[i] = new InternetAddress(emailTos.get(i)); &#125; msg.setRecipients(Message.RecipientType.TO, addresses); &#125; //设置抄送人的电子邮件 if (emailCCs != null &amp;&amp; !emailCCs.isEmpty()) &#123; int size = emailCCs.size(); InternetAddress[] addresses = new InternetAddress[size]; for (int i = 0; i &lt; size; i++) &#123; addresses[i] = new InternetAddress(emailCCs.get(i)); &#125; msg.setRecipients(Message.RecipientType.CC, addresses); &#125; msg.setSubject(title); //创建一个消息体 MimeBodyPart msgBodyPart = new MimeBodyPart(); msgBodyPart.setText(context); //创建Multipart增加其他的parts Multipart mp = new MimeMultipart(); mp.addBodyPart(msgBodyPart); //创建文件附件 if (paths != null) &#123; for (String path : paths) &#123; MimeBodyPart fileBodyPart = new MimeBodyPart(); fileBodyPart.attachFile(path); mp.addBodyPart(fileBodyPart); &#125; &#125; //增加Multipart到消息体中 msg.setContent(mp); //设置日期 msg.setSentDate(new Date()); //设置附件格式 MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap(); mc.addMailcap("text/html;; x-java-content-handler=com.sun.mail.handlers.text_html"); mc.addMailcap("text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml"); mc.addMailcap("text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain"); mc.addMailcap("multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed"); mc.addMailcap("message/rfc822;; x-java-content-handler=com.sun.mail.handlers.message_rfc822"); CommandMap.setDefaultCommandMap(mc); //发送消息 Transport.send(msg); &#125; class MyAuthenticator extends Authenticator &#123; private String strUser; private String strPwd; public MyAuthenticator(String user, String password) &#123; this.strUser = user; this.strPwd = password; &#125; protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(strUser, strPwd); &#125; &#125; class MyAsynTask extends AsyncTask&lt;Void, Void, SendStatus&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); if (EmailInfterface != null) &#123; EmailInfterface.startSend(); &#125; &#125; @Override protected void onPostExecute(SendStatus result) &#123; super.onPostExecute(result); if (EmailInfterface != null) &#123; EmailInfterface.SendStatus(result); &#125; sendStatus = SendStatus.UNDO; &#125; @Override protected SendStatus doInBackground(Void... params) &#123; try &#123; sendStatus = SendStatus.SENDING; sendEmailBg(); sendStatus = SendStatus.SENDOK; &#125; catch (Exception e) &#123; String message = e.getMessage(); Log.v(TAG, "邮件发送失败的原因--》" + message); SendStatus sendStatus = CheckErrorUtils.checkExcption(message); e.printStackTrace();// MyEmailHelper.this.sendStatus = SendStatus.SENDFAIL; MyEmailHelper.this.sendStatus = sendStatus; &#125; return sendStatus; &#125; &#125;&#125; 3. 具体发送方法1234567891011121314151617181920212223242526272829303132333435363738 public void sendMail(String from, String to, String title, String context) &#123;// 附件// List&lt;String&gt; files = new ArrayList&lt;String&gt;();// files.add("/mnt/sdcard/test.txt"); //主要接收人的电子邮箱列表 List&lt;String&gt; toEmail = new ArrayList&lt;String&gt;(); toEmail.add(to); List&lt;String&gt; ccEmail = new ArrayList&lt;String&gt;(); //抄送人的电子邮箱列表 抄送给自己 防止被检测为垃圾邮件 ccEmail.add(from); helper.setParams(toEmail, ccEmail, title, context, null); Log.v(TAG, "toEmail:" + toEmail + " ccEmail:" + ccEmail + " EMAIL_TITLE_APP:" + title + " appEmailContext:" + context); helper.setJieEmailInfterface(new MyEmailHelper.EmailInfterface() &#123; @Override public void startSend() &#123; Toast.makeText(MainActivity.this, "邮件发送中~", Toast.LENGTH_LONG).show(); &#125; @Override public void SendStatus(MyEmailHelper.SendStatus sendStatus) &#123; switch (sendStatus) &#123; case SENDOK: Toast.makeText(MainActivity.this, "发送邮件成功~", Toast.LENGTH_LONG).show(); break; case SENDFAIL: Toast.makeText(MainActivity.this, "发送邮件失败~", Toast.LENGTH_LONG).show(); break; case SENDING: Toast.makeText(MainActivity.this, "邮件正在发送中，请稍后重试~", Toast.LENGTH_LONG).show(); break; case BADCONTEXT: Toast.makeText(MainActivity.this, "邮件内容或标题被识别为垃圾邮件，请修改后重试~", Toast.LENGTH_LONG).show(); break; &#125; &#125; &#125;); helper.sendEmail(); &#125; 4. 发送失败原因检查12345678910111213package lillusory.com.androidemail;import android.util.Log;public class CheckErrorUtils &#123; public static MyEmailHelper.SendStatus checkExcption(String message)&#123; if(message.contains("554 DT:SPM"))&#123; //发送失败原因有很多 这个是比较常见的问题 Log.v("Az","邮件被识别为垃圾邮件了~"); &#125; return MyEmailHelper.SendStatus.BADCONTEXT; &#125;&#125; 5. 网络权限记得添加网络权限 点击下载Demo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo搭建个人博客之（三）--部署篇]]></title>
    <url>%2Fposts%2F41257.html</url>
    <content type="text"><![CDATA[本章主要记录了如何将博客部署至云端，怎么设置个性域名，怎么将自己的网站提交到百度Google。让自己的网站能够出现在各大搜索引擎的具体方法和过程，希望能对大家有帮助。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 购买个性域名估计大家折腾了这么久也就是为 了拥有一个自己的个性站点,所以强烈建议大家为自己的博客站点配置一个独一无二的个性域名.我这里选择阿里旗下的万网。我的域名是www.lixueduan.com 大家可以选择一个自己喜欢的域名。等部署完毕就可以通过域名访问自己的博客了。 问题： GithubPages/CodingPages Github Pages是Github免费提供给开发者的一款托管个人网站的产品。 Coding Pages也是Coding免费提供给开发者的一款托管个人网站的产品。 关于为什么要部署两次 虽然可以根据自定义域名来访问自己的博客了，但是百度谷歌上都搜索不到，那岂不是很难受╮(╯▽╰)╭。 所以接下来为了让自己的博客能够被搜索出来，就需要让百度谷歌收录我们的网站。在部署收录过程中发现，Github屏蔽了百度的爬虫，所以搭建上GithubPages的话无法提交至百度，只有Google可以收录。 所以为了让百度收录我们网站，就得在Coding上也搭建一个。 同时在搭建的过程中发现如果先搭建在Github上，然后再搭建Coding时会出现DNS解析冲突。所以需要：先搭建Coding上的，再搭建Github上的，国外的访问则走Github，国内的访问会走Coding，完美 2. 部署到CodingPages2.1 注册coding账户 点击这里注册Coding](https://coding.net/) 2.2 创建新项目 注册好后创建一个项目用来部署个人博客，项目路径和项目名称最好和用户名一致 2.3 开启CodingPages 点击Pages服务，然后一键开启。 部署master分支 自定义域名 可以填两个 www.xxx.com 和xxx.com 绑定自定义域名的时候需要在买域名的地方(我这里是阿里的万网)配置DNS解析 1234567添加两条CNAME解析主机记录 一个@，一个www//@就是无前缀，xxx.com, www就是www.xxx.com解析路线 默认就行记录值 lillusory.coding.me //这里改成自己的 然后可以开启Https访问。 到这里就可以通过个性域名访问啦。不过现在博客代码还没有push到项目里。 2.4 Push代码到Coding配置SSH key 首先需要配置一个SSHkey，Git有Http协议和Git协议两种。我们这里使用Git协议就需要配置一个SSH key,等会部署到Github上也需要配置这个。 具体配置方法如下： Git 配置及SSH key 修改站点配置文件 这里只配置了Coding，可以先把Github的注释掉 12345678# Deployment 部署到云端相关配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: github: git@github.com:illusorycloud/illusorycloud.github.io.git coding: git@git.coding.net:illusorycloud/illusorycloud.git branch: master 地址在这里： 配置好后，运行hexo g时就可以把博客部署到Coding上了，也可以通过个性域名访问了。 3. 收录到百度3.1 网站添加直接百度搜索你的域名,比如我的www.lixueduan.com ，如果没有收录就会提示暂未收录，点击提交网址。 点击这个链接进入百度站长平台，登录成功后选择`用户中心–&gt;站点管理–&gt;添加网站 输入自己的网站，如www.lixueduan.com 协议头如果开启了https就选https 3.2 网站验证然后会验证这个网站是不是你的，选CNAME验证 然后去域名哪里添加一条解析即可。 记录类型–&gt;CNAME 主机记录—&gt;前面那一串l3rUDBLOMX 记录值–&gt;后面那个ziyuan.baidu.com 其他的都按默认的就行了，添加后别删除，需要一直留着。 3.3 站点地图接下来我们需要生成网站地图sitemap,使用sitemap方式向百度提交我们的网址 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件 12npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 在站点配置文件中添加如下代码 12345678Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了. 然后将博客重新部署后就可以直接访问站点地图了。如https://www.lixueduan.com/baidusitemap.xml 然后将这个站点地图提交到百度 站点管理--&gt;站点属性--&gt;链接提交--&gt;自动提交--&gt;sitemap 完成后就算是提交成功了，百度比较慢，要好几天才能收录。 4. 部署到GitHub步骤和Coding差不多的。 4.1 注册Github账号点这里注册Github账号 4.2 创建新仓库也是名字必须和用户名一样，必须按照这个格式username.github.io，例如lillusorycloud.github.io 创建好仓库后找到Setings 往下拉，找到Github Pages 设置Custom domain填下自定义域名，如www.lixueduan.com.如果有Enforce HTTPS选项也可以勾上。 4.3 Push代码到Github配置SSH key 首先需要配置一个SSHkey，Git有Http协议和Git协议两种。我们这里使用Git协议就需要配置一个SSH key,等会部署到Github上也需要配置这个。 具体配置方法： Git 配置及SSH key 修改站点配置文件 repository中添加一个github 12345678# Deployment 部署到云端相关配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: github: git@github.com:illusorycloud/illusorycloud.github.io.git coding: git@git.coding.net:illusorycloud/illusorycloud.git branch: master 配置好后，运行hexo g时就可以把博客同时部署到Coding和Github上了，也可以通过个性域名访问了。 5. 收录到Google和百度差不多。 5.1 网站添加首先进入Google站点平台 然后添加资源，注意http和https 5.2 验证所有权然后验证所有权,选择DNS供应商 供应商选择其他，然后选择添加CNAME记录，在域名解析中添加一条记录。也是添加后不要删除。 5.3 站点地图验证后就可以添加站点地图了 提交成功后,我们的站点就已经被Google收录了.大概一天就能收录成功，比百度块一些。 6. 总结本文主要讲了怎么将博客部署到Coding和Github和怎么让百度,Google收录我们的网站。 7.参考Hexo官方文档 基于Hexo的个人博客 Hex博客搭建]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo搭建个人博客之（二）--主题优化篇]]></title>
    <url>%2Fposts%2F58273.html</url>
    <content type="text"><![CDATA[本章主要包含了博客主题优化相关内容，第三方服务和插件的配置与使用。如：炫酷头像动态背景、链接变色、鼠标点击效果、站点字数、访客数统计等。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 更多文章欢迎访问我的个人博客–&gt;幻境云图 0. 选择主题你可以点击这里选择你喜欢的Themes,里面有大量美观的主题 我这里用的是简约著称的Next主题. 下载主题 使用git命令下载该主题到本地. git clone https://github.com/theme-next/hexo-theme-next themes/next clone成功后,你的Themes文件夹下就会有next主题文件了. Hexo配置文件: 都叫_config.yml 一份位于站点根目录下，主要包含 Hexo 本身的配置,称为 站点配置文件 另一份位于主题目录下主要用于配置主题相关的选项,称为主题配置文件 开启主题 站点配置文件进行修改: 将theme: landscape修改为 theme: next 1. 侧边栏头像设置新版next注意引入了该功能,直接在主题配置文件修改即可,如下: 123456789# Sidebar Avatar 头像avatar: url: /images/avatar.gif # 圆形头像 rounded: true # 透明度 0~1之间 opacity: 1 # 头像旋转 rotated: true 2. 设置个人社交图标链接直接在主题配置文件修改即可,如下: 123456789101112131415161718192021# Social Links. 社交链接 前面为链接地址 后面是图标 social: GitHub: https://github.com/illusorycloud || github E-Mail: mailto:xueduan.li@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype# 图标配置 social_icons: #是否显示图标 enable: true #是否只显示图标 icons_only: false #是否开启图标变化(就是刷新后会变颜色) transition: false 3. 添加菜单项1.先在主题配置文件修改 12345678menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive AAAAA: /BBBBB/ || CCC其中AAA 为菜单项的名字,BBB是路径,CCC是菜单项显示的图标 next 使用的是 Font Awesome 提供的图标 ,在这里可以选择自己喜欢的图标. 2.生成上述路径的文件 git命令行输入 hexo new page BBB –其中BBB替换为具体的名字,会在站点目录\source下新增一个BBB文件夹,文件夹中有一个index.md文件，需要在文件头中增加一句type: XXX,例如type: categories。这样就会在这个页面显示所有的分类了。 3.修改主题文件下的对应语言的配置文件,这里是中文就修改zh-CN.yml 12345menu: home: 首页 archives: 归档 AAAA : XXXXAAA为上边的菜单项名字,XXX为中文的名字 4. 添加RSS 1.安装插件 首先在Git中运行npm install --save hexo-generator-feed命令,安装插件,插件会放在 node_modules文件夹里面. 2.修改站点配置文件 安装好插件后,打开站点配置文件_config.yml`,在末尾加入以下代码: 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 3.修改主题配置文件 打开主题配置文件_config.yml,找到rss 添加配置:rss: /atom.xml 5. 设置酷炫动态背景next主题提供了两种背景可以选择. 第一种背景（我是用的这种） 新版本的next主题的话直接在主题配置文件中,找到canvas-nest 修改为canvas-nest: true, 123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 进入theme/next目录 执行命令git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 第二种背景 12345678# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 也是需要下载依赖 进入theme/next目录 执行命令：git clone https://github.com/theme-next/theme-next-three source/lib/three 4个背景中只能开启一种背景,不然会出错 6. 设置网站logo把你的图片放在themes/next/source/images里 打开主题配置文件_config.yml ,找到字段favicon: 都修改为对应路径 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 7. 实现点击出现桃心效果themes/next/source/js/src里面 新建一个love.js, 复制下面的代码进去 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 然后打开\themes\next\layout\_layout.swig文件,在末尾 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 8. 修改文章内链接文本样式鼠标移动到连接上变颜色 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 9. 设置顶部滚动加载条打开next\layout\_partials\head文件，在文件末尾添加以下代码: 123456789101112131415&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 10. 在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout\_macro 中新建 page-end-tag.swig 文件,并添加以下内容： 123456&lt;!--文字可以自己修改--&gt;&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #A2CD5A;font-size:15px;"&gt;------------------本文到此结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读------------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加下面的代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'page-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记page_end_tag: enabled: true 11. 静态资源压缩Hexo自动生成的html中有很多空白的地方,会影响加载速度,所以最好还是压缩一下. 这里使用hexo-neat插件来压缩。 安装插件 npm install hexo-neat --save 在站点配置文件添加配置 1234567891011121314151617181920212223242526# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude: # 压缩css 跳过min.cssneat_css: enable: true exclude: - '**/*.min.css' # 压缩js 跳过min.jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' - '**/love.js'# 压缩博文配置结束 3.使用 以后再执行hexo g命令时就会自动压缩了 12. 主页文章添加阴影效果打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 13. 修改文章底部的的标签样式打开模板文件/themes/next/layout/_macro/post.swig，找到rel=&quot;tag&quot;&gt;#字段， 将# 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;,其中tag是你选择标签图标的名字,也是可以自定义的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 14. 实现文章字数统计和预计阅读时间1.在站点根目录下使用GitBash命令安装 hexo-wordcount插件: 1npm install hexo-symbols-count-time --save 2.在全局配置文件_config.yml中激活插件: 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 3.在主题的配置文件_config.yml中进行如下配置: 1234567#字数统计symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 4 wpm: 275 到此,我们就实现了文章字数统计和预估时间的显示功能 15. 在文章底部增加版权信息修改主题配置文件,找到creative_commons字段 12345678910# Creative Commons 4.0 International License.# https://creativecommons.org/share-your-work/licensing-types-examples# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: #选择一个License license: by-nc-sa #是否在侧边栏显示 sidebar: false #是否在文章末尾显示 post: true 16. 文章置顶打开文件：node_modules/hexo-generator-index/lib/generator.js,将原来的代码用下面的代码替换掉 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 写文章的时候,在标题加上top值,数值越大排在越前面. 1234tag: hexo copyright: truepassword: xxxtop: 150 17. 在网站底部加上访问量Next主题配置这个就比较方便了 打开主题配置文件，找到如下配置： 12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 将enable的值由false改为true，便可以看到页脚出现访问量. 另外本地预览时访客数异常是正常的,部署至云端后就不会出现这样的问题. 18. 网站搜索功能1.安装插件 ​ 站点目录下执行命令npm install hexo-generator-searchdb --save 2.修改站点配置文件 12345search: path: search.xml field: post format: html limit: 10000 3.修改主题配置文件 1234567891011# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: enable # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 重新开启服务后即可看到效果。 TODO开启留言评论功能//TODO 待更新 参考Hexo官方文档 Next官方文档]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo搭建个人博客之（一）--基础篇]]></title>
    <url>%2Fposts%2F18973.html</url>
    <content type="text"><![CDATA[本文主要记录了如何搭建自己的博客。基于Hexo框架在本地搭建自己博客的全过程，包括了环境准备到Hexo初始化，再到服务的开启等。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 环境准备 Git Git下载地址 Node.js Node.js下载地址 小白式安装，一直下一步就ok了。 都安装好后就可以开始安装Hexo啦. 2. 安装Hexo 1.新建一个文件夹,用于安装Hexo,以后这个就是放博客文件的. 2.在此文件夹右键,Git Bash Here,打开Git 3.安装Hexo 命令npm install -g hexo 4.初始化Hexo 命令hexo init 5.安装组件 命令npm install 到此为止,Hexo就算是安装完成了。 3. 开启服务 1.hexo generate或者简写hexo g 编译,生成静态文件,就是生成一个个html文件. 2.开启服务hexo server或者hexo s 成功开启后就可以在本地访问了。 http://localhost:4000 假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，hexo server -p 端口号来改变端口号 如hexo server -p 5000 将端口号换为5000,默认是4000 3.常用命令 hexo clean 清除缓存文件 hexo deploy或者hexo d 部署网站到云端,这个后面再讲。 参考Hexo官方文档]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC和三层架构 (集中式)及SSM框架整合]]></title>
    <url>%2Fposts%2F760fc833.html</url>
    <content type="text"><![CDATA[本文主要讲了MVC和三层架构的关系，和SSM框架整合教程。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1.三层架构整体分为三层,表现层UI,业务逻辑层BLL,数据访问层DAL. 表现层 Controller 用户界面,负责与用户进行交互 业务逻辑层 Service 具体的业务操作 数据访问层 Dao 对数据库进行操作,为上层提供数据 为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间的耦合。 2.MVC MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写 . Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 3.MVC与三层架构 经典三层架构和MVC的关系？—–&gt; 他们是两个毫无相关的东西 经典三层架构是一种分层思想，将开发模式分为了这三层 MVC是一种设计模式，目的是让HTML代码和业务逻辑代码分开，让代码看起来更加清晰，便于开发 4.SSM框架和三层架构SSM即SpringMVC、Spring、Mybatis三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。 SpringMVC：作为View层的实现者，完成用户的请求接收功能。SpringMVC的Controller作为整个应用的控制器，完成用户请求的转发及对用户的响应。 MyBatis：作为 Dao层的实现者，完成对数据库的增、删、改、查功能。 Spring：以整个应用大管家的身份出现。整个应用中所有的Bean的生命周期行为，均由Spring来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由Spring进行管理。 5.SSM框架配置5.1 目录 Controller springmvc.xml 包扫描–controller 注解驱动 视图解析器 web.xml DispatcherServlet 监听器 Service applicationContext-service.xml 包扫描–service applicationContext-trans.xml 事务管理器 通知 切面 Dao SqlMapConfig.xml applicationContext-dao.xml dataSource SqlSessionFactory 包扫描–mapper 5.2 springmvc.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置Controller扫描 --&gt; &lt;context:component-scan base-package="com.lillusory.crm.controller" /&gt; &lt;!-- 加载属性文件--&gt; &lt;context:property-placeholder location="classpath:crm.properties"/&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 5.3 applicationContext-dao123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt;&lt;!-- 配置 读取properties文件 jdbc.properties --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 配置 数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 设置MyBatis核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml" /&gt; &lt;!-- 设置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="typeAliasesPackage" value="com.lillusory.crm.domain"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 设置Mapper扫描包 --&gt; &lt;property name="basePackage" value="com.lillusory.crm.mapper" /&gt; &lt;/bean&gt;&lt;/beans&gt; 5.4 applicationContext-service.xml123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt;&lt;!-- 包扫描 --&gt;&lt;context:component-scan base-package="com.lillusory.crm.service"/&gt;&lt;/beans&gt; 5.5 applicationContext-trans.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="create*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.lillusory.crm.service.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 5.6 SqlMapConfig.xml123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!-- 暂时什么都不用配置 --&gt;&lt;/configuration&gt; 5.7 web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;Demo-CRM&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置spring --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置过滤器，解决post的乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置SpringMVC --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo-crm&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置springmvc什么时候启动，参数必须为整数 --&gt; &lt;!-- 如果为0或者大于0，则springMVC随着容器启动而启动 --&gt; &lt;!-- 如果小于0，则在第一次请求进来的时候启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo-crm&lt;/servlet-name&gt; &lt;!-- 所有的请求都进入springMVC / 拦截所有除了jsp /* jsp也拦截 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 5.8其他常用配置jdbc1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/kct?characterEncoding=utf-8jdbc.username=rootjdbc.password=root log4j123456# Global logging configurationlog4j.rootLogger=debug, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 参考https://juejin.im/post/5929259b44d90400642194f3]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(五)--从输入URL到页面加载的过程中发生了什么]]></title>
    <url>%2Fposts%2F5863.html</url>
    <content type="text"><![CDATA[本文主要对用户从浏览器输入URL到页面加载的这一过程进行了具体分析与叙述。包括：DNS解析、发送HTTP请求、TCP连接、服务器响应、浏览器解析渲染页面等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 总体来说分为以下几个过程: 1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面 6.连接结束 1. DNS解析解析域名，找到主机IP。如百度对应的IP为180.97.33.108 ,浏览器输入IP也可以访问到百度。 （1）浏览器会缓存DNS一段时间，一般2-30分钟不等。如果有缓存，直接返回IP，否则下一步。 （2）缓存中无法找到IP，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回IP，否则下一步。（在计算机本地目录etc下有一个hosts文件，hosts文件中保存有域名与IP的对应解析，通常也可以修改hosts科学上网或破解软件。） （3）进行了（1）（2）本地查询无果，只能借助于网络。路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这时一般都能够得到相应的IP。如果还是无果，只能借助于DNS递归解析了。 （4）这时，ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com顶级域名服务器，到baidu的域名服务器。 到这里，浏览器就获得了IP。在DNS解析过程中，常常会解析出不同的IP。比如，电信的是一个IP，网通的是另一个IP。这是采取了智能DNS的结果，降低运营商间访问延时，在多个运营商设置主机房，就近访问主机。电信用户返回电信主机IP，网通用户返回网通主机IP。当然，劫持DNS，也可以屏蔽掉一部分网点的访问，某防火长城也加入了这一特性。 2. TCP连接浏览器与网站建立TCP连接 浏览器利用IP直接与网站主机通信。浏览器发出TCP（SYN标志位为1）连接请求，主机返回TCP（SYN，ACK标志位均为1）应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认。浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP链接建立完成。 3. 发送HTTP请求浏览器发起HTTP请求 其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 请求行 请求行包括：请求方法，URL ， 协议版本 12请求行：请求方法 URL 协议版本 eg: GET index.html HTTP/1.1 请求报头 请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。常见的请求报头有: Accept,Accept-Charset,Accept-Encoding,Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 请求正文 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json 浏览器向主机发起一个HTTP请求。请求中包含访问的URL，也就是http://www.baidu.com/ ，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。 4. 服务器响应服务器对请求做出响应并返回HTTP响应报文。自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，例如Tomcat。 HTTP响应报文也是由三部分组成: 响应行, 响应报头和响应报文。 响应行 响应行包括：协议版本 状态码 状态码描述 12响应行包括：协议版本 状态码 状态码描述 eg: HTTP/1.1 200 OK 响应报头 常见的响应报头字段有: Server, Connection…。 响应报文 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 5. 浏览器解析渲染页面返回状态码200 OK，表示服务器可以相应请求，返回报文，由于在报头中Content-type:“text/html”，浏览器以HTML形式呈现，而不是下载文件。 浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的? 浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 重定向 负载均衡 但是，对于大型网站存在多个主机站点，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200 OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。 补充一点的就是，重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于lixueduan.com，www.lixueduan.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。 6. 连接结束在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 7. 计算机网络常见问题看完系列文章，下面这些问题应该也不是问题了。 1.TCP三次握手和四次挥手 2.在浏览器中输入url地址-&gt;&gt;显示主页的过程 3.HTTP和HTTPS的区别 4.TCP、UDP协议的区别 5.常见的状态码。 8. 参考https://segmentfault.com/a/1190000006879700]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(四)--HTTP与HTTPS]]></title>
    <url>%2Fposts%2F21307.html</url>
    <content type="text"><![CDATA[本文主要介绍了HTTP、HTTPS的基本概念及两者的区别，HTTPS的工作原理及优缺点，最后介绍了HTTP的响应状态码。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. HTTP和HTTPS基本概念 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 12HTTP--&gt; HTTP--&gt;TCP--&gt;IPHTTPS-&gt; HTTP--&gt;SSL--&gt;TCP--&gt;IP HTTPS协议的主要作用：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 2. HTTP与HTTPS的区别 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。 HTTPS和HTTP的区别: 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 3. HTTPS工作原理 我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 SSL协议的握手过程 分为五个步骤: 第一步，客户端给出SSL协议版本号、一个客户端生成的随机数1（Client random），以及客户端支持的加密方法。 第二步，服务端根据客服端支持的加密方法选出双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数2（Server random）。 第三步，客户端确认数字证书有效，然后生成一个新的随机数3（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。 第四步，服务端使用自己的私钥，获取客户端发来的随机数3（即Premaster secret）。到这里双方都拥有三个随机数了，为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。 第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。 第六步，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。 第七步，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。 4. HTTPS的优缺点 优点: （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 （4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高” 缺点: （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 5. HTTP响应状态码状态码以3位数字和原因短语组成，例如 200 OK 。 数字的第一位指定了响应类型，后两位无分类。响应类别一共有5种： 1XX Informational(信息性状态码) 2XX Success(成功状态码) 3XX Redirection(重定向状态码) 4XX Client Error(客户端错误状态码) 5XX Server Error(服务器错误状态码) 1234567891011121314151617181920212223200：请求成功 处理方式：获得响应的内容，进行处理 201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到 202：请求被接受，但处理尚未完成 处理方式：阻塞等待 204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL 304 请求的资源未更新 处理方式：丢弃 400 非法请求 处理方式：丢弃 401 未授权 处理方式：丢弃 403 禁止 处理方式：丢弃 404 没有找到 处理方式：丢弃 5XX 回应代码以“5”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求 处理方式：丢弃 6. HTTP长连接、短连接在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 https加密是在传输层 https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。 当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。 7. 参考https://www.cnblogs.com/qiangxia/p/5261813.html https://www.cnblogs.com/wqhwe/p/5407468.html http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(三)--TCP如何保证传输可靠性]]></title>
    <url>%2Fposts%2F18422.html</url>
    <content type="text"><![CDATA[本文主要叙述了TCP协议是如何保证传输的可靠性的，主要保证手段包括：序列号、校验和 、流量控制、拥塞控制、停止等待协议、超时重传、连接管理等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 主要保证方式 序列号:应用数据被分割成 TCP 认为最适合发送的数据块,同时给每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 停止等待协议(确认应答) 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 连接管理: 三次握手四次挥手,保证可靠的连接，是保证可靠性的前提。 2. 停止等待协议 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组； 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认； 1) 无差错情况: 发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。 2) 出现差错情况（超时重传）: [ 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。 3) 确认丢失和确认迟到 确认丢失：当确认消息在传输过程丢失 A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施： 丢弃这个重复的M1消息，不向上层交付。 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。 确认迟到 ：确认消息在传输过程中迟到 [A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下： A收到重复的确认后，直接丢弃。 B收到重复的M1后，也直接丢弃重复的M1。 3. ARQ协议即自动重传请求 ARQ 协议(Automatic Repeat reQuest )，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。 优点： 简单 缺点： 信道利用率低 4. 连续ARQ协议连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。 优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。 缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。 5. 流量控制 滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。 TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。 TCP 利用滑动窗口实现流量控制的机制。 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 6. 拥塞控制防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降 拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 几种拥塞控制方法 ​ 慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 慢开始和拥塞避免 ​ 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。 ​ 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。 拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 快重传与快恢复 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。 7.参考https://blog.csdn.net/liuchenxia8/article/details/80428157 https://blog.csdn.net/yangbodong22011/article/details/48473183]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(二)--TCP三次握手四次挥手]]></title>
    <url>%2Fposts%2F25338.html</url>
    <content type="text"><![CDATA[本文主要介绍了TCP/IP的三次握手和四次挥手具体步骤及其原因分析。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 三次握手 step1:第一次握手建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。 step2:第二次握手服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RCVD状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。 step3:第三次握手 客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTABLISHED (TCP连接成功)**状态，完成三次握手。 123456建立连接前要确认客户端和服务端的接收和发送功能是否正常。第一次客户端发送SYN时 什么也确认不了第二次服务端发送SYN+ACK 可以确认服务端发送功能正常第三次 客户端收到服务端发送的YSN+ACK 可以确认客户端发送接收功能正常最后客户端发送ACK 服务端接收到后 可以确认服务端发送功能正常到此就确认完毕了。 2. 四次挥手 step1：第一次挥手首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。 客户端进入FIN_WAIT1状态 1我（Client端）没有数据要发给你（Server端）了&quot;，但是如果你（Server端）还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK step2：第二次挥手服务器收到这个FIN进入CLOSE_WAIT状态，然后它给客户端发送一个ACK，确认ack为收到的序号加一。 客户端收到ACK应答后进入FIN_WAIT2状态 1告诉Client端，你的请求我收到了，但是我（Server端）还没准备好，请继续你等我的消息&quot; step3：第三次挥手服务端关闭服务器到客户端的连接，发送一个FIN给客户端。服务端进入LAST_ACK状态 1告诉Client端，好了，我（Server端）这边数据发完了，准备好关闭连接了 step4：第四次挥手 客户端收到FIN后，进入TIME_WAIT状态 并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。 服务端收到客户端回复的ACK后立即关闭，服务端进入CLOASED状态 而客户端要等待2MSL后关闭 进入CLOASED状态 1Client端收到FIN报文后，&quot;就知道可以关闭连接了，所以发送ACK。但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后没有立即，而是进入TIME_WAIT状态，如果Server端没有收到ACK那么自己还可以重传。Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 3. TIME-WAIT状态详解为什么Client端要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？ 保证TCP协议的全双工连接能够可靠关闭，保证这次连接的重复数据段从网络中消失 假设由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，Client端在等待2MSL时间后都没收到信息，说明Server端已经收到自己发送的ACK并且成功关闭了。假设CLient端直接关闭了： 1231.由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。2.如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。 2MSL:Maximum Segment Lifetime 即数据在网络中保存的最大时间。 简单易懂的说法: 1假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 4. TCP 的有限状态机红色为客户端 蓝色为服务端 细箭头为异常变化 5. 参考https://www.baidu.com/link?url=_mlor11BLttd1jmMU4k9OP0gqcjNKhZQ9fJuvbMOhkuH9-lVeB-y3VIVK1neZURi_tmR3rg1lj2lfgvvGhTV-q&amp;wd=&amp;eqid=d0144c250007b69c000000035bfdfafc]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(一)--OSI七层模型]]></title>
    <url>%2Fposts%2F25470.html</url>
    <content type="text"><![CDATA[本文主要通过OSI七层模型与常用TCP/IP5层模型介绍了各层的主要作用，包括应用层，运输层，网络层，数据链路层，物理层等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 OSI与TCP/IP模型 应用层:通过应用进程间的交互来完成特定网络应用。 运输层：向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。 网络层：通过路由算法，为报文或分组通过通信子网选择最适当的路径。 数据链路层：其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。 物理层：利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。 1. 应用层主要作用:通过应用进程间的交互来完成特定网络应用。 应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。 2. 运输层 主要任务：向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。 主要作用：向高层屏蔽下层数据通信的具体细节，即向用户透明的传送报文。 主要用到的协议： 传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 2.1 UDP UDP 是无连接的； UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP 是面向报文的； UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）； UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 2.2 TCP TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 3. 网络层主要任务：通过路由算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与物理层之间的信息转发，建立、维持与终止网络的连接。具体的说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。 一般的，数据链路层是解决统一网络内节点之间的通信，而网络层主要解决不同子网之间的通信。例如路由选择问题。 在实现网络层功能时，需要解决的主要问题如下： 寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一 个唯一的地址。由于各个子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址） 交换：规定不同的交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者包括报文转发技术和分组转发技术。路由算法：当源节点和路由节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径，由发送端传送的接受端。连接服务：与数据链路层的流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测 4. 数据链路层其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。 主要功能：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 具体工作：接受来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上一层的数据帧，拆装为位流形式的数据转发到物理层；并且还负责处理接受端发回的确认帧的信息，以便提供可靠的数据传输。 该层通常又被分为 介质访问控制(MAC)和逻辑链路控制(LLC)两个子层： MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制。LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。 5. 物理层主要功能：利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。 作用：实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质与物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。 透明传输的意义就是：不管传的是什么，所采用的设备只是起一个通道作用，把要传输的内容完好的传到对方！ 在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。 6. 参考https://blog.csdn.net/yaopeng_2005/article/details/7064869]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(十二)--观察者模式]]></title>
    <url>%2Fposts%2F48bcf013.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的观察者模式，并结合实例描述了观察者模式的具体实现和优缺点分析。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 观察者模式介绍 让多个观察者对象同时监听某一个主题对象，这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。 该模式包含四个角色 抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。 具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。 2. 观察者模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*** * 抽象观察者 * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。 * */public interface Observer &#123; void update(String message);&#125;/*** * 抽象被观察者接口 * 声明了添加、删除、通知观察者方法 */public interface Observerable &#123; void registerObserver(Observer o); void removeObserver(Observer o); void notifyObserver();&#125;/** * 具体观察者 * 实现update方法 */public class User implements Observer &#123; private String name; private int age; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public void update(String message) &#123; System.out.println(age + "岁的" + name + "收到推送的消息：" + message); &#125;&#125;/** * 具体被观察者 * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现 */public class MyServer implements Observerable &#123; private List&lt;Observer&gt; observerList; private String message; public MyServer() &#123; observerList = new ArrayList&lt;Observer&gt;(); &#125; @Override public void registerObserver(Observer o) &#123; observerList.add(o); &#125; @Override public void removeObserver(Observer o) &#123; if (!observerList.isEmpty()) &#123; observerList.remove(o); &#125; &#125; @Override public void notifyObserver() &#123; for (int i = 0; i &lt; observerList.size(); i++) &#123; Observer observer = observerList.get(i); observer.update(message); &#125; &#125; public void PushMessage(String message) &#123; this.message = message; System.out.println("推送消息：" + message); notifyObserver(); &#125;&#125;//测试public class Test &#123; public static void main(String[] args) &#123; MyServer myServer = new MyServer(); User lillusory = new User("lillusory", 22); User Az = new User("Az", 17); myServer.registerObserver(lillusory); myServer.registerObserver(Az); myServer.PushMessage("第一条推送消息"); System.out.println("-------------------------------"); myServer.removeObserver(Az);//Az取消注册后就收不到消息 User yiqixing = new User("意琦行", 999); myServer.registerObserver(yiqixing);//新增的观察者只能收到后面的消息 myServer.PushMessage("第二条推送消息"); &#125;&#125;//输出 推送消息：第一条推送消息 22岁的lillusory收到推送的消息：第一条推送消息 17岁的Az收到推送的消息：第一条推送消息 ------------------------------- 推送消息：第二条推送消息 22岁的lillusory收到推送的消息：第二条推送消息 999岁的意琦行收到推送的消息：第二条推送消息 3. 总结优点： 1.降低重复代码，使得代码更清晰、更易读、更易扩展 2.解耦，使得代码可维护性更好，修改代码的时候可以尽量少改地方 应用场景： 1.对一个对象状态的更新需要其他对象同步更新 2.对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节，如消息推送. 观察者模式在Java中的应用及解读 JDK是有直接支持观察者模式的，就是java.util.Observer这个接口： 12345678910111213public interface Observer &#123; /** * This method is called whenever the observed object is changed. An * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's * observers notified of the change. * * @param o the observable object. * @param arg an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt; * method. */ void update(Observable o, Object arg);&#125; 这就是观察者的接口，定义的观察者只需要实现这个接口就可以了。update()方法，被观察者对象的状态发生变化时，被观察者的notifyObservers()方法就会调用这个方法： 12345678910111213141516171819202122232425262728public class Observable &#123; private boolean changed = false; private Vector obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector(); &#125; /** * Adds an observer to the set of observers for this object, provided * that it is not the same as some observer already in the set. * The order in which notifications will be delivered to multiple * observers is not specified. See the class comment. * * @param o an observer to be added. * @throws NullPointerException if the parameter o is null. */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; ...&#125; 这是被观察者的父类，也就是主题对象。 4. 参考https://www.cnblogs.com/xrq730/p/4908686.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(十一)---模板方法模式]]></title>
    <url>%2Fposts%2F57ae709c.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的模板方法模式，并结合实例描述了模板方法模式的具体实现和优缺点分析。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介模板方法模式是类的行为模式。 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。 这就是模板方法模式的用意。 抽象模板(Abstract Template)角色有如下责任： 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任： 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 2. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150假设泡茶喝咖啡都需有四个步骤：1.烧水 2.泡茶/冲咖啡 3.倒入杯子 4.添加调味品那么可以写一个抽象类，因为大多数饮料都可以看成这四个步骤。然后烧水和倒入杯子这两个步骤都是相同的，那么在抽象类中可以直接实现，然后其他特殊操作则由子类具体实现。/** * 模板方法模式 * 抽象模板角色 * * @author illusoryCloud */public abstract class BaseCreatDrink &#123; /** * 按顺序调用其他方法 */ public void doCreate() &#123; boilWater(); brew(); pourInCup(); if (isNeedCondiments()) &#123; addCondiments(); &#125; &#125; /** * 烧开水 * 通用的方法 直接实现 */ private void boilWater() &#123; System.out.println("烧开水~"); &#125; /** * 特殊操作，在子类中具体实现 */ public abstract void brew(); /** * 倒入杯中 * 通用的方法 直接实现 */ private void pourInCup() &#123; System.out.println("倒入杯中~"); &#125; /** * 添加调味品 茶里面加柠檬 咖啡中加糖等等 * 特殊操作 * 具体由子类实现 */ public abstract void addCondiments(); /** * 钩子方法，决定某些算法步骤是否挂钩在算法中 * 子类可以重写该类来改变算法或者逻辑 */ public boolean isNeedCondiments() &#123; return true; &#125;&#125;/** * 具体模板角色 * 纯茶 * * @author illusoryCloud */public class CreatTea extends BaseCreatDrink &#123; @Override public void brew() &#123; System.out.println("泡茶~"); &#125; @Override public void addCondiments() &#123; System.out.println("加柠檬~"); &#125;&#125;/** * 具体模板角色 * 茶 * * @author illusoryCloud */public class CreatPureTea extends BaseCreatDrink &#123; @Override public void brew() &#123; System.out.println("泡茶~"); &#125; @Override public void addCondiments() &#123; System.out.println("加柠檬~"); &#125; /** * 通过重写钩子方法来改变算法 * 返回true则添加调味品 * 返回false则不加 * 默认为true * * @return isNeedCondiments */ @Override public boolean isNeedCondiments() &#123; return false; &#125;&#125;/** * 具体模板角色 * 咖啡 * * @author illusoryCloud */public class CreatCoffee extends BaseCreatDrink &#123; @Override public void brew() &#123; System.out.println("冲咖啡~"); &#125; @Override public void addCondiments() &#123; System.out.println("加糖~"); &#125;&#125;/** * 模板方法模式 测试类 * * @author illusoryCloud */public class TemplateTest &#123; @Test public void templateTest() &#123; System.out.println("-------茶-------"); CreatTea tea = new CreatTea(); tea.doCreate(); System.out.println("-------咖啡-------"); CreatCoffee coffee = new CreatCoffee(); coffee.doCreate(); System.out.println("-------纯茶-------"); CreatPureTea pureTea = new CreatPureTea(); pureTea.doCreate(); &#125;&#125;//输出往锅里加的是白菜~炒啊炒啊炒~菜炒好了，起锅~往锅里加的是肉~炒啊炒啊炒~菜炒好了，起锅~ 3. 总结模板方法模式在Java中的应用 最常见的就是Servlet了。 HttpServlet担任抽象模板角色 模板方法：由service()方法担任。 基本方法：由doPost()、doGet()等方法担任。 MyServlet担任具体模板角色 自定义的servlet置换掉了父类HttpServlet中七个基本方法中的其中两个，分别是doGet()和doPost()。 4. 参考https://www.cnblogs.com/qiumingcheng/p/5219664.html https://www.cnblogs.com/yanlong300/p/8446261.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(十)---策略模式]]></title>
    <url>%2Fposts%2Fa7982bdc.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的策略模式，并结合实例描述了策略模式的具体实现和策略模式的优缺点分析。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介 策略模式是对算法的包装 策略模式定义了一系列的算法，并将每一个算法封装起来，而且它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 这个模式涉及到三个角色： ● 环境(Context)角色：持有一个Strategy的引用。 ● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 ● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 2. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 策略模式 抽象策略角色 * 定义一个两个整数间的计算方法 * * @author illusoryCloud */public interface Strategy &#123; /** * 两个整数间的计算方法 * * @param a * @param b * @return */ int calculate(int a, int b);&#125;/** * 策略模式 具体策略角色 * 加法 * * @author illusoryCloud */public class AddStrategy implements Strategy &#123; @Override public int calculate(int a, int b) &#123; return a + b; &#125;&#125;/** * 策略模式 具体策略角色 * 减法 * * @author illusoryCloud */public class SubtractionStrategy implements Strategy &#123; @Override public int calculate(int a, int b) &#123; return a - b; &#125;&#125;/** * 策略模式 具体策略角色 * 乘法 * * @author illusoryCloud */public class MultiplyStrategy implements Strategy &#123; @Override public int calculate(int a, int b) &#123; return a * b; &#125;&#125;/** * 策略模式 具体策略角色 * 除法 * * @author illusoryCloud */public class DivisionStrategy implements Strategy &#123; @Override public int calculate(int a, int b) &#123; if (b != 0) &#123; return a / b; &#125; else &#123; throw new RuntimeException("除数不能为零"); &#125; &#125;&#125;/** * 策略模式 环境角色 * * @author illusoryCloud */public class Context &#123; /** * 持有Strategy的引用 */ private Strategy strategy; public Context(Strategy strategy) &#123; super(); this.strategy = strategy; &#125; public Strategy getStrategy() &#123; return strategy; &#125; /** * set方法可以完成策略更换 */ public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public int calculate(int a, int b) &#123; return strategy.calculate(a, b); &#125;&#125;/** * 策略模式 测试类 * * @author illusoryCloud */public class StrategyTest &#123; @Test public void strategyTest() &#123; //加法 Context context = new Context(new AddStrategy()); System.out.println(context.calculate(5, 5)); //减法 Context context2 = new Context(new SubtractionStrategy()); System.out.println(context2.calculate(5, 5)); //乘法 Context context3 = new Context(new MultiplyStrategy()); System.out.println(context3.calculate(5, 5)); //除法 Context context4 = new Context(new DivisionStrategy()); System.out.println(context4.calculate(5, 5)); &#125;&#125; 3. 总结策略模式的重心不是如何实现算法（就如同工厂模式的重心不是工厂中如何产生具体子类一样），而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 策略模式与状态模式 策略模式与状态模式及其相似，但是二者有其内在的差别，策略模式将具体策略类暴露出去，调用者需要具体明白每个策略的不同之处以便正确使用。而状态模式状态的改变是由其内部条件来改变的，与外界无关，二者在思想上有本质区别。 优点 1.让代码更优雅，避免了多重条件if…else语句。 2.策略模式提供了管理相关算法簇的办法，恰当使用继承可以把公共代码移到父类，从而避免了代码重复。 缺点 1.客户端必须知道所有的策略类，并自行决定使用 哪一个策略，这意味着客户端必须理解这些算法的区别，以便选择恰当的算法 2.如果备选策略很多，对象的数据会很多 4. 参考https://www.cnblogs.com/xrq730/p/4906313.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举式单例模式与序列化]]></title>
    <url>%2Fposts%2Fdff2f393.html</url>
    <content type="text"><![CDATA[本文主要记录了单例模式中的枚举式写法和序列化与反序列化安全问题，通过分析源码说明了为什么枚举式单例是序列化安全的。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 问题Java中单例模式大概有五种：饿汉式、静态内部类、懒汉式、双重校验锁、枚举式。 静态内部类和双重校验锁已经这么优秀了为什么还要有第五种枚举式呢？ 因为前面4种都存在一个序列化和反序列化时的安全问题。将单例对象序列化后，在反序列化时会重新创建一个单例对象，违背了单例模式的初衷。而枚举式单例则没有这个问题。更多Java单例模式信息请阅读:Java设计模式(一)—单例模式。 2. 分析序列化可能会破坏单例模式，比较每次反序列化一个序列化的对象实例时都会创建一个新的实例,枚举类单例可以解决该问题。枚举序列化是由jvm保证的，每一个枚举类型和定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定：在序列化时Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf()方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的并禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，从而保证了枚举实例的唯一性. Enum类的valueOf方法: 12345678910public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException("Name is null"); throw new IllegalArgumentException( "No enum constant " + enumType.getCanonicalName() + "." + name); &#125; 实际上通过调用enumType(Class对象的引用)的enumConstantDirectory()方法获取到的是一个Map集合，在该集合中存放了以枚举name为key和以枚举实例变量为value的Key&amp;Value数据，因此通过name的值就可以获取到枚举实例. enumConstantDirectory()方法： 12345678910111213141516Map&lt;String, T&gt; enumConstantDirectory() &#123; if (enumConstantDirectory == null) &#123; //getEnumConstantsShared最终通过反射调用枚举类的values方法 T[] universe = getEnumConstantsShared(); if (universe == null) throw new IllegalArgumentException( getName() + " is not an enum type"); Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length); //map存放了当前enum类的所有枚举实例变量，以name为key值 for (T constant : universe) m.put(((Enum&lt;?&gt;)constant).name(), constant); enumConstantDirectory = m; &#125; return enumConstantDirectory; &#125; private volatile transient Map&lt;String, T&gt; enumConstantDirectory = null; 到这里我们也就可以看出枚举序列化确实不会重新创建新实例，jvm保证了每个枚举实例变量的唯一性。 通过反射获取构造器并创建枚举 : 123456public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123; Constructor&lt;SingletonEnum&gt; constructor=SingletonEnum.class.getDeclaredConstructor(String.class,int.class); constructor.setAccessible(true); //创建枚举 SingletonEnum singleton=constructor.newInstance("otherInstance",9); &#125; 执行报错 12345678Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.lang.reflect.Constructor.newInstance(Constructor.java:417) at zejian.SingletonEnum.main(SingletonEnum.java:38) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144) 显然不能使用反射创建枚举类，这是为什么呢？在newInstance()方法中找找原因。 newInstance()方法： 123456789101112131415161718192021public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); &#125; &#125; //这里判断Modifier.ENUM是不是枚举修饰符，如果是就抛异常 if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException("Cannot reflectively create enum objects"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings("unchecked") T inst = (T) ca.newInstance(initargs); return inst; &#125; 源码显示确实无法使用反射创建枚举实例，也就是说明了创建枚举实例只有编译器能够做到而已。 3. 结论显然枚举单例模式确实是很不错的选择，因此我们推荐使用它。 不过由于使用枚举时占用的内存常常是静态变量的两倍还多，因此android官方在内存优化方面给出的建议是尽量避免在android中使用enum。 但是不管如何，关于单例，我们总是应该记住：线程安全，延迟加载，序列化与反序列化安全，反射安全是很重重要的。 4. 参考https://blog.csdn.net/javazejian/article/details/71333103#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(九)---享元模式]]></title>
    <url>%2Fposts%2F34e634e7.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的享元模式，并结合实例描述了享元模式的具体实现，具体优缺点和单例模式的对比。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 享元模式介绍享元模式：“享”就是分享之意，指一物被众人共享，而这也正是该模式的终旨所在。 享元模式有点类似于单例模式，都是只生成一个对象来被共享使用。存储这些共享实例对象的地方称为享元池 。享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。如围棋中的的黑棋白棋，不会随外部环境的变化而变化，无论在任何环境下黑棋始终是黑棋。 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。比如每颗棋子的位置是不同的。 围棋中的黑棋和白棋可以是共享的对象，不用每次都创建一个新的对象。这样就只需要创建黑棋和白棋两个对象了。颜色是不会变得，所以是内部状态。落下得位置是随机的，所以作为外部状态。 2. 单纯享元模式 在单纯的享元模式中，所有的享元对象都是可以共享的。 单纯享元模式所涉及到的角色如下： ● 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。 ● 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。 ● 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 单纯享元模式 抽象享元角色 * * @author illusoryCloud */public interface Ball &#123; /** * 简单的show方法 * 根据传入的参数(外蕴状态)不同而产生不同的表现 * * @param color 外蕴状态 */ void show(String color);&#125;/** * 单纯享元模式 具体享元角色 * 内蕴状态为type 即球的类型 由构造方法传入 * 外蕴状态为color 即球的颜色 作为show()方法的参数传入 * * @author illusoryCloud */public class ConcreteBall implements Ball &#123; private String type; public ConcreteBall(String type) &#123; this.type = type; &#125; @Override public void show(String color) &#123; System.out.println("这是一个：" + color + "的" + type); &#125;&#125; /** * 单纯享元模式 享元工厂角色 * * @author illusoryCloud */public class BallFactory &#123; /** * 将对象存在map中 */ private static Map&lt;String, Ball&gt; factory = new HashMap&lt;&gt;(); /** * 获取单纯享元角色 * * @param type 内蕴状态 * @return 具体享元角色 */ public Ball getBall(String type) &#123; Ball ball = factory.get(type); if (ball == null) &#123; //如果对象不存在则创建一个新的对象 ball = new ConcreteBall(type); //把这个新的Flyweight对象添加到缓存中 factory.put(type, ball); &#125; return ball; &#125; /** * 静态内部类 单例模式 */ private BallFactory() &#123; &#125; private static class SingletonHolder &#123; private static final BallFactory INSTANCE = new BallFactory(); &#125; public static BallFactory getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125;/** * 单纯享元模式 测试类 * * @author illusoryCloud */public class PureTest &#123; /** * 当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法， * 并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。 */ @Test public void flyWeightTest() &#123; BallFactory ballFactory = BallFactory.getInstance(); Ball basketball = ballFactory.getBall("篮球"); Ball football = ballFactory.getBall("足球"); basketball.show("红色"); basketball.show("黄色"); football.show("黑色"); football.show("白色"); Ball basketball2 = ballFactory.getBall("篮球"); Ball football2 = ballFactory.getBall("足球"); //true 都是同一个对象 System.out.println(basketball.equals(basketball2)); //true System.out.println(football.equals(football2)); &#125;&#125;//输出这是一个：红色的篮球这是一个：黄色的篮球这是一个：黑色的足球这是一个：白色的足球truetrue 3. 复合享元模式 在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。 复合享元角色所涉及到的角色如下： ● 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。 ● 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。 ● 复合享元(ConcreteCompositeFlyweight)角色 ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。 ● 享元工厂(FlyweightFactory)角色 ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * 复合享元模式 复合享元角色 * * @author illusoryCloud */public class CompositeBall implements Ball &#123; /** * 复合享元角色内部包含多个单纯享元角色 */ private Map&lt;String, Ball&gt; composite = new HashMap&lt;&gt;(); /** * 增加一个新的单纯享元对象到集合中 */ public void add(String type, Ball ball) &#123; composite.put(type, ball); &#125; /** * 遍历的方式挨个调用内部单纯享元角色的show方法 * * @param color 外蕴状态 */ @Override public void show(String color) &#123; Set&lt;String&gt; strings = composite.keySet(); for (String type : strings) &#123; Ball ball = composite.get(type); ball.show(color); &#125; &#125;&#125;/** * 复合享元模式 复合工厂角色 * * @author illusoryCloud */public class CompositeFactory &#123; private Map&lt;String, Ball&gt; factory = new HashMap&lt;String, Ball&gt;(); /** * 获取复合享元 * * @param types 类型集合 * @return 复合享元对象 包含多个单纯享元对象 */ public Ball getComposite(List&lt;String&gt; types) &#123; CompositeBall composteBall = new CompositeBall(); for (String type : types) &#123; composteBall.add(type, getPure(type)); &#125; return composteBall; &#125; /** * 获取单纯享元角色 * * @param type 内蕴状态 * @return 具体享元角色 */ public Ball getPure(String type) &#123; Ball ball = factory.get(type); if (ball == null) &#123; //如果对象不存在则创建一个新的对象 ball = new ConcreteBall(type); //把这个新的Flyweight对象添加到缓存中 factory.put(type, ball); &#125; return ball; &#125; /** * 静态内部类 单例模式 */ private CompositeFactory() &#123; &#125; private static class SingletonHolder &#123; private static final CompositeFactory INSTANCE = new CompositeFactory(); &#125; public static CompositeFactory getInstance() &#123; return CompositeFactory.SingletonHolder.INSTANCE; &#125;&#125;/** * 单纯享元模式 测试类 * * @author illusoryCloud */public class CompositeTest &#123; /** * 当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法， * 并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。 */ @Test public void flyWeightTest() &#123; CompositeFactory compositeFactory = CompositeFactory.getInstance(); Ball pure = compositeFactory.getPure("篮球"); Ball pure2 = compositeFactory.getPure("篮球"); pure.show("红色"); List&lt;String&gt; types = Arrays.asList("篮球", "足球", "排球"); Ball composite = compositeFactory.getComposite(types); Ball composite2 = compositeFactory.getComposite(types); composite.show("蓝色"); //false 复合享元角色不相同 System.out.println(composite.equals(composite2)); //true 单纯享元角色相同 System.out.println(pure.equals(pure2)); &#125;&#125;//输出这是一个：红色的篮球这是一个：蓝色的足球这是一个：蓝色的篮球这是一个：蓝色的排球falsetrue 4. 总结享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。 优点： 节约系统的开销，可以少创建对象。外部状态不会影响内部状态，可以在不同环境下进行共享哦。缺点： 享元模式使逻辑变得更加复杂，需要将享元对象分出内部状态和外部状态。 并且为了使对象可以共享，外部状态在很多情况下是必须有的，当读取外部状态时明显会增加运行时间。 享元模式使用的场景： 当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。 与单例模式的区别： 享元模式的目的是共享，避免多次创建耗费资源，减少不会要额内存消耗 。 单例模式的目的是限制创建多个对象以避免冲突等 。 5. 参考http://blog.csdn.net/lovelion&gt; https://blog.csdn.net/Hmily_hui/article/details/80917975]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(八)---外观模式]]></title>
    <url>%2Fposts%2F22a51705.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的外观模式，并结合实例描述了 模式的具体实现和性能分析测试。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介 它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。 外观模式结构： SubSystem: 子系统角色。表示一个系统的子系统或模块。 Facade: 外观角色，客户端通过操作外观角色从而达到控制子系统角色的目的。对于客户端来说，外观角色好比一道屏障，对客户端屏蔽了子系统的具体实现。 2. 具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 子系统角色类 * 电脑CPU * * @author illusoryCloud */public class CPU &#123; public void startUp()&#123; System.out.println("cpu is startUp..."); &#125; public void shutDown()&#123; System.out.println("cpu is shutDown..."); &#125;&#125;/** * 子系统角色类 * 电脑硬盘 * * @author illusoryCloud */public class Disk &#123; public void startUp() &#123; System.out.println("disk is startUp..."); &#125; public void shutDown() &#123; System.out.println("disk is shutDown..."); &#125;&#125;/** * 子系统角色类 * 电脑内存 * * @author illusoryCloud */public class Memory &#123; public void startUp() &#123; System.out.println("memory is startUp..."); &#125; public void shutDown() &#123; System.out.println("memory is shutDown..."); &#125;&#125;/** * 外观角色 * 电脑 * 用户通过操作当前类即可达到操作所有子系统的目的 * * @author illusoryCloud */public class Computer &#123; private CPU cpu; private Disk disk; private Memory memory; public Computer() &#123; cpu = new CPU(); disk = new Disk(); memory = new Memory(); &#125; public void startUp() &#123; cpu.startUp(); disk.startUp(); memory.startUp(); &#125; public void shutDown() &#123; cpu.shutDown(); disk.shutDown(); memory.shutDown(); &#125;&#125;/** * 外观模式 测试类 * * @author illusoryCloud */public class FacedeTest &#123; @Test public void facedeTest() &#123; Computer computer = new Computer(); computer.startUp(); System.out.println("------------------"); computer.shutDown(); &#125;&#125; 3. 总结外观模式的优点 外观模式有如下几个优点： 1、松散耦合 外观模式松散了客户端和子系统的耦合关系，让子系统内部的模块能更容易扩展和维护 2、简单易用 客户端不需要了解系统内部的实现，也不需要和众多子系统内部的模块交互，只需要和外观类交互就可以了 3、更好地划分层次 通过合理使用Facade，可以帮助我们更好地划分层次。有些方法是系统对内的，有些方法是对外的，把需要暴露给外部的功能集中到Facade中，这样既方便客户端使用，也很好地隐藏了内部的细节 4. Tomcat中的外观模式Tomcat中有很多场景都使用到了外观模式，因为Tomcat中有很多不同的组件，每个组件需要相互通信，但又不能将自己内部数据过多地暴露给其他组件。用外观模式隔离数据是个很好的方法，比如Request上使用外观模式。 比如Servlet，doGet和doPost方法，参数类型是接口HttpServletRequest和接口HttpServletResponse，那么Tomcat中传递过来的真实类型到底是什么呢？ 在真正调用Servlet前，会经过很多Tomcat方法，传递给Tomcat的request和response的真正类型是一个Facade类。 Request类 123456public HttpServletRequest getRequest() &#123; if (facade == null) &#123; facade = new RequestFacade(this); &#125; return facade;&#125; Response类 123456public HttpServletResponse getResponse() &#123; if (facade == null) &#123; facade = new ResponseFacade(this); &#125; return (facade);&#125; 因为Request类中很多方法都是组件内部之间交互用的，比如setComet、setReuqestedSessionId等方法，这些方法并不对外公开，但又必须设置为public，因为还要和内部组件交互使用。最好的解决方法就是通过使用一个Facade类，屏蔽掉内部组件之间交互的方法，只提供外部程序要使用的方法。 如果不使用Facade，直接传递的是HttpServletRequest和HttpServletResponse，那么熟悉容器内部运作的开发者可以分别把ServletRequest和ServletResponse向下转型为HttpServletRequest和HttpServletResponse，这样就有安全性的问题了。 5. 参考https://www.cnblogs.com/xrq730/p/4908822.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(七)---代理模式]]></title>
    <url>%2Fposts%2Fae2a93bd.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的代理模式，并结合实例描述了各种代理模式的具体实现和对比。包括：JDK静态代理，JDK动态代理，cglib动态代理. 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介 给某一对象提供一个代理对象，并由代理对象控制对原对象的引用。 代理模式的结构 有些情况下，一个客户不想或者不能够直接引用一个对象，可以通过代理对象在客户端和目标对象之间起到中介作用。代理模式中的角色有： 1、抽象对象角色 声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象 2、目标对象角色 定义了代理对象所代表的目标对象 3、代理对象角色 代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象 2. 静态代理123由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。代理类和被代理类必须实现同一个接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 抽象对象角色 * * @author illusoryCloud */public interface Human &#123; void work();&#125;/** * 目标对象角色 * * @author illusoryCloud */public class Singer implements Human &#123; @Override public void work() &#123; System.out.println("歌手在唱歌~"); &#125;&#125;/** * 代理对象角色 * * @author illusoryCloud */public class ProxyMan implements Human &#123; /** * 持有目标对象的引用 */ private Human human; /** * 通过构造方法注入 * * @param human 目标对象 */ public ProxyMan(Human human) &#123; this.human = human; &#125; @Override public void work() &#123; System.out.println("经纪人为歌手安排好时间~"); human.work(); System.out.println("经纪人为歌手联系下一场演出~"); &#125;&#125; /** * 静态代理模式 测试类 * * @author illusoryCloud */public class StaticProxyTest &#123; @Test public void staticProxyTest() &#123; Human singer = new ProxyMan(new Singer()); singer.work(); &#125;&#125; //输出结果经纪人为歌手安排好时间~歌手在唱歌~经纪人为歌手联系下一场演出~ 3. JDK动态代理 代理类在程序运行时创建的代理方式被成为动态代理。 1. 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 回调方法 * * @author illusoryCloud */public class MyInvocationHandler implements InvocationHandler &#123; public static final String PROXY_METHOD = "work"; /** * 持有一个被代理对象的引用 */ private Human human; public MyInvocationHandler(Human human) &#123; this.human = human; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 判断是否是需要代理的方法 if (PROXY_METHOD.equals(method.getName())) &#123; System.out.println("经纪人为歌手安排好时间~"); Object invoke = method.invoke(human, args); System.out.println("经纪人为歌手联系下一场演出~"); return invoke; &#125; else &#123; return null; &#125; &#125;&#125;/** * JDK动态代理 测试类 * * @author illusoryCloud */public class JDKProxyTest &#123; @Test public void JDKProxyTest() &#123; Singer singer = new Singer(); //参数1：类加载器 参数2：被代理类实现的接口 参数3：回调 由自己实现 Human human = (Human) Proxy.newProxyInstance(singer.getClass().getClassLoader() , singer.getClass().getInterfaces() , new MyInvocationHandler(singer)); human.work(); &#125;&#125; 2. InvocationHandlerInvocationHandler是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。 1234public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 接口内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。对代理对象的增强就在这里进行。实现该接口 重写此方法 可以用匿名内部类或者直接用生成代理的那个类实现该接口。 方法参数 1.proxy 代理对象 2.method 代理对象调用的方法 3.args 调用的方法中的参数 因为Proxy动态产生的代理会调用InvocationHandler实现类，所以InvocationHandler是实际执行者。 3. 生成代理对象 Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler); 方法参数 1.classLoader 类加载器,告诉虚拟机用哪个字节码加载器加载内存中创建出来的字节码文件 一般是application类加载器.(增强哪个对象就写哪个类的类加载器) 2.interfaces 字节码数组 告诉虚拟机内存中正在你被创建的字节码文件中应该有哪些方法(被代理类实现的所有接口的字节码数组 ) 3.一个InvocationHandler对象,表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上,告诉虚拟机字节码上的那些方法如何处理 （用户自定义增强操作等 写在实现InvocationHandler接口的那个类中. 小结： 1.通过 Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler);生成代理对象 2.创建InvocationHandler接口实现类 重写invoke方法 实现具体的方法增强 3.调用对象的方法最后都是调用InvocationHandler接口的invoke方法 4.只能增强接口中有的方法 4. CGLIB动态代理JDK代理要求被代理的类必须实现接口，有很强的局限性。 而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。 cglib原理 通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。由于是通过子类来代理父类，因此不能代理被final字段修饰的方法。 需要引入两个jar包 cglib-3.2.10.jar //cglib包 asm-7.0.jar //底层用到的asm包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 被代理类 没有实现接口 无法使用JDK动态代理 * * @author illusoryCloud */public class Dancer &#123; public void dance() &#123; System.out.println("跳舞者翩翩起舞~"); &#125;&#125;/** * @author illusoryCloud */public class MyMethodInterceptor implements MethodInterceptor &#123; public static final String PROXY_METHOD = "work"; /** * @param o cglib生成的代理对象 * @param method 目标对象的方法 * @param objects 方法入参 * @param methodProxy 代理方法 * @return 返回值 * @throws Throwable 异常 */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("经纪人为舞蹈演员安排好时间~"); //注意 这里是invokeSuper 若是invoke则会循环调用最终堆栈溢出 Object o1 = methodProxy.invokeSuper(o, objects); System.out.println("经纪人为舞蹈演员联系下一场演出~"); return o1; &#125;&#125;/** * CGLib动态代理 测试类 * * @author illusoryCloud */public class CglibProxyTest &#123; @Test public void cglibProxyTest()&#123; Enhancer enhancer=new Enhancer(); //设置父类 即被代理类 cglib是通过生成子类的方式来代理的 enhancer.setSuperclass(Dancer.class); //设置回调 enhancer.setCallback(new MyMethodInterceptor()); Dancer dancer= (Dancer) enhancer.create(); dancer.dance(); &#125;&#125; 5. 代理模式比较 代理方式 实现 优点 缺点 特点 JDK静态代理 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口 实现简单，容易理解 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 好像没啥特点 JDK动态代理 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理 不需要硬编码接口，代码复用率高 只能够代理实现了接口的委托类 底层使用反射机制进行方法的调用 CGLIB动态代理 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 不能对final类以及final方法进行代理 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 6. 参考https://www.cnblogs.com/xrq730/p/4907999.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(六)---装饰者模式]]></title>
    <url>%2Fposts%2F75903408.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的装饰者模式，并结合实例描述了装饰者模式的具体实现和优缺点分析。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。 它是通过创建一个包装对象，也就是装饰来包裹真实的对象。是继承关系的一个替代方案。 装饰模式由4种角色组成：（1）抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加职责的对象。（2）具体构件（Concrete Component）角色：定义一个将要接收附加职责的类。（3）装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口，从外类来扩展Component类的功能，但对于Component类来说，是无需知道Decorato的存在的。（4）具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的职责。 2. 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * 抽象构件角色 * 人类 * * @author illusoryCloud */public interface Human &#123; void run();&#125;/** * 具体构件角色 * 男人 * * @author illusoryCloud */public class Man implements Human &#123; @Override public void run() &#123; System.out.println("男人跑得很快"); &#125;&#125;/** * 抽象装饰角色 * * @author illusoryCloud */public class Decorator implements Human &#123; /** * 持有一个具体构件的引用 */ private Human human; public Decorator(Human human) &#123; this.human = human; &#125; @Override public void run() &#123; human.run(); &#125;&#125;/** * 具体装饰角色 * 飞人 * * @author illusoryCloud */public class FlyMan extends Decorator &#123; public FlyMan(Human human) &#123; super(human); &#125; @Override public void run() &#123; super.run(); this.fly(); &#125; /** * 扩展功能 */ private void fly() &#123; System.out.println("变成飞人了，跑得更快了~"); &#125;&#125;/** * 具体装饰角色 * 强壮的男人 * * @author illusoryCloud */public class StrongMan extends Decorator &#123; public StrongMan(Human human) &#123; super(human); &#125; @Override public void run() &#123; super.run(); this.strong(); &#125; public void strong() &#123; System.out.println("变得强壮了，耐力提升了~"); &#125;&#125;/** * 装饰者模式 测试类 * * @author illusoryCloud */public class DecoratorTest &#123; @Test public void decoratorTest() &#123; //普通对象 Human man = new Man(); man.run(); System.out.println("--------------------"); //装饰后的对象 Human flyMan = new FlyMan(man); flyMan.run(); System.out.println("--------------------"); //装饰后的对象 Human strongMan = new StrongMan(man); strongMan.run(); System.out.println("--------------------"); //装饰后的对象再次装饰 Human strongFlyMan = new StrongMan(flyMan); strongFlyMan.run(); &#125;&#125; //输出男人在跑--------------------男人在跑变成飞人了，速度加快了~--------------------男人在跑变得强壮了，耐力提升了~--------------------男人在跑变成飞人了，速度加快了~变得强壮了，耐力提升了~ 3. 总结优点 1.装饰者模式可以提供比继承更多的灵活性。装饰器模式允许系统动态决定贴上一个需要的装饰，或者除掉一个不需要的装饰。继承关系是不同，继承关系是静态的，它在系统运行前就决定了。 2.通过使用不同的具体装饰器以及这些装饰类的排列组合，设计师可以创造出很多不同的行为组合。 缺点 由于使用装饰器模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是另一方面，由于使用装饰器模式会产生比使用继承关系更多的对象，更多的对象会使得查错变得困难，特别是这些对象看上去都很像。 装饰者模式和代理模式对比 装饰者模式主要对功能进行扩展，代理模式主要是添加一些无关业务的功能，比如日志，验证等。 使用代理模式,代理和真实对象之间的关系在编译时就已经确定了,而装饰器者能够在运行时递归的被构造.(代理模式会在代理类中创建真实处理类的一个实例,所以可以确定代理和真实对象的关系,而装饰器模式是将原始对象作为一个参数传给装饰器类) 装饰模式：以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；代理模式：给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用； 4. 装饰者模式在Java中的应用装饰器模式在Java体系中的经典应用是Java I/O 抽象构件角色:InputStream 具体构建角色:ByteArrayInputStream、FileInputStream、ObjectInputStream、PipedInputStream等 装饰角色；FilterInputStream –&gt;实现了InputStream内的所有抽象方法并且持有一个InputStream的引用 具体装饰角色:InflaterInputStream、BufferedInputStream、DataInputStream等 5. 参考https://www.cnblogs.com/xrq730/p/4908940.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(五)---适配器模式]]></title>
    <url>%2Fposts%2Ff444ac9.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式之适配器模式，并结合实例描述了适配器模式的具体实现和优缺点分析。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介 适配器模式将一个接口转换成客户希望的另外一个接口。它使得原来由于接口不兼容而不能在一起工作的那些类可以一起工作。 把一个类的接口变换成客户端所期待的另一种接口 用到的对象 Target —定义Client使用的与特定领域相关的接口。 Client —与符合Target接口的对象协同。 Adaptee —定义一个已经存在的接口，这个接口需要适配。 Adapter —对Adaptee的接口与Target接口进行适配 2. 类适配器模式原理： 通过继承来实现适配器功能。 当我们要访问的类A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，但我们又不能改变类A。 在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要继承我们访问类A，这样我们就能继续访问当前类A中的方法（虽然它目前不是我们的菜），然后再实现接口B，这样我们可以在适配器P中访问接口B的方法了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 目标类 * * @author illusoryCloud */public interface Target &#123; void Target();&#125;/** * 被适配类 * 只有Adaptee方法 但是目标接口要Target方法 * * @author illusoryCloud */public class Adaptee &#123; public void Adaptee() &#123; System.out.println("这是现有的方法"); &#125;&#125;/** * 适配器类 * 继承Adaptee类 使得此类保留了Adaptee方法 * 实现Target接口 使得此类同时也拥有Target方法 * 适配完成 * * @author illusoryCloud */public class Adapter extends Adaptee implements Target &#123; @Override public void Target() &#123; System.out.println("这是目标方法"); &#125;&#125;/** * 类适配器模式 测试类 * * @author illusoryCloud */public class ClassAdapterTest &#123; @Test public void classAdapterTest() &#123; //Target类型的对象 同时拥有Target()和Adaptee()方法 Target target = new Adapter(); //这是目标方法 target.Target(); //这是现有的方法 ((Adapter) target).Adaptee(); &#125;&#125; 3. 对象适配器模式原理 基本思路和类的适配器模式相同，只是将 Adapter 类作修改，这次不继承 Adaptee 类，而是持有 Adaptee 类的实例，以达到解决兼容性的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243//-------Target和Adaptee与上面一样----------/** * 适配器类 持有Adaptee对象来代替继承Adaptee类 * 传入Adaptee对象 使得此类同样拥有Adaptee方法 * 实现Target接口 使得此类同时也拥有Target方法 * 适配完成 * * @author illusoryCloud */public class Adapter implements Target &#123; private Adaptee adaptee; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void Target() &#123; System.out.println("这是目标方法"); &#125; public void Adaptee() &#123; adaptee.Adaptee(); &#125;&#125;/** * 对象适配器模式 测试类 * * @author illusoryCloud */public class ObjectAdapterTest &#123; @Test public void objectAdapterTest() &#123; Target target = new Adapter(new Adaptee()); //这是目标方法 target.Target(); //这是现有的方法 ((Adapter) target).Adaptee(); &#125;&#125; 4. 总结适配器模式优点 1、有更好的复用性。系统需要使用现有的类，但此类接口不符合系统需要，通过适配器模式让这些功能得到很好的复用 2、有更好的扩展性。实现适配器，可以调用自己开发的功能 缺点 过多使用适配器会使得系统非常凌乱，明明调用的是A接口，内部却被适配成了B接口。因此除非必要，不推荐使用适配器，而是作为一种补救措施，条件允许的情况下推荐直接对系统重构。 适配器模式在JDK中的应用 InputStreamReader/OutputStreanWriter 创建InputStreamReader对象的时候必须在构造函数中传入一个InputStream实例，然后InputStreamReader的作用就是将InputStream适配到Reader。很显然，适配器就是InputStreamReader，源角色就是InputStream代表的实例对象，目标接口就是Reader类。 5. 参考https://www.cnblogs.com/xrq730/p/4906487.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(四)---原型模式]]></title>
    <url>%2Fposts%2F24b6c0e4.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的原型模式，并结合实例描述了原型模式的具体实现和应用场景，优缺点分析等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介1.1 原型模式 原型模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。简单地说原型模式就是创建复杂对象的时候使用克隆手段来代替新建一个对象。当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。 原型模式主要包含如下三个角色： Prototype：抽象原型类。声明克隆自身的接口。 ConcretePrototype：具体原型类。实现克隆的具体操作。 Client：客户类。让一个原型克隆自身，从而获得一个新的对象。 1.2 Java中的克隆我们需要知道，Java中的对象克隆分为浅克隆和深克隆。 浅克隆：将一个对象克隆后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深克隆：将一个对象克隆后，不论是基本数据类型还有引用类型，都是重新创建的。 简单来说，就是深克隆进行了完全彻底的克隆，而浅克隆不彻底。 2. 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//实现Cloneable接口浅克隆，Serializable接口深克隆/** * 构建的消息对象 * 普通对象 * * @author illusoryCloud */public class Message implements Serializable, Cloneable &#123; /** * 标题 */ private String Title; /** * 内容 */ private String Content; /** * 发送者 */ private User From; /** * 接收者 */ private User To; /** * 时间 */ private Date Time; /** * 浅克隆 * * @return * @throws CloneNotSupportedException */ @Override protected Object clone() throws CloneNotSupportedException &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 深克隆 * * @return Message对象 * @throws IOException * @throws ClassNotFoundException */ public Message deepClone() throws IOException, ClassNotFoundException &#123; // 写入当前对象的二进制流 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 读出二进制流产生的新对象 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (Message) ois.readObject(); &#125; //省略Getter、Setter、toString、构造函数等 &#125;//User类 Message类中引用 /** * 用户类 被消息类引用 * 主类实现深克隆 则被引用类也得实现Serializable接口 * @author illusoryCloud */public class User implements Serializable &#123; private String name; private int age; //省略Getter、Setter、toString、构造函数等&#125;//测试 /** * 原型模式测试类 * * @author illusoryCloud */public class PrototypeTest &#123; @Test public void prototypeTest() &#123; User zhangsan = new User("张三", 22); User lisi = new User("李四", 23); Message message = new Message(); message.setTitle("hello"); message.setContent("how are you~"); message.setFrom(zhangsan); message.setTo(lisi); message.setTime(new Date()); Message cloneOne = null; Message cloneTwo = null; try &#123; cloneOne = (Message) message.clone(); cloneTwo = message.deepClone(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //false 克隆实现的是一个(和原对象相似的)新对象 System.out.println(message == cloneOne); //false System.out.println(message == cloneTwo); //true 浅克隆 引用对象指向的还是原对象 System.out.println(message.getFrom()==cloneOne.getFrom()); //false 深克隆 引用对象也重新创建 System.out.println(message.getFrom()==cloneTwo.getFrom()); &#125;&#125; 3. 总结为什么要用原型模式 通过复制已有的对象，可以简化对象的创建过程，提高创建对象的效率。 深克隆保存对象状态，实现撤销恢复功能。 缺点： 在实现深克隆时需要编写复杂的代码。 需要为每一个类写一个克隆方法，如果要深克隆，则类中的每一层对象的类都得支持深克隆，代码比较复杂。 应用场景 创建对象成本高。 当一个系统应该独立于它的产品创建、构成和表示时，要使用原型模式。 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 原型模式在Java中的应用及解读 只要是实现了Cloneable接口的类都可以算是原型模式的应用，比如ArrayList。 1234567891011121314151617public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ... public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; ...&#125; 程序中获取到了一个ArrayList的实例arrayList，我们完全可以通过调用arrayList.clone()方法获取到原ArrayList的拷贝。 4. 参考https://www.cnblogs.com/xrq730/p/4905907.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(三)---建造者模式]]></title>
    <url>%2Fposts%2F52453.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的建造者模式，并结合实例描述了建造者模式的具体实现和优缺点及建造者模式和工厂模式的差别分析等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介 建造者模式是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。。 建造者模式通常包括下面几个角色： （1） Builder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。 （2） ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。 （3）Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 （4）Product：要创建的复杂对象 2. 实现2.1 常见写法以创建一个Person为例： Product（要创建的对象）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 构建的消息对象 * 普通对象 * * @author illusoryCloud */public class Message &#123; /** 标题 */ private String Title; /** 内容 */ private String Content; /** 发送者 */ private String From; /** 接收者 */ private String To; /** 时间 */ private Date Time; public String getTitle() &#123; return Title; &#125; public void setTitle(String title) &#123; Title = title; &#125; public String getContent() &#123; return Content; &#125; public void setContent(String content) &#123; Content = content; &#125; public String getFrom() &#123; return From; &#125; public void setFrom(String from) &#123; From = from; &#125; public String getTo() &#123; return To; &#125; public void setTo(String to) &#123; To = to; &#125; public Date getTime() &#123; return Time; &#125; public void setTime(Date time) &#123; Time = time; &#125; @Override public String toString() &#123; return "Message&#123;" + "Title='" + Title + '\'' + ", Content='" + Content + '\'' + ", From='" + From + '\'' + ", To='" + To + '\'' + ", Time=" + Time + '&#125;'; &#125;&#125; Builder（给出一个抽象接口，以规范产品对象的各个组成成分的建造 ） 123456789101112/** * Builder接口 建造对象的标准 */public interface Builder &#123; void setTitle(); void setContent(); void setFrom(); void setTo(); void setTime(); Message build();&#125; ConcreteBuilder（实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建） 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 具体的建造对象类 实现了Builder接口 * 可以根据不同需求有不同的实现 * @author illusoryCloud */public class CommonMessageBuilder implements Builder &#123; private Message message; public CommonMessageBuilder() &#123; this.message = new Message(); &#125; @Override public void setTitle() &#123; message.setTitle("常见的标题"); &#125; @Override public void setContent() &#123; message.setContent("普通的内容"); &#125; @Override public void setFrom() &#123; message.setFrom("未知的发送者"); &#125; @Override public void setTo() &#123; message.setTo("未知的接收者"); &#125; @Override public void setTime() &#123; message.setTime(new Date()); &#125; @Override public Message build() &#123; return this.message; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 具体的建造对象类 实现了Builder接口 * 可以根据不同需求有不同的实现 * @author illusoryCloud */public class OthersMessageBuilder implements Builder &#123; private Message message; public OthersMessageBuilder() &#123; this.message = new Message(); &#125; @Override public void setTitle() &#123; message.setTitle("不寻常的标题"); &#125; @Override public void setContent() &#123; message.setContent("奇怪的内容"); &#125; @Override public void setFrom() &#123; message.setFrom("神秘的发送者"); &#125; @Override public void setTo() &#123; message.setTo("诡异的接收者"); &#125; @Override public void setTime() &#123; message.setTime(new Date()); &#125; @Override public Message build() &#123; return this.message; &#125;&#125; Director（调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建 ） 12345678910111213141516171819/** 指导者 *只负责保证对象各部分完整创建 * @author illusoryCloud */public class Dreator &#123; /** * * @param builder 参数是只要实现了Builder接口的类都可以 * @return */ public Message createMessage(Builder builder) &#123; builder.setTitle(); builder.setContent(); builder.setFrom(); builder.setTo(); builder.setTime(); return builder.build(); &#125;&#125; 测试 123456789public class Test &#123; @org.junit.jupiter.api.Test public void testBuilder() &#123; Message commonMessage = new Dreator().createMessage(new CommonMessageBuilder()); Message othersMessage = new Dreator().createMessage(new OthersMessageBuilder()); System.out.println(commonMessage); System.out.println(othersMessage); &#125;&#125; 2.2 静态内部类方式静态内部类写法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 构建的消息对象 * 有个静态内部类 * * @author illusoryCloud */public class Message &#123; /** * 标题 */ private String Title; /** * 内容 */ private String Content; /** * 发送者 */ private String From; /** * 接收者 */ private String To; /** * 时间 */ private Date Time; @Override public String toString() &#123; return "Message&#123;" + "Title='" + Title + '\'' + ", Content='" + Content + '\'' + ", From='" + From + '\'' + ", To='" + To + '\'' + ", Time=" + Time + '&#125;'; &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; /** * 静态内部类 builder */ public static class Builder &#123; //设置默认值 private String Title = "未命名"; private String Content = "暂无内容"; private String From = "unknow"; private String To = "unknow"; private Date Time = new Date(); /** * 设置消息标题 * * @param title 要设置的标题 * @return 返回Builder对象 以达到链式调用 */ public Builder setTitle(String title) &#123; this.Title = title; return this; &#125; public Builder setContent(String content) &#123; this.Content = content; return this; &#125; public Builder setFrom(String from) &#123; this.From = from; return this; &#125; public Builder setTo(String to) &#123; this.To = to; return this; &#125; public Builder setTime(Date time) &#123; this.Time = time; return this; &#125; public Message Build() &#123; Message message = new Message(); message.Title = Title; message.Content = Content; message.From = From; message.To = To; message.Time = Time; return message; &#125; &#125;&#125; 测试类 1234567891011121314151617/** * 建造者模式 测试类 * * @author illusoryCloud */public class Test &#123; @org.junit.jupiter.api.Test public void testBuilder() &#123; Message build = Message.newBuilder().setTitle("这是消息标题") .setContent("这是消息内容") .setFrom("这是消息发送者") .setTo("这是消息接收者") .setTime(new Date()) .Build(); System.out.println(build.toString()); &#125;&#125; 3. 总结建造者模式优点： 1.将对象本身与对象的创建过程解耦，使得相同的创建过程可以创建不同的对象。 2.可以更加精细地控制产品的创建过程 3.增加新的具体建造者无须修改原有类库的代码，符合开闭原则 与工厂模式的区别： 工厂模式注重的是整体对象的创建方法，只为了获取对象，关注整体 建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象，关注细节。建造者模式一般用来创建更为复杂的对象 4. 参考https://blog.csdn.net/zhuhuitao_struggle/article/details/80489572]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(二)---工厂模式]]></title>
    <url>%2Fposts%2F34710.html</url>
    <content type="text"><![CDATA[本章主要介绍了设计模式中的工厂模式，并结合实例描述了工厂模式的具体实现和使用场景。包括：普通工厂模式、工厂方法模式、抽象工厂模式等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 简介工厂模式可以分为普通工厂模、工厂方法模式和抽象工厂模式。 简单工厂模式：建立一个工厂类，根据传入的参数对实现了同一接口的一些类进行实例的创建。如果传入的字符串错误就不能正确创建对象。 工厂方法模式：是对普通工厂方法模式的改进，提供多个工厂方法，分别创建对象。 抽象工厂模式：创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 工厂模式优点： (1) 解耦：把对象的创建和使用的过程分开 (2)减少重复代码: 若创建对象的过程很复杂，有一定的代码量，且很多地方都要用到，那么就会有很多重复代码。 (3) 降低维护成本 ：创建过程都由工厂统一管理，发生业务逻辑变化，只需要在工厂里修改即可。 适用场景 （1）需要创建的对象较少。 （2）客户端不关心对象的创建过程。 2. 简单工厂模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 抽象产品类 水果 */public interface Fruit &#123; void show();&#125;/** * 具体产品类 * 苹果 实现了水果接口 * @author illusoryCloud */public class Apple implements Fruit &#123; @Override public void show() &#123; System.out.println("This is Apple"); &#125;&#125;/** * 具体产品类 * 橘子 实现了水果接口 * @author illusoryCloud */public class Orange implements Fruit &#123; @Override public void show() &#123; System.out.println("This is Orange"); &#125;&#125;/** * 工厂类 水果工厂 * 负责生产各种产品 * * @author illusoryCloud */public class FruitFactory &#123; public static final String FRUIT_APPLE = "Apple"; public static final String FRUIT_ORANGE = "Orange"; public static Fruit creatFruit(String fruit) &#123; if (FRUIT_APPLE.equals(fruit)) &#123; return new Apple(); &#125; else if (FRUIT_ORANGE.equals(fruit)) &#123; return new Orange(); &#125; else &#123; System.out.println("error unknown fruit ~"); return null; &#125; &#125;&#125;/** * 简单工厂模式 测试 * * @author illusoryCloud * */public class EasyFactoryTest &#123; @Test public void testEasyFactory() &#123; Fruit apple = FruitFactory.creatFruit(FruitFactory.FRUIT_APPLE); if (apple != null) &#123; apple.show(); &#125; Fruit orange = FruitFactory.creatFruit(FruitFactory.FRUIT_ORANGE); if (orange != null) &#123; orange.show(); &#125; &#125;&#125; 3. 工厂方法模式简单工厂模式中，如果创建对象时传入的字符串出现错误则不能正确创建产品。工厂方法模式为每种产品创建一个工厂，则不会出现这样的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 抽象产品工厂类 * @author illusoryCloud */public interface FruitFactory &#123; Fruit create();&#125;/** * 具体产品工厂 实现接口 * 苹果工厂 * @author illusoryCloud */public class AppleFactory implements FruitFactory &#123; @Override public Fruit create() &#123; return new Apple(); &#125;&#125;/** * 具体产品工厂 实现接口 * 苹果工厂 * @author illusoryCloud */public class AppleFactory implements FruitFactory &#123; @Override public Fruit create() &#123; return new Apple(); &#125;&#125;/** * 工厂方法模式 测试类 * * @author illusoryCloud */public class FactoryMethodTest &#123; @Test public void factoryMethodTest() &#123; Fruit apple = new AppleFactory().create(); apple.show(); Fruit orange = new OrangeFactory().create(); orange.show(); &#125;&#125; 4. 抽象工厂模式网上找的一个类图： 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * 抽象产品类 果汁 * * @author illusoryCloud */public interface Juice &#123; void show();&#125;/** * 具体产品类 * 苹果汁 * * @author illusoryCloud */public class AppleJuice implements Juice &#123; @Override public void show() &#123; System.out.println("AppleJuice"); &#125;&#125;/** * 具体产品类 * 橘子汁 * * @author illusoryCloud */public class OrangeJuice implements Juice &#123; @Override public void show() &#123; System.out.println("OrangeJuice"); &#125;&#125;/** * 抽象工厂类 * * @author illusoryCloud */public interface AbstractFactory &#123; /** * 创建水果 * * @return 水果 */ Fruit createFruit(); /** * 创建果汁 * * @return 果汁 */ Juice createJuice();&#125;/** * 具体工厂类 * 苹果工厂 生产苹果和苹果汁 * * @author illusoryCloud */public class AppleFactory implements AbstractFactory &#123; @Override public Fruit createFruit() &#123; return new Apple(); &#125; @Override public Juice createJuice() &#123; return new AppleJuice(); &#125;&#125;/** * 具体工厂类 * 橘子工厂 生产橘子和橘子汁 * * @author illusoryCloud */public class OrangeFactory implements AbstractFactory &#123; @Override public Fruit createFruit() &#123; return new Orange(); &#125; @Override public Juice createJuice() &#123; return new OrangeJuice(); &#125;&#125;/** * 抽象工厂模式 测试类 * * @author illusoryCloud */public class AbstractFactoryTest &#123; @Test public void abstractFactoryTest() &#123; //苹果产品簇 AbstractFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.createFruit(); Juice appleJuice = appleFactory.createJuice(); //橘子产品簇 AbstractFactory orangeFactory = new OrangeFactory(); Fruit orange = orangeFactory.createFruit(); Juice orangeJuice = orangeFactory.createJuice(); apple.show(); appleJuice.show(); orange.show(); orangeJuice.show(); &#125;&#125; 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 工厂里加代码，又要在具体的工厂里面加代码。要增加一个新的系列时比较简单。 例如上面例子中在苹果系列增加一个苹果派就很困难得修改苹果工厂和抽象工厂，但是若增加一个菠萝系列就很简单，只需要添加一个菠萝工厂就行了。 5. 总结工厂模式的优点？为什么要使用工厂模式 工厂都是用来封装对象的具体创建过程，减少重复代码，降低对象变化时的维护成本，将对象创建过程和使用相解耦。 工厂方法模式使用继承，抽象工厂使用对象组合；两者利用抽象的原则，将具体的实例化过程延迟到子类。 工厂利用的最重要和基本的原则——依赖抽象，不要依赖具体类。 应用场景 简单工厂：适合创建同一级别的不同对象。 工厂方法：为每种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品。 抽象工厂模式：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。 工厂模式在Java中的应用 简单工厂模式 JDK中的简单工厂模式有很多应用，比较典型的比如线程池。我们使用线程池的时候，可以使用ThreadPoolExecutor，根据自己的喜好传入corePoolSize、maximumPoolSize、keepAliveTimem、unit、workQueue、threadFactory、handler这几个参数，new出一个指定的ThreadPoolExecutor出来。 工厂方法模式 123456789101112public interface ThreadFactory &#123; /** * Constructs a new &#123;@code Thread&#125;. Implementations may also initialize * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or &#123;@code null&#125; if the request to * create a thread is rejected */ Thread newThread(Runnable r);&#125; 这是一个生产线程的接口,具体的线程工厂可以implements这个接口并实现newThread(Runnable r)方法，来生产具体线程工厂想要生产的线程。 6. 参考https://blog.csdn.net/d1562901685/article/details/77623237 https://www.cnblogs.com/xrq730/p/4905578.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(十三)--组合模式]]></title>
    <url>%2Fposts%2Fa340063f.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的 模式，并结合实例描述了 模式的具体实现和性能分析测试。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 组合模式介绍组合模式：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 所谓组合模式，其实说的是对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局 以Windows文件系统为例，文件夹下可能有文件，也可能还有一个文件夹。文件夹可以包含文件和文件夹，但文件却没有这些功能。所以实现的时候需要单独实现。如果用组合模式的话，将文件和文件夹看成一个整体。都是文件。当做抽象的文件。 2. 组合模式实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//抽象文件类 public abstract class AbstractFiles &#123; public abstract void add(AbstractFiles af); public abstract void remove(AbstractFiles af); public abstract AbstractFiles get(int i); public abstract void killVirus();&#125;//具体文件类型 图片文件 没有的方法就不实现 叶子节点public class ImageFile extends AbstractFiles &#123; private String name; public ImageFile(String name) &#123; this.name=name; &#125; @Override public void add(AbstractFiles af) &#123; System.out.println("不支持该方法"); &#125; @Override public void remove(AbstractFiles af) &#123; System.out.println("不支持该方法"); &#125; @Override public AbstractFiles get(int i) &#123; System.out.println("不支持该方法"); return null; &#125; @Override public void killVirus() &#123; System.out.println("开始进行--"+name+"--文件杀毒"); &#125;&#125;//文件夹类型的文件 实现所有方法 树枝节点public class Folder extends AbstractFiles &#123; //文件夹类，所有的都可以用 private ArrayList&lt;AbstractFiles&gt; list = new ArrayList&lt;AbstractFiles&gt;(); private String name; public Folder(String name) &#123; this.name=name; &#125; @Override public void add(AbstractFiles af) &#123; list.add(af); System.out.println("添加成功"); &#125; @Override public void remove(AbstractFiles af) &#123; // TODO Auto-generated method stub if(list.remove(af)) &#123; System.out.println("删除成功"); &#125;else&#123; System.out.println("删除失败"); &#125; &#125; @Override public AbstractFiles get(int i) &#123; return list.get(i); &#125; @Override public void killVirus() &#123; // TODO Auto-generated method stub System.out.println("对文件夹"+name+"进行杀毒"); //递归调用 for(Object o:list) &#123; ((AbstractFiles)o).killVirus(); &#125; &#125;&#125;//测试代码public class Client &#123; public static void main(String[] args) &#123; //创建一个文件类型 AbstractFiles f1 = new Folder("主文件夹"); //创建文件 AbstractFiles file1= new ImageFile("孙悟空。png"); AbstractFiles file2= new ImageFile("龙珠.jpg"); AbstractFiles file3= new ImageFile("帅哥威.gif"); f1.add(file1); f1.add(file2); f1.add(file3); f1.killVirus(); file1.killVirus(); &#125; 参考https://blog.csdn.net/qq_40709468/article/details/81990084]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字在单例模式(双重校验锁)中的作用]]></title>
    <url>%2Fposts%2Fe7cef119.html</url>
    <content type="text"><![CDATA[本文主要讲述了Java单例模式之双重校验锁中volatile关键字的作用。 更多文章欢迎访问我的个人博客–&gt;幻境云图 上篇文章Java设计模式(一)–单例模式中讲了Java单例模式的几种写法，其中懒汉式和双重校验锁方式写法如下： 1. 懒汉式12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种方式实现的单例：实现了lazy loading 使用时才创建实例。synchronized保证了线程安全，但效率低。 2. 双重校验锁1234567891011121314151617public class Singleton &#123; private static volatile Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; //1 if (singleton == null) &#123; //2 singleton = new Singleton(); //3 &#125; &#125; &#125; return singleton; &#125;&#125; 3. 执行过程双重校验锁方式的执行过程如下： 1.线程A进入 getInstance() 方法。 2.由于 singleton为 null，线程A在 //1 处进入 synchronized 块。 3.线程A被线程B预占。 4.线程B进入 getInstance() 方法。 5.由于 singleton仍旧为 null，线程B试图获取 //1 处的锁。然而，由于线程A已经持有该锁，线程B在 //1 处阻塞。 6.线程B被线程A预占。 7.线程A执行，由于在 //2 处实例仍旧为 null，线程A还创建一个 Singleton 对象并将其引用赋值给 instance。 8.线程A退出 synchronized 块并从 getInstance() 方法返回实例。 9.线程A被线程B预占。 10.线程B获取 //1 处的锁并检查 instance 是否为 null。 11.由于 singleton是非 null 的，并没有创建第二个 Singleton 对象，由线程A所创建的对象被返回。 4. 问题双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。 双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。 singleton = new Singleton(); 该语句非原子操作，实际是三个步骤。 1.给singleton分配内存； 2.调用 Singleton 的构造函数来初始化成员变量； 3.将给singleton对象指向分配的内存空间（此时singleton才不为null）； 虚拟机的指令重排序–&gt; 执行命令时虚拟机可能会对以上3个步骤交换位置 最后可能是132这种 分配内存并修改指针后未初始化 多线程获取时可能会出现问题。 当线程A进入同步方法执行singleton = new Singleton();代码时，恰好这三个步骤重排序后为1 3 2， 那么步骤3执行后singleton已经不为null,但是未执行步骤2，singleton对象初始化不完全，此时线程B执行getInstance()方法，第一步判断时singleton不为null,则直接将未完全初始化的singleton对象返回了。 5. 解决如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序 所以使用volatile关键字会禁止指令重排序,可以避免这种问题。使用volatile关键字后使得 singleton = new Singleton();语句一定会按照上面拆分的步骤123来执行。 参考https://blog.csdn.net/qq646040754/article/details/81327933]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式(一)---单例模式]]></title>
    <url>%2Fposts%2F53093.html</url>
    <content type="text"><![CDATA[本文主要介绍了设计模式的六大原则，并结合实例描述了各种单例模式的具体实现和性能分析测试。包括：饿汉式、静态内部类、懒汉式、双重校验锁、枚举等。 更多文章欢迎访问我的个人博客–&gt;幻境云图 Demo下载–&gt; Github 1. 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 2、里氏代换原则（Liskov Substitution Principle） 其官方描述比较抽象，可自行百度。实际上可以这样理解： （1）子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。 （2）返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。 （3）还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。而不能声明抛出父类没有声明的异常。 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 Java 中一般认为有 23 种设计模式，总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录 模式、状态模式、访问者模式、中介者模式、解释器模式。 比较常用的有：工厂方法模式、抽象工厂模式、单例模式、建造者模式、适配器模式、代理模式、享元模式、策略模式、观察者模式。 2. 单例模式2.1 单利模式介绍作用：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 应用场景： 1.配置文件访问类，不用每次使用时都new一个 2.数据库连接池 保证项目中只有一个连接池存在。 2.2 单利模式实现1. 饿汉式1234567891011121314151617181920212223242526/** * 饿汉式 * @author illusoryCloud */public class FirstSingleton &#123; /** * 类变量在类准备阶段就初始化了然后放在&lt;clinit&gt;构造方法中 * 一旦外部调用了静态方法，那么就会初始化完成。 * 一个类的&lt;clinit&gt;只会执行一次 保证多线程情况下不会创建多个实例 */ private static final FirstSingleton INSTANCE =new FirstSingleton(); /** * * 构造函数私有化 */ private FirstSingleton()&#123;&#125; /** * 提供公共方法以获取实例对象 * @return instance 实例对象 */ public static FirstSingleton getInstance()&#123; return INSTANCE ; &#125;&#125; 这种方式实现的单例：类加载时就创建实例。由classloder保证了线程安全。 2. 静态内部类123456789101112131415161718192021/** * 静态内部类方式 * * @author illusoryCloud */public class SecondSingleton &#123; private static class SingletonHolder &#123; /** * 静态变量类加载时才会被创建 且只会创建一次 */ private static final SecondSingleton INSTANCE = new SecondSingleton(); &#125; private SecondSingleton() &#123; &#125; public static SecondSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 这种方式实现的单例：实现了lazy loading 使用时才创建实例，由classloder保证了线程安全。 饿汉式/静态内部类是如何保证线程安全的： 在《深入理解JAVA虚拟机》中，有这么一句话: 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。 3. 懒汉式12345678910111213141516171819202122232425/** * 懒汉式 * * @author illusoryCloud */public class ThirdSingleton &#123; private static ThirdSingleton instance; private ThirdSingleton() &#123; &#125; /** * synchronized 保证线程安全 但效率低 * * @return instance单例对象 */ public static synchronized ThirdSingleton getInstance() &#123; if (instance == null) &#123; instance = new ThirdSingleton(); &#125; return instance; &#125;&#125; 这种方式实现的单例：实现了lazy loading 使用时才创建实例。synchronized保证了线程安全，但效率低。 4. 双重校验锁12345678910111213141516171819202122232425262728293031323334/** * 双重校验锁式 * * @author illusoryCloud */public class FourSingleton &#123; /** * volatile关键字禁止指令重排序 * 保证多线程下不会获取到未完全初始化的实例 * 详细请阅读：https://www.lixueduan.com/posts/e7cef119.html */ private static volatile FourSingleton instance; private FourSingleton() &#123; &#125; /** * 双重if校验 缩小synchronized代码块范围 * 若instance不为空 就可直接return * * @return instance 实例对象 */ public static FourSingleton getInstance() &#123; if (instance == null) &#123; synchronized (FourSingleton.class) &#123; if (instance == null) &#123; //非原子操作 instance = new FourSingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 这种方式实现的单例：实现了lazy loading 使用时才创建实例。synchronized保证了线程安全，volatile禁止指令重排序保证了多线程获取时不为空，但要JDK1.5以上才行。详细信息请阅读volatile关键字在单例模式(双重校验锁)中的作用 5. 枚举123456789101112131415161718192021/** * 枚举式 * 序列化及反序列化安全 * @author illusoryCloud */public enum FiveSingleton &#123; //定义一个枚举的元素，它就是 singleton 的一个实例 INSTANCE; public void doSomeThing(FiveSingleton instance) &#123; System.out.println("枚举方式实现单例"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.INSTANCE; singleton.doSomeThing();//output:枚举方法实现单例 &#125;&#125; 这种方式也是《Effective Java 》以及《Java与模式》的作者推荐的方式。 静态内部类和双重校验锁已经这么优秀了为什么还要有第五种枚举式呢？ 因为前面4种都存在一个序列化和反序列化时的安全问题。将单例对象序列化后，在反序列化时会重新创建一个单例对象，违背了单例模式的初衷。而枚举式单例则没有这个问题，具体信息查看：枚举式单例模式与序列化 3. 性能测试五种单例实现方式，在100个线程下，每个线程访问1千万次实例的用时. Tables 实现方式 用时(毫秒) 1 饿汉式 13 2 懒汉式 10778 3 双重检查 15 4 静态内部类 14 5 枚举 12 (*注意:由于不同电脑之间的性能差异，测试的结果可能不同) 根据不同场合选择具体的实现方式，一般情况下我是使用的静态内部类或者DCL双重校验锁方式。 4. 总结为什么要使用单例模式？什么场景适合使用单例模式?单例模式有什么好处 1.单例模式能够保证一个类仅有唯一的实例，避免创建多个实例。并提供一个全局访问点，优化和共享资源访问。 2.当一个对象需要频繁创建和销毁时使用单例模式能节省系统资源。 应用场景： 1.配置文件访问类，不用每次使用时都new一个 2.数据库连接池 保证项目中只有一个连接池存在。 单例模式的缺点： 单例模式一般没有接口，扩展很困难，若要扩展只能修改代码。 单例模式在Java中的应用 1234567891011121314151617181920public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don't let anyone else instantiate this class */ private Runtime() &#123;&#125; ...&#125; 5. 参考http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html https://blog.csdn.net/qq_22706515/article/details/74202814]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制详解]]></title>
    <url>%2Fposts%2F7d3d70a4.html</url>
    <content type="text"><![CDATA[本文主要记录了Android中的事件分发机制。通过对源码进行分析和实例测试，对Android事件分发机制有了更深的了解。主要为学习Android时的笔记。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. 触发过程1.1 点击控件1.2 dispatchTouchEven一定会执行dispatchTouchEvent方法，若当前类没有该方法，则向上往父类查找。 1234567public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event);&#125; 条件1 mOnTouchListener != null 123public void setOnTouchListener(OnTouchListener l) &#123; mOnTouchListener = l;&#125; 给控件设置监听就会给mOnTouchListener赋值，则条件1成立。 条件2 (mViewFlags &amp; ENABLED_MASK) == ENABLED 控件是否是可点击的 条件3 mOnTouchListener.onTouch(this, event) 回调onTouch方法，返回true 则成立 小结：dispatchTouchEvent 方法中一定会执行onTouch方法，如果onTouch方法返回true 则dispatchTouchEvent方法直接返回true 不会执行if外的 return onTouchEvent(event)。 1234567 title_bar.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123;Log.v("Az","onTouch"); return false; &#125; &#125;); 在setOnTouchListener时，onTouch方法默认返回false,所以才会执行后面的onTouchEvent方法； 1.3 onTouchEvent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; mPrivateFlags |= PRESSED; refreshDrawableState(); postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; return true; &#125; return false;&#125; 首先在第14行我们可以看出，如果该控件是可以点击的就会进入到第16行的switch判断中去，而如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。在经过种种判断之后，会执行到第38行的performClick()方法，那我们进入到这个方法里瞧一瞧： 若当前事件为抬手，则进入performClick方法 123456789public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; &#125; return false;&#125; 如果 mOnClickListener != null 则会执行onClick方法， 123456public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; mOnClickListener = l;&#125; 所以只要给控件设置了点击监听，setOnClickListener就会给mOnClickListener赋值，上面条件就成立，然后回调onClick方法。 到这儿差不多就清楚了分发流程。 这样View的整个事件分发的流程就让我们搞清楚了！不过别高兴的太早，现在还没结束，还有一个很重要的知识点需要说明，就是touch事件的层级传递。我们都知道如果给一个控件注册了touch事件，每次点击它的时候都会触发一系列的ACTION_DOWN，ACTION_MOVE，ACTION_UP等事件。这里需要注意，如果你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发后一个action。 1234567891011121314151617public boolean onTouchEvent(MotionEvent event) &#123; //省略...if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: break; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_CANCEL: break; case MotionEvent.ACTION_MOVE: break; &#125; return true; &#125;&#125; 可以看出在dispatchTouchEvent方法中，onTouch方法返回false,然后执行onTouchEvent方法，在进入if判断后，不管进入那个case,最后都会return true,所以才会执行后续的action. **1. onTouch和onTouchEvent有什么区别，又该如何使用？** 都是dispatchTouchEvent中的方法，onTouch优先级高，若onTouch返回true，就会消费掉当前事件，onTouchEvent就不会执行。 要执行onTouch也需要两个条件，1 给控件设置了触摸监听OnTouchListener ，2该控件是可以点击的。 若控件是非enable的，则不会执行onTouch方法，会执行onTouchEvent，所以想要监听ouTouch事件只能重写onTouchEvent方法来实现。 小结： 控件被点击或触摸后一定会执行dispatchTouchEvent方法（当前类没有则去父类找），如果设置了触摸监听且控件是enable的，就执行onTouch方法 。OnTouch方法返回true则消耗掉本次事件，不执行后面的方法，返回false则执行onTouchEvent方法，如果设置了点击监听且控件是enable的，就在抬手的时候执行onClick方法。 给一个控件注册了touch事件，每次点击它的时候都会触发一系列的ACTION_DOWN，ACTION_MOVE，ACTION_UP等事件。当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发后一个action。 2. ViewGroupAndroid中touch事件的传递，绝对是先传递到ViewGroup，再传递到View的 上边说只要你触摸了任何控件，就一定会调用该控件的dispatchTouchEvent方法。这个说法没错，只不过还不完整而已。实际情况是，当你点击了某个控件，首先会去调用该控件所在布局的dispatchTouchEvent方法，然后在布局的dispatchTouchEvent方法中找到被点击的相应控件，再去调用该控件的dispatchTouchEvent方法。 ViewGroup的dispatchTouchEvent方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public boolean dispatchTouchEvent(MotionEvent ev) &#123; final int action = ev.getAction(); final float xf = ev.getX(); final float yf = ev.getY(); final float scrolledXFloat = xf + mScrollX; final float scrolledYFloat = yf + mScrollY; final Rect frame = mTempRect; boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (action == MotionEvent.ACTION_DOWN) &#123; if (mMotionTarget != null) &#123; mMotionTarget = null; &#125; if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; &#125; &#125; &#125; &#125; &#125; &#125; boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; if (target == null) &#123; ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; return super.dispatchTouchEvent(ev); &#125; if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123; final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; ev.setAction(MotionEvent.ACTION_CANCEL); ev.setLocation(xc, yc); if (!target.dispatchTouchEvent(ev)) &#123; &#125; mMotionTarget = null; return true; &#125; if (isUpOrCancel) &#123; mMotionTarget = null; &#125; final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setLocation(xc, yc); if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; mMotionTarget = null; &#125; return target.dispatchTouchEvent(ev);&#125; 第二个if语句 if (disallowIntercept || !onInterceptTouchEvent(ev) 第一个条件disallowIntercept 是否禁用掉事件拦截的功能，默认是false 所以是否进入if内部就由第二个条件决定了。 ViewGroup中有一个onInterceptTouchEvent方法 是否拦截触摸事件 默认返回false 即不拦截 123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false;&#125; 第二个条件 !onInterceptTouchEvent(ev) 对返回值取反 即返回false不拦截触摸事件时进入if内部，返回true拦截时不进入if内部 1234567891011121314//省略。。。if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; for (int i = count - 1; i &gt;= 0; i--) &#123;//遍历当前ViewGroup下的所有子View if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; if (frame.contains(scrolledXInt, scrolledYInt)) &#123;//判断当前遍历的View是不是正在点击的View if (child.dispatchTouchEvent(ev)) &#123;//是则调用子View的dispatchTouchEvent mMotionTarget = child; return true; &#125; &#125; &#125; &#125; &#125; if内部对子View进行了遍历，最终调用子View的dispatchTouchEvent，然后控件可点击那么dispatchTouchEvent一定会返回true，所以后面的代码就执行不了。 即 ViewGroup 的onInterceptTouchEvent返回false,不拦截触摸事件时，最终会执行子View的dispatchTouchEvent。 ViewGroup 的onInterceptTouchEvent返回true,拦截触摸事件，就不会进入if内部，则会执行到后面的程序 12345678if (target == null) &#123; ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; return super.dispatchTouchEvent(ev); &#125; 可以看到，最后会执行super.dispatchTouchEvent(ev)，执行父类即View的dispatchTouchEvent。 View的dispatchTouchEvent如下： 1234567public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event);&#125; 然后又和前面的一样了。执行onTouch或者onTouchEvent。。 3. 总结传递顺序Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; … －&gt; View 通俗语言总结一下，事件来的时候， Activity会询问Window，Window这个事件你能不能消耗， Window一看，你先等等，我去问问DecorView他能不能消耗， DecorView一看，onInterceptTouchEvent返回false啊，不让我拦截啊， (DecorView继承自FrameLayout,FrameLayout是ViewGroup的子类，所以DecorView也是ViewGroup的子类，事件从Activity传到了ViewGroup) 遍历一下子View吧，问问他们能不能消耗，那个谁，事件按在你的身上了，你看看你能不能消耗， 假如子View为RelativeLayout RelativeLayout一看，也没有让我拦截啊，我也得遍历看看这个事件发生在那个子View上面， 到这儿事件从ViewGroup传到View上了 那个TextView,事件在你身上，你能不能消耗了他。TextView一看，消耗不了啊， RelativeLayout一看TextView消耗不了啊，mFirstTouchTarget==null啊，得，我自己消耗吧，嗯！一看自己的onTouchEvent也消耗不了啊！那个DecorView事件我消耗不了， DecorView一看自己，我也消耗不了，继续往上传，那个Window啊。事件我消耗不了啊， Window再告诉Activity事件消耗不了啊。 Activity还得我自己来啊。调用自己的onTouchEvent，还是消耗不了，算了，不要了。 最后Activity的onTouchEvent无论返回什么，事件分发都结束。（如果事件在边界范围外默认会返回false） 参考https://blog.csdn.net/guolin_blog/article/details/9097463 https://blog.csdn.net/guolin_blog/article/details/9153747]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 配置及SSH key及使用]]></title>
    <url>%2Fposts%2F49894.html</url>
    <content type="text"><![CDATA[​ 本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以配置SSH key之后，上传代码到Github远程仓库时就不用输入密码了。一般是在C盘用户目录下有一个 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。连接时必须提供一个公钥用于授权，没有的话就要生成一个。 更多文章欢迎访问我的个人博客–&gt;幻境云图 1. Git 配置配置全局用户名和密码，git提交代码时用来显示你身份和联系方式，并不是github用户名和邮箱 12git config --global user.name "lillusory" //改成自己的git config --global user.email "xueduanli@163.com" //改成自己的 2. 生成SSH key2.1 生成秘钥 执行ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; 命令 生成ssh key 然后会叫你输入保存路径，直接按回车即可，保存在C盘用户目录下 然后会提示输入密码和确认密码，不用输入直接按两下回车即可 到这里SSH key就生成好了，接下来就是配置到github上。 2.2 配置SSH key 登陆Github–&gt;点击头像–&gt;Settings–&gt;SSH and GPG keys–&gt;选择SSh keys上的New SSH keys–&gt;name 随便写，key就是刚才生成的文件中的所有内容。 文件默认是在C盘用户目录下，我的是C:\Users\13452\.ssh 文件夹中应该会有两个文件 ：id_rsa和id_rsa.pub id_rsa.pub就是我们要的key, 一般以ssh-rsa开头，以你刚才输的邮箱结尾。 2.3 测试执行ssh -T git@github.com命令验证一下。 可能会提示，无法验证主机的真实性是否要建立连接，输入yes就行了。 如果，看到： Hi xxx! You’ve successfully authenticated, but GitHub does not # provide shell access. 恭喜你，你的设置已经成功了。 3. 参考Git Book]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
