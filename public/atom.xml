<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻境云图</title>
  
  <subtitle>勿在浮沙筑高台</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lixueduan.com/"/>
  <updated>2019-01-15T13:53:17.336Z</updated>
  <id>https://www.lixueduan.com/</id>
  
  <author>
    <name>illusoryCloud</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下的网络配置</title>
    <link href="https://www.lixueduan.com/posts/b0d13a6d.html"/>
    <id>https://www.lixueduan.com/posts/b0d13a6d.html</id>
    <published>2019-01-14T14:00:00.000Z</published>
    <updated>2019-01-15T13:53:17.336Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要讲了linux如何配置网络，让虚拟机能够连上外网，如何让虚拟机和主机联通，同时介绍了ssh客户端工具连接虚拟机。</p><a id="more"></a><blockquote><p>点击阅读更多系列文章<a href="https://www.lixueduan.com/categories/Linux/">欢迎访问我的个人博客–&gt;幻境云图</a></p></blockquote><h2 id="1-Xshell"><a href="#1-Xshell" class="headerlink" title="1. Xshell"></a>1. Xshell</h2><p>在安装好虚拟机后就可以正常使用了。但是在正常工作中不可能真的在服务器上操作，一般都是通过ssh客户端工具连接服务器进行操作。</p><p>这里用到的客户端工具是<code>Xshell</code>,通过该工具连上服务器后就可以在自己的电脑上操作了。而且还可以开多个窗口，比较方便。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/xshell-use.png" alt="xshell"></p><p>这里新建连接时需要输入要连接的服务器的IP和端口号，账户和密码，端口号默认是22，一般不用改。</p><h2 id="2-网络配置"><a href="#2-网络配置" class="headerlink" title="2. 网络配置"></a>2. 网络配置</h2><h3 id="2-1-桥接模式和NAT模式"><a href="#2-1-桥接模式和NAT模式" class="headerlink" title="2.1 桥接模式和NAT模式"></a>2.1 桥接模式和NAT模式</h3><p>按照上面的方法就可以连上虚拟机了，但是现在虚拟机的IP是自动获取的，<strong>每次重启后都IP都会变</strong>，这肯定不行呀，所以我们需要为虚拟机设置<strong>静态IP</strong>.</p><p>由于我们这里使用的是NAT模式。这个模式下虚拟机可以上网，但是无法和主机联通。</p><p><strong>桥接模式和NAT模式的区别：</strong></p><p>桥接模式下虚拟机可以看做一台真正的独立的电脑，所以桥接模式下需要为虚拟机分配独立的IP，在家里到时无所谓，在公司的话由于IP和电脑绑定的，所以需要网络管理人员给你的虚拟机分配一个IP才行。</p><p>NAT模式下，虚拟机会动态获取IP,虽然有自己的IP但是最终上网还是通过主机上网的。所以NAT模式下不用分配独立的IP,但是<strong>NAT模式下主机和虚拟机无法联通。</strong></p><p><strong>为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。</strong></p><p><strong>为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。</strong></p><p><strong>为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。</strong></p><h3 id="2-2-设置静态IP"><a href="#2-2-设置静态IP" class="headerlink" title="2.2 设置静态IP"></a>2.2 设置静态IP</h3><p>在设置静态IP前我们需要知道主机的IP.</p><p>windows下命令行输入 <code>ipconfig</code> 即可获取到本机IP.</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/ip-query.png" alt="ipconfig"></p><p>然后通过VMware软件对网络进行配置。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/ip-set-way.png" alt="vmware"></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/vm-ip-set.png" alt="static ip"></p><p>接着在虚拟机中配置具体网络信息。</p><h3 id="2-3-网络配置"><a href="#2-3-网络配置" class="headerlink" title="2.3 网络配置"></a>2.3 网络配置</h3><h4 id="2-3-1-配置文件"><a href="#2-3-1-配置文件" class="headerlink" title="2.3.1 配置文件"></a>2.3.1 配置文件</h4><p>网络配置文件在<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>目录下，一般是叫<code>ifcfg-ens33</code></p><p>编辑配置文件 命令：<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>配置如下 ：</p><p>其中ip地址必须和主机在同一网段下，网关就是上边的那个网关。DNS可填可不填。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO="static"  # 手动分配ip</span><br><span class="line">ONBOOT="yes"  # 该网卡是否随网络服务启动</span><br><span class="line">IPADDR="192.168.1.111"  # 该网卡ip地址就是你要配置的固定IP</span><br><span class="line">GATEWAY="192.168.1.2"   # 网关</span><br><span class="line">NETMASK="255.255.255.0"   # 子网掩码 固定值</span><br><span class="line">DNS1="8.8.8.8"    # DNS，8.8.8.8为Google提供的免费DNS服务器的IP地址</span><br><span class="line">DNS2="192.168.1.2"</span><br></pre></td></tr></table></figure><h4 id="2-3-2-配置网络工作"><a href="#2-3-2-配置网络工作" class="headerlink" title="2.3.2 配置网络工作"></a>2.3.2 配置网络工作</h4><p>命令：<code>vi /etc/sysconfig/network</code></p><p>内容：<code>NETWORKING=yes # 网络是否工作，此处一定不能为no</code></p><h4 id="2-3-3-配置公共DNS服务"><a href="#2-3-3-配置公共DNS服务" class="headerlink" title="2.3.3 配置公共DNS服务"></a>2.3.3 配置公共DNS服务</h4><p><code>vi /etc/resolv.conf</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 192.168.1.2</span><br></pre></td></tr></table></figure><h4 id="2-3-4-关闭防火墙"><a href="#2-3-4-关闭防火墙" class="headerlink" title="2.3.4 关闭防火墙"></a>2.3.4 关闭防火墙</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld # 临时关闭防火墙</span><br><span class="line">systemctl disable firewalld # 禁止开机启动</span><br></pre></td></tr></table></figure><h4 id="2-3-5-重启网络服务"><a href="#2-3-5-重启网络服务" class="headerlink" title="2.3.5 重启网络服务"></a>2.3.5 重启网络服务</h4><p><code>service network restart</code></p><p>到此为止网络配置就完成了，现在虚拟机的IP重启后不会变了，也可以连上外网了，还可以和主机联通了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要讲了linux如何配置网络，让虚拟机能够连上外网，如何让虚拟机和主机联通，同时介绍了ssh客户端工具连接虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.lixueduan.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.lixueduan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>超详细的CentOS7安装教程</title>
    <link href="https://www.lixueduan.com/posts/4d7cca6f.html"/>
    <id>https://www.lixueduan.com/posts/4d7cca6f.html</id>
    <published>2019-01-14T14:00:00.000Z</published>
    <updated>2019-01-15T13:53:28.588Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个十分详细的CentOS7的安装教程，对自己的安装过程做了一个记录。主要记录了如何通过VMware虚拟机安装Linux，从软件下载到虚拟机安装等等。</p><a id="more"></a><blockquote><p>点击阅读更多Linux入门系列文章<a href="https://www.lixueduan.com/categories/Linux/">欢迎访问我的个人博客–&gt;幻境云图</a></p></blockquote><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="1-1-VMware下载"><a href="#1-1-VMware下载" class="headerlink" title="1.1 VMware下载"></a>1.1 VMware下载</h3><p>百度网盘下载（内含注册机）</p><p>链接: <code>https://pan.baidu.com/s/1wz4hdNQBikTvyUMNokSVYg</code>提取码: yed7</p><p>怎么安装就不用写了吧。</p><h3 id="1-2-CentOS下载"><a href="#1-2-CentOS下载" class="headerlink" title="1.2 CentOS下载"></a>1.2 CentOS下载</h3><p><code>http://mirrors.163.com/centos/7.6.1810/isos/x86_64/</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/software-install/centos7-down.png" alt=""></p><h2 id="2-CentOS-7安装"><a href="#2-CentOS-7安装" class="headerlink" title="2. CentOS 7安装"></a>2. CentOS 7安装</h2><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/1-create-vm.png" alt=""></p><p>创建虚拟机，这里我们选择自定义安装类型。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/2-custom-install.png" alt=""></p><p>然后选择版本，需要注意兼容问题，一般是向下兼容，14上的虚拟机复制到15上可以用，15的复制到14上可能会用不了。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/3-version-select.png" alt=""></p><p>这里选择稍后再安装。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/4-after-install.png" alt=""></p><p>接着选择系统，这里是CentOS 7 64位。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/5-system-select.png" alt=""></p><p>这个是保存的文件名字。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/6-filename.png" alt=""></p><p>这里一般默认的就行了,电脑配置好的可以调高点。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/7-cpu-select.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/8-memory-select.png" alt=""></p><p>网络这里,如果仅仅是让虚拟机能上网，两种模式都可以的，用桥接的话只要你在局域网内有合法的地址，比如你的ADSL猫是带路由功能的，如果是在单位，那就要网络管理人员给你合法IP才行。NAT模式下，虚拟机从属于主机，也就是访问外部网络必须通过主机来访问，因此虚拟机的IP只有主机才能识别。而桥接模式下，虚拟机和主机是平行关系，共享一张网卡（使用网卡的多个接口），可以直接访问外部网络。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/9-network-select.png" alt=""></p><p>这些都默认的就行了。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/10-IO-select.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/11-disk-select.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/12-newdisk-select.png" alt=""></p><p>这个是虚拟机文件的名字。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/14-filename.png" alt=""></p><p>这里选择自定义硬件。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/15-custom.png" alt=""></p><p>选择镜像文件。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/17-file-select.png" alt=""></p><p>到这里就结束了，点击开启虚拟机后会自动开始安装。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/18-start.png" alt=""></p><p>选择安装CentOS 7</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/19-setup.png" alt=""></p><p>语言选择</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/20-language.png" alt=""></p><p>调一下时间和地区。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/21-time.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/22-time2.png" alt=""></p><p>选择要安装的软件，新手还是安装一个GUI比较好。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/23-software1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/24-software2.png" alt=""></p><p>查看一下网络连接</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/25-network-set1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/26-network-set2.png" alt=""></p><p>开始安装。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/27-begin-install.png" alt=""></p><p>安装过程中可以设置一下账号密码，一个root账户，一个普通账户。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/28-password-set1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/29-password-set2.png" alt=""></p><p>然后耐心等待安装完成就好了。</p><p>安装完成后重启就可以登录系统了。</p><h2 id="3-快照"><a href="#3-快照" class="headerlink" title="3. 快照"></a>3. 快照</h2><p>快照相当于windows中的还原点。在安装好后可以拍摄一张快照，方便恢复或者克隆虚拟机。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/30-backup1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个十分详细的CentOS7的安装教程，对自己的安装过程做了一个记录。主要记录了如何通过VMware虚拟机安装Linux，从软件下载到虚拟机安装等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.lixueduan.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.lixueduan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客优化之gulp压缩静态资源（五）</title>
    <link href="https://www.lixueduan.com/posts/70deabab.html"/>
    <id>https://www.lixueduan.com/posts/70deabab.html</id>
    <published>2019-01-10T14:00:00.000Z</published>
    <updated>2019-01-15T13:47:02.019Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要记录了如何通过<code>gulp</code>工具压缩压缩博客静态文件以加快网站加载速度。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><p>在本系列文章的第二章中也有类似静态资源压缩的教程，是用的<code>hexo-neat</code>插件，最近用着用着出现了一点点问题，无奈之下换用了<code>gulp</code>。这个工具也可以很方便的压缩静态资源。</p><h2 id="1-插件安装"><a href="#1-插件安装" class="headerlink" title="1. 插件安装"></a>1. 插件安装</h2><p>首先需要安装<code>gulp</code>工具</p><p>命令：<code>npm install gulp</code></p><p>接着安装功能模块，包括</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp-htmlclean // 清理html</span><br><span class="line">gulp-htmlmin // 压缩html</span><br><span class="line">gulp-minify-css // 压缩css</span><br><span class="line">gulp-uglify // 混淆js</span><br></pre></td></tr></table></figure><p>命令：<code>npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</code></p><h2 id="2-创建任务"><a href="#2-创建任务" class="headerlink" title="2. 创建任务"></a>2. 创建任务</h2><p>在站点根目录下，新建<code>gulpfile.js</code>文件，文件内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Plugins模块获取</span></span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">//压缩css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">.pipe(htmlclean())</span><br><span class="line">.pipe(htmlmin(&#123;</span><br><span class="line">removeComments: <span class="literal">true</span>,</span><br><span class="line">minifyJS: <span class="literal">true</span>,</span><br><span class="line">minifyCSS: <span class="literal">true</span>,</span><br><span class="line">minifyURLs: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩js 不压缩min.js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以前的写法 </span></span><br><span class="line"><span class="comment">//gulp.task('default', [</span></span><br><span class="line">  <span class="comment">//  'minify-html', 'minify-css', 'minify-js'</span></span><br><span class="line"><span class="comment">//]);</span></span><br><span class="line"><span class="comment">//4.0以后的写法</span></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something after a, b, and c are finished.</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><p>使用时按照以下顺序就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">//先清理文件</span></span><br><span class="line">hexo g  <span class="comment">//编译生成静态文件</span></span><br><span class="line">gulp  <span class="comment">//gulp插件执行压缩任务</span></span><br><span class="line">hexo s <span class="comment">//开启服务</span></span><br></pre></td></tr></table></figure><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4. 问题"></a>4. 问题</h2><p>刚开始弄这个的时候也是各种百度，Google，大部分的文章也是这么写的但是，第二部的js 代码却都有问题，也不能说有问题吧，大部分都是4.0以前的写法，导致现在gulp更新到4.0之后全都无法使用了。可能在看到这篇文章之前也试了各种办法。然后每次都出现这样的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">assert</span>.js:<span class="number">85</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">assert</span>.AssertionError(&#123;</span><br><span class="line">  ^</span><br><span class="line">AssertionError: Task function must be specified</span><br><span class="line">    at Gulp.set [as _setTask] (/home/hope/web/node_modules/undertaker/lib/set-task.js:<span class="number">10</span>:<span class="number">3</span>)</span><br><span class="line">    at Gulp.task (/home/hope/web/node_modules/undertaker/lib/task.js:<span class="number">13</span>:<span class="number">8</span>)</span><br><span class="line">.................</span><br></pre></td></tr></table></figure><p>在看了下gulp相关资料后才发现了问题，接着把js代码稍微改了改终于能用了。不过运行的时候好像也有点问题，不过不影响使用，对这些工具还是不太了解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">21</span>:<span class="number">35</span>:<span class="number">20</span>] The following tasks did not complete: <span class="keyword">default</span>, &lt;anonymous&gt;</span><br><span class="line">[<span class="number">21</span>:<span class="number">35</span>:<span class="number">20</span>] Did you forget to signal async completion?</span><br><span class="line"><span class="comment">//代码里也没这个任务呀</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要记录了如何通过&lt;code&gt;gulp&lt;/code&gt;工具压缩压缩博客静态文件以加快网站加载速度。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Synchronize和Volatile底层实现原理</title>
    <link href="https://www.lixueduan.com/posts/cf1a701a.html"/>
    <id>https://www.lixueduan.com/posts/cf1a701a.html</id>
    <published>2019-01-08T14:00:00.000Z</published>
    <updated>2019-01-14T14:46:26.048Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看<code>并发编程的艺术</code>这本书，希望加深对并发这块的理解。毕竟并发相关还是十分重要的。本文主要是关于<code>第二章Java并发机制的底层实现原理</code>的相关笔记。主要包括<code>volatile</code>,<code>synchronized</code>,<code>原子操作</code>等实现原理的分析。</p><blockquote><p>点击阅读更多系列文章<a href="https://www.lixueduan.com/categories/Java/">我的个人博客–&gt;幻境云图</a></p></blockquote><a id="more"></a><h2 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1. 上下文切换"></a>1. 上下文切换</h2><p><strong>多线程</strong></p><p>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。</p><p><strong>什么是上下文切换</strong></p><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。</p><p>所以任务从保存到再加载的过程就是一次上下文切换。</p><p><strong>上下文切换也会影响多线程的执行速度</strong></p><p>因为线程有创建和上下文切换的开销，所以有时候并发不一定比串行快。</p><p><strong>减少上下文切换的办法</strong></p><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p><ul><li>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一<br>些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li><li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这<br>样会造成大量线程都处于等待状态。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><h2 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2. volatile关键字"></a>2. volatile关键字</h2><p><strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</strong></p><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，其中就包括了<code>Lock前缀</code>.Lock前缀的指令在多核处理器下会引发了两件事情。</p><p><strong>1）将当前处理器缓存行的数据写回到系统内存。</strong></p><p>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。</p><p>如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区<br>域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁<br>定”，<code>缓存一致性</code>机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</p><p><strong>2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</strong></p><p>处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</p><h2 id="3-synchronized原理与应用"><a href="#3-synchronized原理与应用" class="headerlink" title="3. synchronized原理与应用"></a>3. synchronized原理与应用</h2><p><strong>Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</strong></p><p>Java中的每一个对象都可以作为锁。具体表现<br>为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。<br>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</li></ul><h3 id="3-1-底层实现"><a href="#3-1-底层实现" class="headerlink" title="3.1 底层实现"></a>3.1 底层实现</h3><p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。</p><p><code>代码块同步</code>是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的.</p><p>而<code>方法同步</code>是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</p><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h2 id="3-2-Java对象头"><a href="#3-2-Java对象头" class="headerlink" title="3.2 Java对象头"></a>3.2 Java对象头</h2><p>synchronized用的锁是存在Java对象头里的。</p><p>java的对象头由以下三部分组成：</p><blockquote><p>1，Mark Word</p><p>2，指向类的指针</p><p>3，数组长度（只有数组对象才有）</p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java-mark-work%E5%8F%98%E5%8C%96%E7%8A%B6%E6%80%81.png" alt=""></p><h3 id="3-3-锁的升级与对比"><a href="#3-3-锁的升级与对比" class="headerlink" title="3.3 锁的升级与对比"></a>3.3 锁的升级与对比</h3><p>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状<br>态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p><p><strong>偏向锁</strong></p><p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p>偏向锁解除</p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程.</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E5%81%8F%E5%90%91%E9%94%81.png" alt=""></p><p><strong>轻量级锁</strong></p><p>（1）轻量级锁加锁<br>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>（2）轻量级锁解锁<br>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt=""></p><p><strong>优缺点比较</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83.png" alt=""></p><h2 id="4-原子操作的实现原理"><a href="#4-原子操作的实现原理" class="headerlink" title="4. 原子操作的实现原理"></a>4. 原子操作的实现原理</h2><p>原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p><h3 id="4-1-处理器如何实现原子操作"><a href="#4-1-处理器如何实现原子操作" class="headerlink" title="4.1 处理器如何实现原子操作"></a>4.1 处理器如何实现原子操作</h3><p>处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><p><strong>第一个机制是通过总线锁保证原子性。</strong></p><p>所谓总线锁就是使用处理器提供的一个<code>LOCK＃信号</code>，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p><p><strong>第二个机制是通过缓存锁定来保证原子性。</strong></p><p>总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<code>缓存一致性</code>机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效.</p><h3 id="4-2-Java如何实现原子操作"><a href="#4-2-Java如何实现原子操作" class="headerlink" title="4.2 Java如何实现原子操作"></a>4.2 Java如何实现原子操作</h3><p><strong>使用循环CAS实现原子操作</strong></p><p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p><p><strong>CAS实现原子操作的三大问题</strong></p><p>1.ABA问题</p><p>但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。</p><p>2.循环时间长开销大</p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>3.只能保证一个共享变量的原子操作</p><p>操作多个共享变量时无法使用CAS操作，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。</p><p><strong>使用锁机制实现原子操作</strong></p><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文内容来自Java并发编程的艺术</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看&lt;code&gt;并发编程的艺术&lt;/code&gt;这本书，希望加深对并发这块的理解。毕竟并发相关还是十分重要的。本文主要是关于&lt;code&gt;第二章Java并发机制的底层实现原理&lt;/code&gt;的相关笔记。主要包括&lt;code&gt;volatile&lt;/code&gt;,&lt;code&gt;synchronized&lt;/code&gt;,&lt;code&gt;原子操作&lt;/code&gt;等实现原理的分析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;点击阅读更多系列文章&lt;a href=&quot;https://www.lixueduan.com/categories/Java/&quot;&gt;我的个人博客–&amp;gt;幻境云图&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.lixueduan.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.lixueduan.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客之迁移（四）</title>
    <link href="https://www.lixueduan.com/posts/33469.html"/>
    <id>https://www.lixueduan.com/posts/33469.html</id>
    <published>2018-12-27T14:00:00.000Z</published>
    <updated>2019-01-03T13:48:47.084Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要记录了如何通过使用<code>Github</code>的<code>分支功能</code>解决更换电脑后博客更新不方便的问题，让你的博客能在各个电脑上灵活切换。在也不用担心换电脑后博客配置丢失等问题了。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><p>到此为止，我们已经完成了差不多所有的步骤。</p><ul><li>1.搭建博客</li><li>2.优化主题</li><li>3.部署收录</li></ul><p><strong>新问题：</strong></p><p>​    现在博客只能在自己的电脑上更新，如果换电脑了就很麻烦。配置文件主题什么的都要重新弄。所以网上找了找多台电脑同时操作的办法，我们可以利用Github的分支功能。</p><p>​    将博客文件夹下所有文件全<code>push</code>到<code>Github</code>。这样换电脑后直接<code>pull</code>就可以了。</p><h2 id="1-新建分支"><a href="#1-新建分支" class="headerlink" title="1. 新建分支"></a>1. 新建分支</h2><ul><li><p>1.在<code>Github</code>的<code>lillusory.github.io</code>（hexo仓库）上新建一个分支，例如<code>Hexo</code>，并切换到该分支.</p></li><li><p>2.并在该仓库<code>Settings-&gt;Branches-&gt;Default branch</code>中将默认分支设为<code>Hexo</code>.<code>Hexo</code>分支是博客的开发环境，用来写博客，保存原始文件,<code>master</code>分支用于显示，保存生产的静态文件。</p></li><li><p>3.新建分支后将博客目录下的所有文件上传到该分支，注意由于一个<code>git仓库</code>中不能包含其他仓库，所以需要删除掉主题文件夹中的<code>.git</code>目录。</p></li><li><p>4.如果按照前面的博文添加了背景，则需要删掉<code>站点目录\themes\next\source\lib\canvas-nest</code>文件夹中的<code>.git</code>目录。以后需要更新主题时，可以先克隆到本地在复制到相应目录.</p></li></ul><h2 id="2-写博客"><a href="#2-写博客" class="headerlink" title="2. 写博客"></a>2. 写博客</h2><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。</p><ul><li>依次执行<code>git add .</code>、<code>git commit -m &quot;这里写备注&quot;</code>、<code>git push origin 这里写分支名字</code>指令将改动推送到GitHub（此时当前分支应为hexo）。</li><li>然后才执行<code>hexo g -d</code>发布网站到master分支上。</li></ul><h2 id="3-博客迁移"><a href="#3-博客迁移" class="headerlink" title="3. 博客迁移"></a>3. 博客迁移</h2><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><ul><li>克隆仓库<ul><li>使用<code>git clone git@github.com:illusorycloud/illusorycloud.github.io.git</code>拷贝仓库（默认分支为hexo）；//修改成自己的</li></ul></li><li>安装插件 在前面克隆下的项目中安装插件<ul><li>执行命令<code>npm install hexo、npm install</code>、<code>npm install hexo-deployer-git</code></li></ul></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://blog.csdn.net/qq_25560423/article/details/53785707" target="_blank" rel="noopener">如何在多台电脑上更新博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要记录了如何通过使用&lt;code&gt;Github&lt;/code&gt;的&lt;code&gt;分支功能&lt;/code&gt;解决更换电脑后博客更新不方便的问题，让你的博客能在各个电脑上灵活切换。在也不用担心换电脑后博客配置丢失等问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客之部署（三）</title>
    <link href="https://www.lixueduan.com/posts/41257.html"/>
    <id>https://www.lixueduan.com/posts/41257.html</id>
    <published>2018-12-25T04:00:00.000Z</published>
    <updated>2019-01-03T11:35:39.596Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要记录了如何将博客部署至云端，怎么设置个性域名，怎么将自己的网站提交到百度Google。让自己的网站能够出现在各大搜索引擎的具体方法和过程，希望能对大家有帮助。  </p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><h2 id="1-购买个性域名"><a href="#1-购买个性域名" class="headerlink" title="1. 购买个性域名"></a>1. 购买个性域名</h2><p>估计大家折腾了这么久也就是为 了拥有一个自己的个性站点,所以强烈建议大家为自己的博客站点配置一个独一无二的个性域名.我这里选择阿里旗下的<a href="https://wanwang.aliyun.com/?spm=5176.8142029.735711.62.f0586d3eFXYcmo" target="_blank" rel="noopener">万网</a>。我的域名是<a href="https://www.lixueduan.com">www.lixueduan.com</a></p><p>大家可以选择一个自己喜欢的域名。等部署完毕就可以通过域名访问自己的博客了。</p><p><strong>问题：</strong></p><ul><li><p><strong>GithubPages/CodingPages</strong></p><ul><li>Github Pages是<a href="https://github.com/" target="_blank" rel="noopener">Github</a>免费提供给开发者的一款托管个人网站的产品。</li><li>Coding Pages也是<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>免费提供给开发者的一款托管个人网站的产品。</li></ul></li><li><p><strong>关于为什么要部署两次</strong></p><blockquote><p>虽然可以根据自定义域名来访问自己的博客了，但是百度谷歌上都搜索不到，那岂不是很难受<code>╮(╯▽╰)╭</code>。</p><p>所以接下来为了让自己的博客能够被搜索出来，就需要让百度谷歌收录我们的网站。在部署收录过程中发现，<strong><code>Github</code>屏蔽了百度的爬虫</strong>，所以搭建上<code>GithubPages</code>的话无法提交至百度，只有Google可以收录。</p><p>所以为了让百度收录我们网站，就得在Coding上也搭建一个。</p><p>同时在搭建的过程中发现如果先搭建在Github上，然后再搭建Coding时会出现<code>DNS解析</code>冲突。所以需要：<strong>先搭建Coding上的，再搭建Github上的，国外的访问则走<code>Github</code>，国内的访问会走<code>Coding</code>，完美</strong></p></blockquote></li></ul><h2 id="2-部署到CodingPages"><a href="#2-部署到CodingPages" class="headerlink" title="2. 部署到CodingPages"></a>2. 部署到CodingPages</h2><h3 id="2-1-注册coding账户"><a href="#2-1-注册coding账户" class="headerlink" title="2.1 注册coding账户"></a>2.1 注册coding账户</h3><p> 点击这里注册Coding](<a href="https://coding.net/" target="_blank" rel="noopener">https://coding.net/</a>)</p><h3 id="2-2-创建新项目"><a href="#2-2-创建新项目" class="headerlink" title="2.2 创建新项目"></a>2.2 创建新项目</h3><ul><li>注册好后创建一个项目用来部署个人博客，项目路径和项目名称最好和用户名一致</li><li><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-deploy-coding1.png" alt=""></li></ul><h3 id="2-3-开启CodingPages"><a href="#2-3-开启CodingPages" class="headerlink" title="2.3 开启CodingPages"></a>2.3 开启CodingPages</h3><ul><li><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-deploy-coding2.png" alt=""></p><p>点击Pages服务，然后一键开启。</p></li></ul><p>部署master分支</p><p>自定义域名 可以填两个 <code>www.xxx.com</code> 和<code>xxx.com</code></p><p>绑定自定义域名的时候需要在买域名的地方(我这里是阿里的万网)配置DNS解析</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-coding-dns.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加两条CNAME解析</span><br><span class="line">主机记录</span><br><span class="line">一个@，一个www<span class="comment">//@就是无前缀，xxx.com, www就是www.xxx.com</span></span><br><span class="line">解析路线</span><br><span class="line">默认就行</span><br><span class="line">记录值</span><br><span class="line">lillusory.coding.me <span class="comment">//这里改成自己的</span></span><br></pre></td></tr></table></figure><p> 然后可以开启Https访问。</p><p>到这里就可以通过个性域名访问啦。不过现在博客代码还没有<code>push</code>到项目里。</p><h3 id="2-4-Push代码到Coding"><a href="#2-4-Push代码到Coding" class="headerlink" title="2.4 Push代码到Coding"></a>2.4 Push代码到Coding</h3><p><strong>配置SSH key</strong></p><p>首先需要配置一个<code>SSHkey</code>，<code>Git</code>有<code>Http</code>协议和<code>Git</code>协议两种。我们这里使用<code>Git</code>协议就需要配置一个<code>SSH key</code>,等会部署到<code>Github</code>上也需要配置这个。</p><p>具体配置方法如下：</p><p><a href="https://www.lixueduan.com/categories/Git/">Git 配置及SSH key</a></p><p><strong>修改站点配置文件</strong></p><p>这里只配置了Coding，可以先把Github的注释掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Deployment 部署到云端相关配置</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">   github: git<span class="meta">@github</span>.com:illusorycloud/illusorycloud.github.io.git</span><br><span class="line">   coding: git<span class="meta">@git</span>.coding.net:illusorycloud/illusorycloud.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>地址在这里：</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-deploy-coding3.png" alt=""></p><p>配置好后，运行<code>hexo g时就可以把博客部署到Coding上了，也可以通过个性域名访问了。</code></p><h2 id="3-收录到百度"><a href="#3-收录到百度" class="headerlink" title="3. 收录到百度"></a>3. 收录到百度</h2><h3 id="3-1-网站添加"><a href="#3-1-网站添加" class="headerlink" title="3.1 网站添加"></a>3.1 网站添加</h3><p>直接百度搜索你的域名,比如我的<code>www.lixueduan.com</code> ，如果没有收录就会提示暂未收录，点击<code>提交网址</code>。</p><p>点击这个链接进入百度站长平台，登录成功后选择`用户中心–&gt;站点管理–&gt;添加网站 </p><p>输入自己的网站，如<code>www.lixueduan.com</code> 协议头如果开启了<code>https</code>就选<code>https</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-baidu1-add.png" alt=""></p><h3 id="3-2-网站验证"><a href="#3-2-网站验证" class="headerlink" title="3.2 网站验证"></a>3.2 网站验证</h3><p>然后会验证这个网站是不是你的，选CNAME验证</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-baidu2-verfication.png" alt=""></p><p>然后去域名哪里添加一条解析即可。</p><p>记录类型–&gt;<code>CNAME</code></p><p>主机记录—&gt;前面那一串<code>l3rUDBLOMX</code></p><p>记录值–&gt;后面那个<code>ziyuan.baidu.com</code></p><p>其他的都按默认的就行了，添加后别删除，需要一直留着。</p><h3 id="3-3-站点地图"><a href="#3-3-站点地图" class="headerlink" title="3.3 站点地图"></a>3.3 站点地图</h3><p>接下来我们需要生成网站地图<code>sitemap</code>,使用sitemap方式向百度提交我们的网址</p><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p><ul><li>先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save  #sitemap.xml适合提交给谷歌搜素引擎</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save  #baidusitemap.xml适合提交百度搜索引擎</span><br></pre></td></tr></table></figure><ul><li>在<code>站点配置文件</code>中添加如下代码</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-baidu-sitemap</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure><p>在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了.</p><p>然后将博客重新部署后就可以直接访问站点地图了。如<code>https://www.lixueduan.com/baidusitemap.xml</code></p><p>然后将这个<code>站点地图</code>提交到百度</p><p><code>站点管理--&gt;站点属性--&gt;链接提交--&gt;自动提交--&gt;sitemap</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-baidu3-sitemap.png" alt=""></p><p>完成后就算是提交成功了，百度比较慢，要好几天才能收录。</p><h2 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4. 部署到GitHub"></a>4. 部署到GitHub</h2><p>步骤和Coding差不多的。</p><h3 id="4-1-注册Github账号"><a href="#4-1-注册Github账号" class="headerlink" title="4.1 注册Github账号"></a>4.1 注册Github账号</h3><p><a href="https://github.com/" target="_blank" rel="noopener">点这里注册Github账号</a></p><h3 id="4-2-创建新仓库"><a href="#4-2-创建新仓库" class="headerlink" title="4.2 创建新仓库"></a>4.2 创建新仓库</h3><p>也是名字必须和用户名一样，必须按照这个格式<code>username.github.io</code>，例如<code>lillusorycloud.github.io</code></p><p>创建好仓库后找到<code>Setings</code>  往下拉，找到<code>Github Pages</code>  设置<code>Custom domain</code>填下自定义域名，如<code>www.lixueduan.com</code>.如果有<code>Enforce HTTPS</code>选项也可以勾上。</p><h3 id="4-3-Push代码到Github"><a href="#4-3-Push代码到Github" class="headerlink" title="4.3 Push代码到Github"></a>4.3 Push代码到Github</h3><p><strong>配置SSH key</strong></p><p>首先需要配置一个<code>SSHkey</code>，<code>Git</code>有<code>Http</code>协议和<code>Git</code>协议两种。我们这里使用<code>Git</code>协议就需要配置一个<code>SSH key</code>,等会部署到<code>Github</code>上也需要配置这个。</p><p>具体配置方法：</p><p><a href="https://www.lixueduan.com/categories/Git/">Git 配置及SSH key</a></p><p><strong>修改站点配置文件</strong></p><p><code>repository</code>中添加一个<code>github</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Deployment 部署到云端相关配置</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">    github: git<span class="meta">@github</span>.com:illusorycloud/illusorycloud.github.io.git</span><br><span class="line">    coding: git<span class="meta">@git</span>.coding.net:illusorycloud/illusorycloud.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>配置好后，运行<code>hexo g时就可以把博客同时部署到Coding和Github上了，也可以通过个性域名访问了。</code></p><h2 id="5-收录到Google"><a href="#5-收录到Google" class="headerlink" title="5. 收录到Google"></a>5. 收录到Google</h2><p>和百度差不多。</p><h3 id="5-1-网站添加"><a href="#5-1-网站添加" class="headerlink" title="5.1 网站添加"></a>5.1 网站添加</h3><p>首先进入<a href="https://www.google.com/webmasters/#?modal_active=none" target="_blank" rel="noopener">Google站点平台</a></p><p>然后添加资源，注意<code>http</code>和<code>https</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-add.png" alt=""></p><h3 id="5-2-验证所有权"><a href="#5-2-验证所有权" class="headerlink" title="5.2 验证所有权"></a>5.2 验证所有权</h3><p>然后验证所有权,选择DNS供应商</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-verfication1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-verfication2.png" alt=""></p><p>供应商选择其他，然后选择添加CNAME记录，在域名解析中添加一条记录。也是添加后不要删除。</p><h3 id="5-3-站点地图"><a href="#5-3-站点地图" class="headerlink" title="5.3 站点地图"></a>5.3 站点地图</h3><p>验证后就可以添加站点地图了</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-sitemap.png" alt=""></p><p>提交成功后,我们的站点就已经被Google收录了.大概一天就能收录成功，比百度块一些。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文主要讲了怎么将博客部署到<code>Coding</code>和<code>Github</code>和怎么让<code>百度</code>,<code>Google</code>收录我们的网站。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><p><a href="https://www.jianshu.com/p/cc902b54d493" target="_blank" rel="noopener">基于Hexo的个人博客</a></p><p><a href="https://blog.csdn.net/qq_35561857/article/details/81590953" target="_blank" rel="noopener">Hex博客搭建</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要记录了如何将博客部署至云端，怎么设置个性域名，怎么将自己的网站提交到百度Google。让自己的网站能够出现在各大搜索引擎的具体方法和过程，希望能对大家有帮助。  &lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门系列（一）之HelloWorld</title>
    <link href="https://www.lixueduan.com/posts/22f8f0ac.html"/>
    <id>https://www.lixueduan.com/posts/22f8f0ac.html</id>
    <published>2018-12-22T14:00:00.000Z</published>
    <updated>2019-01-13T08:40:32.601Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了SpringBoot是什么、怎么使用和为什么要用SpringBoot。使用Spring boot ，可以轻松的创建独立运行的程序，非常容易构建独立的服务组件，是实现分布式架构、微服务架构利器。Spring boot简化了第三方包的引用，通过提供的starter，简化了依赖包的配置。</p><a id="more"></a><h2 id="1-SpringBoot介绍"><a href="#1-SpringBoot介绍" class="headerlink" title="1. SpringBoot介绍"></a>1. SpringBoot介绍</h2><p><strong>Spring boot的优点</strong></p><ul><li>轻松创建独立的Spring应用程序。</li><li>内嵌Tomcat、jetty等web容器，不需要部署WAR文件。</li><li>提供一系列的“starter” 来简化的Maven配置。</li><li>开箱即用，尽可能自动配置Spring。</li></ul><h2 id="2-创建SpringBoot项目"><a href="#2-创建SpringBoot项目" class="headerlink" title="2.创建SpringBoot项目"></a>2.创建SpringBoot项目</h2><p>如果使用的是IDEA则非常方便的创建SpringBoot项目，在新建项目的时候选择Spring initializr填写一些基本信息后就可以了。</p><p> Eclipse的话就需要去官网构建。</p><p><strong>maven构建项目</strong></p><p>1、访问<code>http://start.spring.io/</code></p><p>2、选择构建工具Maven Project、Spring Boot版本等一些工程基本信息</p><p>3、点击Generate Project下载项目压缩包</p><p>4、解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK！</p><h3 id="2-controller"><a href="#2-controller" class="headerlink" title="2. controller"></a>2. controller</h3><p>@SpringBootApplication </p><p>SpringBoot启动类注解</p><h3 id="3-hello"><a href="#3-hello" class="headerlink" title="3 hello"></a>3 hello</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/gethello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-整合Servlet"><a href="#3-整合Servlet" class="headerlink" title="3. 整合Servlet"></a>3. 整合Servlet</h2><h3 id="3-1-方式一-扫描注解注册Servlet"><a href="#3-1-方式一-扫描注解注册Servlet" class="headerlink" title="3.1 方式一 扫描注解注册Servlet"></a>3.1 方式一 扫描注解注册Servlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"FirstServlet"</span>,urlPatterns = <span class="string">"/first"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@WebServlet(name = “FirstServlet”,urlPatterns = “/first”) 相当于web.xml中的以下配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.demo.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/firse<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@ServletComponentScan  让SpringBoot在启动时扫描@WebServlet注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-方式二-通过方法注册Servlet"><a href="#3-2-方式二-通过方法注册Servlet" class="headerlink" title="3.2 方式二 通过方法注册Servlet"></a>3.2 方式二 通过方法注册Servlet</h3><p>该方式 创建servlet后不用任何注解，直接在启动器中注册servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">app</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(app.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">Register</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean bean=<span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> FirstServlet());</span><br><span class="line">        bean.addUrlMappings(<span class="string">"/first"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-整合Filter"><a href="#4-整合Filter" class="headerlink" title="4. 整合Filter"></a>4. 整合Filter</h2><h3 id="4-1-方式一-扫描注解注册Filter"><a href="#4-1-方式一-扫描注解注册Filter" class="headerlink" title="4.1 方式一 扫描注解注册Filter"></a>4.1 方式一 扫描注解注册Filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(filterName = &quot;firstFilter&quot;,urlPatterns =&quot;/first&quot;)</span><br><span class="line">public class FirstFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;进入Filter&quot;);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(&quot;放行Filter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@WebFilter(filterName = “firstFilter”,urlPatterns =”/first”)</strong></p><h3 id="4-2-方式二-通过方法注册Servlet"><a href="#4-2-方式二-通过方法注册Servlet" class="headerlink" title="4.2 方式二 通过方法注册Servlet"></a>4.2 方式二 通过方法注册Servlet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean RegisterFilter() &#123;</span><br><span class="line">    FilterRegistrationBean bean = new FilterRegistrationBean&lt;&gt;(new FirstFilter());</span><br><span class="line">    bean.addUrlPatterns(&quot;/first&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-整合Listener"><a href="#5-整合Listener" class="headerlink" title="5. 整合Listener"></a>5. 整合Listener</h2><h3 id="5-1-方式一-扫描注解注册Listener"><a href="#5-1-方式一-扫描注解注册Listener" class="headerlink" title="5.1 方式一 扫描注解注册Listener"></a>5.1 方式一 扫描注解注册Listener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@WebListener</strong></p><h3 id="5-2-方式二-通过方法注册Listener"><a href="#5-2-方式二-通过方法注册Listener" class="headerlink" title="5.2 方式二 通过方法注册Listener"></a>5.2 方式二 通过方法注册Listener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean&lt;FirstListener&gt; <span class="title">registerListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;FirstListener&gt; bean = <span class="keyword">new</span>              ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> FirstListener());</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-访问静态资源"><a href="#6-访问静态资源" class="headerlink" title="6. 访问静态资源"></a>6. 访问静态资源</h2><p><strong>1.从classpath/static目录下（名称必须是static）</strong></p><p>2.ServletContext根目录下</p><p><strong>src/main/webapp(名称必须是webapp)</strong></p><p>访问路径：localhost:8080/filename</p><h2 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7.文件上传"></a>7.文件上传</h2><h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"fileuploadController"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    上传文件<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"filename"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">//对方法返回值会自动做json格式转换 不用@responseBody了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileuploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileuploadController"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">fileUpload</span><span class="params">(MultipartFile filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(filename.getOriginalFilename());</span><br><span class="line">        filename.transferTo(<span class="keyword">new</span> File(<span class="string">"e:/"</span>+filename.getOriginalFilename()));</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>,<span class="string">"ok"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件大小限制"><a href="#文件大小限制" class="headerlink" title="文件大小限制"></a>文件大小限制</h4><p>application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.servlet.multipart.max-request-size=200MB</span><br><span class="line">spring.servlet.multipart.max-file-size=200MB</span><br></pre></td></tr></table></figure><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><h3 id="8-1注解方式"><a href="#8-1注解方式" class="headerlink" title="8.1注解方式"></a>8.1注解方式</h3><ul><li><strong>Servlet</strong>   @WebServlet(name = “FirstServlet”,urlPatterns = “/first”)</li><li><strong>Filter</strong>       @WebFilter(filterName = “firstFilter”,urlPatterns =”/first”)</li><li><strong>Listener</strong> @WebListener</li><li>启动器     @ServletComponentScan</li></ul><h3 id="8-2-方法注册"><a href="#8-2-方法注册" class="headerlink" title="8.2 方法注册"></a>8.2 方法注册</h3><p>不用加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------Servlet------------------   </span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">Register</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean bean=<span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> FirstServlet());</span><br><span class="line">        bean.addUrlMappings(<span class="string">"/first"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//---------Filter------------------   </span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">RegisterFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> FirstFilter());</span><br><span class="line">    bean.addUrlPatterns(<span class="string">"/first"</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------Linster------------------  </span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean&lt;FirstListener&gt; <span class="title">registerListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;FirstListener&gt; bean = <span class="keyword">new</span>              ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> FirstListener());</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了SpringBoot是什么、怎么使用和为什么要用SpringBoot。使用Spring boot ，可以轻松的创建独立运行的程序，非常容易构建独立的服务组件，是实现分布式架构、微服务架构利器。Spring boot简化了第三方包的引用，通过提供的starter，简化了依赖包的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="https://www.lixueduan.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.lixueduan.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客之优化（二）</title>
    <link href="https://www.lixueduan.com/posts/58273.html"/>
    <id>https://www.lixueduan.com/posts/58273.html</id>
    <published>2018-12-22T14:00:00.000Z</published>
    <updated>2019-01-03T11:32:08.985Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要包含了博客主题优化相关内容，第三方服务和插件的配置与使用。如：炫酷头像动态背景、链接变色、鼠标点击效果、站点字数、访客数统计等。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><h3 id="0-选择主题"><a href="#0-选择主题" class="headerlink" title="0. 选择主题"></a>0. 选择主题</h3><p>你可以点击这里选择你喜欢的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Themes</a>,里面有大量美观的主题 </p><p>我这里用的是简约著称的<code>Next</code>主题.</p><ul><li>下载主题<ul><li>使用<code>git</code>命令下载该主题到本地.</li><li><code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>  </li><li>clone成功后,你的Themes文件夹下就会有next主题文件了.</li></ul></li><li>Hexo配置文件:<ul><li>都叫<code>_config.yml</code></li><li>一份位于站点根目录下，主要包含 Hexo 本身的配置,称为 <code>站点配置文件</code></li><li>另一份位于主题目录下主要用于配置主题相关的选项,称为<code>主题配置文件</code></li></ul></li><li>开启主题<ul><li><code>站点配置文件</code>进行修改: 将<code>theme: landscape</code>修改为 <code>theme: next</code> </li></ul></li></ul><h3 id="1-侧边栏头像设置"><a href="#1-侧边栏头像设置" class="headerlink" title="1. 侧边栏头像设置"></a>1. 侧边栏头像设置</h3><p>新版next注意引入了该功能,直接在<code>主题配置文件</code>修改即可,如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar 头像</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line"><span class="attr">  url:</span> <span class="string">/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># 圆形头像</span></span><br><span class="line"><span class="attr">  rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 透明度 0~1之间</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 头像旋转</span></span><br><span class="line"><span class="attr">  rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-设置个人社交图标链接"><a href="#2-设置个人社交图标链接" class="headerlink" title="2. 设置个人社交图标链接"></a>2. 设置个人社交图标链接</h3><p>直接在<code>主题配置文件</code>修改即可,如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Social Links. 社交链接 前面为链接地址 后面是图标 </span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/illusorycloud</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  E-Mail:</span> <span class="attr">mailto:xueduan.li@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"><span class="comment"># 图标配置 </span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="comment">#是否显示图标</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#是否只显示图标</span></span><br><span class="line"><span class="attr">  icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#是否开启图标变化(就是刷新后会变颜色)</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="3-添加菜单项"><a href="#3-添加菜单项" class="headerlink" title="3. 添加菜单项"></a>3. 添加菜单项</h3><p>1.先在<code>主题配置文件</code>修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  AAAAA:</span> <span class="string">/BBBBB/</span> <span class="string">||</span> <span class="string">CCC</span></span><br><span class="line"><span class="string">其中AAA</span> <span class="string">为菜单项的名字,BBB是路径,CCC是菜单项显示的图标</span></span><br></pre></td></tr></table></figure><p> <code>next</code> 使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 提供的图标 ,在这里可以选择自己喜欢的图标.</p><p>2.生成上述路径的文件</p><p><code>git</code>命令行输入</p><p><code>hexo new page BBB</code> –其中BBB替换为具体的名字,会在<code>站点目录\source</code>下新增一个BBB文件夹,文件夹中有一个<code>index.md</code>文件，需要在文件头中增加一句<code>type: XXX</code>,例如<code>type: categories</code>。这样就会在这个页面显示所有的分类了。</p><p>3.修改主题文件下的对应语言的配置文件,这里是中文就修改<code>zh-CN.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">首页</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="string">AAAA</span> <span class="string">:</span> <span class="string">XXXX</span></span><br><span class="line"><span class="string">AAA为上边的菜单项名字,XXX为中文的名字</span></span><br></pre></td></tr></table></figure><h3 id="4-添加RSS"><a href="#4-添加RSS" class="headerlink" title="4. 添加RSS"></a>4. 添加RSS</h3><ul><li><p>1.安装插件</p><ul><li><p>首先在Git中运行<code>npm install --save hexo-generator-feed</code>命令,安装插件,插件会放在</p><p><code>node_modules</code>文件夹里面.</p></li></ul></li><li><p>2.修改<code>站点配置文件</code></p><ul><li>安装好插件后,打开站点配置文件_config.yml`,在末尾加入以下代码:</li></ul></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br></pre></td></tr></table></figure><ul><li>3.修改<code>主题配置文件</code><ul><li>打开主题配置文件<code>_config.yml</code>,找到<code>rss</code> 添加配置:<code>rss: /atom.xml</code> </li></ul></li></ul><h3 id="5-设置酷炫动态背景"><a href="#5-设置酷炫动态背景" class="headerlink" title="5. 设置酷炫动态背景"></a>5. 设置酷炫动态背景</h3><p>next主题提供了两种背景可以选择.</p><ul><li>第一种背景（我是用的这种）</li></ul><p>新版本的next主题的话直接在主题配置文件中,找到<code>canvas-nest</code> 修改为<code>canvas-nest: true</code>,</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  onmobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile or not</span></span><br><span class="line"><span class="attr">  color:</span> <span class="string">'0,0,255'</span> <span class="comment"># RGB values, use ',' to separate</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">0.5</span> <span class="comment"># the opacity of line: 0~1</span></span><br><span class="line"><span class="attr">  zIndex:</span> <span class="bullet">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line"><span class="attr">  count:</span> <span class="number">99</span> <span class="comment"># the number of lines</span></span><br></pre></td></tr></table></figure><p>进入theme/next目录</p><p> 执行命令<code>git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</code></p><ul><li>第二种背景</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>也是需要下载依赖 </p><ol><li>进入theme/next目录</li><li>执行命令：<code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></li></ol><p><strong>4个背景中只能开启一种背景,不然会出错</strong></p><h3 id="6-设置网站logo"><a href="#6-设置网站logo" class="headerlink" title="6. 设置网站logo"></a>6. 设置网站logo</h3><p>把你的图片放在<code>themes/next/source/images</code>里 </p><p>打开<code>主题配置文件</code>_config.yml ,找到字段<code>favicon:</code>  都修改为对应路径</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line"><span class="attr">  small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line"><span class="attr">  medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line"><span class="attr">  apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line"><span class="attr">  safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br></pre></td></tr></table></figure><h3 id="7-实现点击出现桃心效果"><a href="#7-实现点击出现桃心效果" class="headerlink" title="7. 实现点击出现桃心效果"></a>7. 实现点击出现桃心效果</h3><p><code>themes/next/source/js/src</code>里面 新建一个love.js,</p><p>复制下面的代码进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>然后打开<code>\themes\next\layout\_layout.swig</code>文件,在末尾 添加以下代码： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-修改文章内链接文本样式"><a href="#8-修改文章内链接文本样式" class="headerlink" title="8. 修改文章内链接文本样式"></a>8. 修改文章内链接文本样式</h3><p>鼠标移动到连接上变颜色</p><p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式，：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-设置顶部滚动加载条"><a href="#9-设置顶部滚动加载条" class="headerlink" title="9. 设置顶部滚动加载条"></a>9. 设置顶部滚动加载条</h3><p>打开<code>next\layout\_partials\head</code>文件，在文件末尾添加以下代码: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#1E92FB</span>; <span class="comment">/*进度条颜色*/</span></span></span><br><span class="line"><span class="undefined">        height: 3px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress-inner</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#1E92FB</span>, 0 0 5<span class="selector-tag">px</span>     <span class="selector-id">#1E92FB</span>; <span class="comment">/*阴影颜色*/</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-activity</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-top-color</span>: <span class="selector-id">#1E92FB</span>;    <span class="comment">/*上边框颜色*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-left-color</span>: <span class="selector-id">#1E92FB</span>;    <span class="comment">/*左边框颜色*/</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="10-在每篇文章末尾统一添加“本文结束”标记"><a href="#10-在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="10. 在每篇文章末尾统一添加“本文结束”标记"></a>10. 在每篇文章末尾统一添加“本文结束”标记</h3><p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>page-end-tag.swig</code> 文件,并添加以下内容： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文字可以自己修改--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #A2CD5A;font-size:15px;"</span>&gt;</span>------------------本文到此结束<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您的阅读------------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后， <code>post-footer</code> 之前添加下面的代码 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include 'page-end-tag.swig' %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后打开主题配置文件（<code>_config.yml</code>),在末尾添加： </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">page_end_tag:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="11-静态资源压缩"><a href="#11-静态资源压缩" class="headerlink" title="11. 静态资源压缩"></a>11. 静态资源压缩</h3><p>Hexo自动生成的html中有很多空白的地方,会影响加载速度,所以最好还是压缩一下.</p><p>这里使用<code>hexo-neat</code>插件来压缩。</p><ul><li><p>安装插件</p><ul><li><code>npm install hexo-neat --save</code></li></ul></li><li><p>在<code>站点配置文件</code>添加配置</p><ul><li><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line"><span class="comment"># 博文压缩</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩html</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 压缩css  跳过min.css</span></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.css'</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 压缩js 跳过min.js</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  mangle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  output:</span></span><br><span class="line"><span class="attr">  compress:</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.js'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/jquery.fancybox.pack.js'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/index.js'</span>  </span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/love.js'</span></span><br><span class="line"><span class="comment"># 压缩博文配置结束</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.使用 </p><ul><li>以后再执行<code>hexo g</code>命令时就会自动压缩了</li></ul></li></ul><h3 id="12-主页文章添加阴影效果"><a href="#12-主页文章添加阴影效果" class="headerlink" title="12. 主页文章添加阴影效果"></a>12. 主页文章添加阴影效果</h3><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: <span class="number">60</span>px;</span><br><span class="line">   margin-bottom: <span class="number">60</span>px;</span><br><span class="line">   padding: <span class="number">25</span>px;</span><br><span class="line">   -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>);</span><br><span class="line">   -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="13-修改文章底部的的标签样式"><a href="#13-修改文章底部的的标签样式" class="headerlink" title="13. 修改文章底部的的标签样式"></a>13. 修改文章底部的的标签样式</h3><p>打开模板文件<code>/themes/next/layout/_macro/post.swig</code>，找到<code>rel=&quot;tag&quot;&gt;#</code>字段， 将<code># 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>,其中tag是你选择标签图标的名字,也是可以自定义的 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(tag.path) &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"tag"</span>&gt;</span> <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="14-实现文章字数统计和预计阅读时间"><a href="#14-实现文章字数统计和预计阅读时间" class="headerlink" title="14. 实现文章字数统计和预计阅读时间"></a>14. 实现文章字数统计和预计阅读时间</h3><p>1.在站点根目录下使用<code>GitBash</code>命令安装 <code>hexo-wordcoun</code>t插件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>2.在全局配置文件<code>_config.yml</code>中激活插件:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">    symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>3.在主题的配置文件<code>_config.yml</code>中进行如下配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_total:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><p>到此,我们就实现了文章字数统计和预估时间的显示功能</p><h3 id="15-在文章底部增加版权信息"><a href="#15-在文章底部增加版权信息" class="headerlink" title="15. 在文章底部增加版权信息"></a>15. 在文章底部增加版权信息</h3><p>修改<code>主题配置文件</code>,找到<code>creative_commons</code>字段</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="comment">#选择一个License</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="comment">#是否在侧边栏显示</span></span><br><span class="line"><span class="attr">  sidebar:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="comment">#是否在文章末尾显示</span></span><br><span class="line"><span class="attr">  post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="16-文章置顶"><a href="#16-文章置顶" class="headerlink" title="16. 文章置顶"></a>16. 文章置顶</h3><p>打开文件：<code>node_modules/hexo-generator-index/lib/generator.js</code>,将原来的代码用下面的代码替换掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写文章的时候,在标题加上top值,数值越大排在越前面.</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag: hexo </span><br><span class="line">copyright: true</span><br><span class="line">password: xxx</span><br><span class="line">top: 150</span><br></pre></td></tr></table></figure><h3 id="17-在网站底部加上访问量"><a href="#17-在网站底部加上访问量" class="headerlink" title="17. 在网站底部加上访问量"></a>17. 在网站底部加上访问量</h3><p><strong>Next主题配置这个就比较方便了</strong></p><p>打开<code>主题配置文件</code>，找到如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_views_icon:</span> <span class="string">eye</span></span><br><span class="line"><span class="attr">  post_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure><p>将<code>enable</code>的值由<code>false</code>改为<code>true</code>，便可以看到页脚出现访问量.</p><p>另外本地预览时访客数异常是正常的,部署至云端后就不会出现这样的问题.</p><h3 id="18-网站搜索功能"><a href="#18-网站搜索功能" class="headerlink" title="18. 网站搜索功能"></a>18. 网站搜索功能</h3><p>1.安装插件</p><p>​    站点目录下执行命令<code>npm install hexo-generator-searchdb --save</code></p><p>2.修改<code>站点配置文件</code> </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>3.修改<code>主题配置文件</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="string">enable</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># unescape html strings to the readable one</span></span><br><span class="line"><span class="attr">  unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>重新开启服务后即可看到效果。</p><h3 id="TODO开启留言评论功能"><a href="#TODO开启留言评论功能" class="headerlink" title="TODO开启留言评论功能"></a>TODO开启留言评论功能</h3><p>//TODO 待更新</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要包含了博客主题优化相关内容，第三方服务和插件的配置与使用。如：炫酷头像动态背景、链接变色、鼠标点击效果、站点字数、访客数统计等。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客之搭建（一）</title>
    <link href="https://www.lixueduan.com/posts/18973.html"/>
    <id>https://www.lixueduan.com/posts/18973.html</id>
    <published>2018-12-20T14:00:00.000Z</published>
    <updated>2019-01-03T12:03:17.080Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了如何搭建自己的博客。基于Hexo框架在本地搭建自己博客的全过程，包括了环境准备到Hexo初始化，再到服务的开启等。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><ul><li>Git  <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下载地址</a></li><li>Node.js  <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js下载地址</a></li></ul><p>小白式安装，一直下一步就ok了。</p><p>都安装好后就可以开始安装Hexo啦.</p><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h2><ul><li>1.新建一个文件夹,用于安装Hexo,以后这个就是放博客文件的.</li><li>2.在此文件夹右键,<code>Git Bash Here</code>,打开Git</li><li>3.安装Hexo  命令<code>npm install -g hexo</code></li><li>4.初始化Hexo  命令<code>hexo init</code></li><li>5.安装组件  命令<code>npm install</code></li></ul><p>到此为止,Hexo就算是安装完成了。</p><h2 id="3-开启服务"><a href="#3-开启服务" class="headerlink" title="3. 开启服务"></a>3. 开启服务</h2><ul><li><p>1.<code>hexo generate</code>或者简写<code>hexo g</code>  编译,生成静态文件,就是生成一个个html文件.</p></li><li><p>2.开启服务<code>hexo server</code>或者<code>hexo s</code>   成功开启后就可以在本地访问了。 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><ul><li>假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，<code>hexo server -p 端口号</code>来改变端口号  </li><li>如<code>hexo server -p 5000</code>  将端口号换为<code>5000</code>,默认是<code>4000</code></li></ul></li><li>3.常用命令 <ul><li><code>hexo clean</code>  清除缓存文件  </li><li><code>hexo deploy</code>或者<code>hexo d</code>  部署网站到云端,这个后面再讲。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了如何搭建自己的博客。基于Hexo框架在本地搭建自己博客的全过程，包括了环境准备到Hexo初始化，再到服务的开启等。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(五)--从输入URL到页面加载的过程中发生了什么</title>
    <link href="https://www.lixueduan.com/posts/5863.html"/>
    <id>https://www.lixueduan.com/posts/5863.html</id>
    <published>2018-11-15T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.253Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对用户从浏览器输入URL到页面加载的这一过程进行了具体分析与叙述。包括：<code>DNS解析</code>、<code>发送HTTP请求</code>、<code>TCP连接</code>、<code>服务器响应</code>、<code>浏览器解析渲染页面</code>等。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><p>总体来说分为以下几个过程:</p><ul><li>1.DNS解析</li><li>2.TCP连接</li><li>3.发送HTTP请求</li><li>4.服务器处理请求并返回HTTP报文</li><li>5.浏览器解析渲染页面</li><li>6.连接结束</li></ul><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcpip-http-relation-about.jpg" alt=""></p><h2 id="1-DNS解析"><a href="#1-DNS解析" class="headerlink" title="1. DNS解析"></a>1. DNS解析</h2><p>解析域名，找到主机IP。如百度对应的IP为<code>180.97.33.108</code> ,浏览器输入IP也可以访问到百度。</p><p>（1）浏览器会缓存DNS一段时间，一般2-30分钟不等。如果有缓存，直接返回IP，否则下一步。</p><p>（2）缓存中无法找到IP，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回IP，否则下一步。（在计算机本地目录etc下有一个hosts文件，hosts文件中保存有域名与IP的对应解析，通常也可以修改hosts科学上网或破解软件。）</p><p>（3）进行了（1）（2）本地查询无果，只能借助于网络。路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这时一般都能够得到相应的IP。如果还是无果，只能借助于DNS递归解析了。</p><p>（4）这时，ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com顶级域名服务器，到baidu的域名服务器。</p><p>到这里，浏览器就获得了IP。在DNS解析过程中，常常会解析出不同的IP。比如，电信的是一个IP，网通的是另一个IP。这是采取了智能DNS的结果，降低运营商间访问延时，在多个运营商设置主机房，就近访问主机。电信用户返回电信主机IP，网通用户返回网通主机IP。当然，劫持DNS，也可以屏蔽掉一部分网点的访问，某防火长城也加入了这一特性。</p><h2 id="2-TCP连接"><a href="#2-TCP连接" class="headerlink" title="2. TCP连接"></a>2. TCP连接</h2><p>浏览器与网站建立TCP连接</p><p>浏览器利用IP直接与网站主机通信。浏览器发出TCP（SYN标志位为1）连接请求，主机返回TCP（SYN，ACK标志位均为1）应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认。浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP链接建立完成。</p><h2 id="3-发送HTTP请求"><a href="#3-发送HTTP请求" class="headerlink" title="3. 发送HTTP请求"></a>3. 发送HTTP请求</h2><p>浏览器发起HTTP请求</p><p>其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: <strong>请求行</strong>, <strong>请求报头</strong>和<strong>请求正文</strong>。 </p><p><strong>请求行</strong></p><p>请求行包括：请求方法，URL  ， 协议版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求行：请求方法    URL    协议版本</span><br><span class="line">    eg:GET   index.html HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><p><strong>请求报头</strong></p><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br>常见的请求报头有: <code>Accept</code>,<code>Accept-Charset</code>,<code>Accept-Encoding</code>,<code>Accept-Language,</code> <code>Content-Type</code>, <code>Authorization</code>, <code>Cookie</code>, <code>User-Agent</code>等。</p><p><strong>请求正文</strong></p><p>当使用<code>POST</code>, <code>PUT</code>等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置<code>Content-Type: application/json</code></p><p>浏览器向主机发起一个HTTP请求。请求中包含访问的URL，也就是<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a> ，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。</p><h2 id="4-服务器响应"><a href="#4-服务器响应" class="headerlink" title="4. 服务器响应"></a>4. 服务器响应</h2><p>服务器对请求做出响应并返回HTTP响应报文。自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，例如Tomcat。</p><p>HTTP响应报文也是由三部分组成: <strong>响应行</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p><p><strong>响应行</strong></p><p>响应行包括：协议版本 状态码 状态码描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应行包括：协议版本   状态码 状态码描述</span><br><span class="line">    eg:  HTTP/<span class="number">1.1</span>  <span class="number">200</span>    OK</span><br></pre></td></tr></table></figure><p><strong>响应报头</strong></p><p>常见的响应报头字段有: Server, Connection…。</p><p><strong>响应报文</strong></p><p>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。</p><h2 id="5-浏览器解析渲染页面"><a href="#5-浏览器解析渲染页面" class="headerlink" title="5. 浏览器解析渲染页面"></a>5. 浏览器解析渲染页面</h2><p>返回状态码200 OK，表示服务器可以相应请求，返回报文，由于在报头中<code>Content-type:“text/html”</code>，浏览器以HTML形式呈现，而不是下载文件。</p><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的?</p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p><p><strong>重定向 负载均衡</strong></p><p>但是，对于大型网站存在多个主机站点，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200 OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。</p><p>补充一点的就是，重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于<a href="lixueduan.com">lixueduan.com</a>，<a href="www.lixueduan.com">www.lixueduan.com</a>会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。</p><h2 id="6-连接结束"><a href="#6-连接结束" class="headerlink" title="6. 连接结束"></a>6. 连接结束</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><h2 id="7-计算机网络常见问题"><a href="#7-计算机网络常见问题" class="headerlink" title="7. 计算机网络常见问题"></a>7. 计算机网络常见问题</h2><p>看完系列文章，下面这些问题应该也不是问题了。</p><ul><li>1.TCP三次握手和四次挥手</li><li>2.在浏览器中输入url地址-&gt;&gt;显示主页的过程</li><li>3.HTTP和HTTPS的区别</li><li>4.TCP、UDP协议的区别</li><li>5.常见的状态码。</li></ul><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h2><p><code>https://segmentfault.com/a/1190000006879700</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对用户从浏览器输入URL到页面加载的这一过程进行了具体分析与叙述。包括：&lt;code&gt;DNS解析&lt;/code&gt;、&lt;code&gt;发送HTTP请求&lt;/code&gt;、&lt;code&gt;TCP连接&lt;/code&gt;、&lt;code&gt;服务器响应&lt;/code&gt;、&lt;code&gt;浏览器解析渲染页面&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(四)--HTTP与HTTPS</title>
    <link href="https://www.lixueduan.com/posts/21307.html"/>
    <id>https://www.lixueduan.com/posts/21307.html</id>
    <published>2018-11-12T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.255Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了<code>HTTP</code>、<code>HTTPS</code>的基本概念及两者的区别，<code>HTTPS</code>的工作原理及优缺点，最后介绍了HTTP的响应状态码。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h2 id="1-HTTP和HTTPS基本概念"><a href="#1-HTTP和HTTPS基本概念" class="headerlink" title="1. HTTP和HTTPS基本概念"></a>1. HTTP和HTTPS基本概念</h2><p>　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>　　HTTPS：是以<strong>安全</strong>为目标的HTTP通道，简单讲是<strong>HTTP的安全版</strong>，即HTTP下加入<strong>SSL层</strong>，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP--&gt; HTTP--&gt;TCP--&gt;IP</span><br><span class="line">HTTPS-&gt; HTTP--&gt;SSL--&gt;TCP--&gt;IP</span><br></pre></td></tr></table></figure><p>　　HTTPS协议的<strong>主要作用</strong>：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="2-HTTP与HTTPS的区别"><a href="#2-HTTP与HTTPS的区别" class="headerlink" title="2. HTTP与HTTPS的区别"></a>2. HTTP与HTTPS的区别</h2><p>　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用<strong>HTTP协议传输隐私信息非常不安全</strong>，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，<strong>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全</strong>。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/https-key-lvalue.jpg" alt=""></p><p>　　<strong>HTTPS和HTTP的区别:</strong></p><p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="3-HTTPS工作原理"><a href="#3-HTTPS工作原理" class="headerlink" title="3. HTTPS工作原理"></a>3. HTTPS工作原理</h2><p>　　我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p><strong>SSL协议的握手过程</strong></p><p>分为五个步骤:</p><p>第一步，客户端给出SSL协议版本号、一个客户端生成的随机数1（Client random），以及客户端支持的加密方法。</p><p>第二步，服务端根据客服端支持的加密方法选出双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数2（Server random）。</p><p>第三步，客户端确认数字证书有效，然后生成一个新的随机数3（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。</p><p>第四步，服务端使用自己的私钥，获取客户端发来的随机数3（即Premaster secret）。到这里双方都拥有三个随机数了，为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。 </p><p>第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</p><p>第六步，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。 </p><p>第七步，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 </p><p>到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。 </p><p>  <img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/https-ssl-connection.png" alt="https握手过程"></p><h2 id="4-HTTPS的优缺点"><a href="#4-HTTPS的优缺点" class="headerlink" title="4. HTTPS的优缺点"></a>4. HTTPS的优缺点</h2><p>　　<strong>优点:</strong></p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”</p><p>　　<strong>缺点:</strong></p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h2 id="5-HTTP响应状态码"><a href="#5-HTTP响应状态码" class="headerlink" title="5. HTTP响应状态码"></a>5. HTTP响应状态码</h2><p>状态码以3位数字和原因短语组成，例如 200 OK 。</p><p>数字的第一位指定了响应类型，后两位无分类。响应类别一共有5种：</p><ul><li>1XX Informational(信息性状态码)</li><li>2XX Success(成功状态码)</li><li>3XX Redirection(重定向状态码)</li><li>4XX Client Error(客户端错误状态码)</li><li>5XX Server Error(服务器错误状态码)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span>：请求成功      处理方式：获得响应的内容，进行处理 </span><br><span class="line"></span><br><span class="line"><span class="number">201</span>：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到 </span><br><span class="line"></span><br><span class="line"><span class="number">202</span>：请求被接受，但处理尚未完成    处理方式：阻塞等待 </span><br><span class="line"></span><br><span class="line"><span class="number">204</span>：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃</span><br><span class="line"></span><br><span class="line"><span class="number">300</span>：该状态码不被HTTP/<span class="number">1.0</span>的应用程序直接使用， 只是作为<span class="number">3</span>XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃</span><br><span class="line"><span class="number">301</span>：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL</span><br><span class="line"><span class="number">302</span>：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL </span><br><span class="line"></span><br><span class="line"><span class="number">304</span> 请求的资源未更新     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">400</span> 非法请求     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">401</span> 未授权     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">403</span> 禁止     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">404</span> 没有找到     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>XX 回应代码以“<span class="number">5</span>”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求    处理方式：丢弃</span><br></pre></td></tr></table></figure><h2 id="6-HTTP长连接、短连接"><a href="#6-HTTP长连接、短连接" class="headerlink" title="6. HTTP长连接、短连接"></a>6. HTTP长连接、短连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p><strong>https加密是在传输层</strong> </p><p>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的<strong>header域</strong>也好，body域也罢都是会被加密的。</p><p>当使用<strong>tcpdump或者wireshark</strong>之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用<strong>Charels(Mac)、Fildder(Windows)</strong>抓包工具，那当然看到是明文的。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><code>https://www.cnblogs.com/qiangxia/p/5261813.html</code></p><p><code>https://www.cnblogs.com/wqhwe/p/5407468.html</code></p><p><code>http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了&lt;code&gt;HTTP&lt;/code&gt;、&lt;code&gt;HTTPS&lt;/code&gt;的基本概念及两者的区别，&lt;code&gt;HTTPS&lt;/code&gt;的工作原理及优缺点，最后介绍了HTTP的响应状态码。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.lixueduan.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(三)--TCP如何保证传输可靠性</title>
    <link href="https://www.lixueduan.com/posts/18422.html"/>
    <id>https://www.lixueduan.com/posts/18422.html</id>
    <published>2018-11-08T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.257Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要叙述了TCP协议是如何保证传输的可靠性的，主要保证手段包括：<code>序列号</code>、<code>校验和</code></p><p>、<code>流量控制</code>、<code>拥塞控制</code>、<code>停止等待协议</code>、<code>超时重传</code>、<code>连接管理</code>等。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h2 id="1-主要保证方式"><a href="#1-主要保证方式" class="headerlink" title="1. 主要保证方式"></a>1. 主要保证方式</h2><ol><li><strong>序列号:</strong>应用数据被分割成 TCP 认为最适合发送的数据块,同时给每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>停止等待协议(确认应答)</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li><strong>连接管理:</strong> 三次握手四次挥手,保证可靠的连接，是保证可靠性的前提。 </li></ol><h2 id="2-停止等待协议"><a href="#2-停止等待协议" class="headerlink" title="2. 停止等待协议"></a>2. 停止等待协议</h2><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><p><strong>1) 无差错情况:</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-normal.jpg" alt="normal"></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong> [<img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-tiemout.jpg" alt="timeout"></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong>：当确认消息在传输过程丢失 <img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-lost.jpg" alt="lost">A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：<ol><li>丢弃这个重复的M1消息，不向上层交付。</li><li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li></ol></li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到 [<img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-late.jpg" alt="late">A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：<ol><li>A收到重复的确认后，直接丢弃。</li><li>B收到重复的M1后，也直接丢弃重复的M1。</li></ol></li></ul><h2 id="3-ARQ协议"><a href="#3-ARQ协议" class="headerlink" title="3. ARQ协议"></a>3. ARQ协议</h2><p>即自动重传请求 ARQ 协议(Automatic Repeat reQuest )，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。</p><p><strong>优点：</strong> 简单</p><p><strong>缺点：</strong> 信道利用率低</p><h2 id="4-连续ARQ协议"><a href="#4-连续ARQ协议" class="headerlink" title="4. 连续ARQ协议"></a>4. 连续ARQ协议</h2><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h2 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5. 流量控制"></a>5. 流量控制</h2><ul><li>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</li><li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</li><li><strong>TCP 利用滑动窗口实现流量控制的机制。</strong></li><li><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></li><li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</li></ul><h2 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h2><p><strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</strong></p><p> 拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降 </p><p>拥塞控制所要做的都有一个<strong>前提：网络能够承受现有的网络负荷。</strong>拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p><p>几种拥塞控制方法</p><p>​    慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><p><strong>慢开始和拥塞避免</strong></p><p>​    发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p><p>​    发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p> <strong>慢开始算法：</strong>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。 </p><p><strong>拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 </p><p><strong>快重传与快恢复</strong></p><p> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。  </p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><code>https://blog.csdn.net/liuchenxia8/article/details/80428157</code></p><p><code>https://blog.csdn.net/yangbodong22011/article/details/48473183</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要叙述了TCP协议是如何保证传输的可靠性的，主要保证手段包括：&lt;code&gt;序列号&lt;/code&gt;、&lt;code&gt;校验和&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;、&lt;code&gt;流量控制&lt;/code&gt;、&lt;code&gt;拥塞控制&lt;/code&gt;、&lt;code&gt;停止等待协议&lt;/code&gt;、&lt;code&gt;超时重传&lt;/code&gt;、&lt;code&gt;连接管理&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://www.lixueduan.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(二)--TCP三次握手四次挥手</title>
    <link href="https://www.lixueduan.com/posts/25338.html"/>
    <id>https://www.lixueduan.com/posts/25338.html</id>
    <published>2018-11-05T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.260Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了<code>TCP/IP</code>的三次握手和四次挥手具体步骤及其原因分析。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h3 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h3><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-connection-three.jpg" alt=""></p><p><code>step1:第一次握手</code><br>建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入<strong>SYN_SENT</strong>状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。</p><p><code>step2:第二次握手</code><br>服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入<strong>SYN_RCVD</strong>状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。</p><p><code>step3:第三次握手</code></p><p>客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入<strong>ESTABLISHED </strong>(TCP连接成功)**状态，完成三次握手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">建立连接前要确认客户端和服务端的接收和发送功能是否正常。</span><br><span class="line">第一次客户端发送SYN时 什么也确认不了</span><br><span class="line">第二次服务端发送SYN+ACK 可以确认服务端发送功能正常</span><br><span class="line">第三次 客户端收到服务端发送的YSN+ACK 可以确认客户端发送接收功能正常</span><br><span class="line">最后客户端发送ACK 服务端接收到后 可以确认服务端发送功能正常</span><br><span class="line">到此就确认完毕了。</span><br></pre></td></tr></table></figure><h3 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h3><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-close-connection-four.jpg" alt=""></p><p><code>step1：第一次挥手</code><br>首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。 <strong>客户端</strong>进入<strong>FIN_WAIT1</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我（Client端）没有数据要发给你（Server端）了&quot;，但是如果你（Server端）还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK</span><br></pre></td></tr></table></figure><p><code>step2：第二次挥手</code><br><strong>服务器</strong>收到这个FIN进入<strong>CLOSE_WAIT</strong>状态，然后它给客户端发送一个ACK，确认ack为收到的序号加一。</p><p><strong>客户端</strong>收到ACK应答后进入<strong>FIN_WAIT2</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">告诉Client端，你的请求我收到了，但是我（Server端）还没准备好，请继续你等我的消息&quot;</span><br></pre></td></tr></table></figure><p><code>step3：第三次挥手</code><br>服务端关闭服务器到客户端的连接，发送一个FIN给客户端。<strong>服务端</strong>进入<strong>LAST_ACK</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">告诉Client端，好了，我（Server端）这边数据发完了，准备好关闭连接了</span><br></pre></td></tr></table></figure><p><code>step4：第四次挥手</code></p><p><strong>客户端</strong>收到FIN后，进入<strong>TIME_WAIT</strong>状态    并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。</p><p>服务端收到客户端回复的ACK后立即关闭，服务端进入<strong>CLOASED</strong>状态</p><p>而客户端要等待2MSL后关闭 进入<strong>CLOASED</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client端收到FIN报文后，&quot;就知道可以关闭连接了，所以发送ACK。但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后没有立即，而是进入TIME_WAIT状态，如果Server端没有收到ACK那么自己还可以重传。Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</span><br></pre></td></tr></table></figure><h3 id="3-TIME-WAIT状态详解"><a href="#3-TIME-WAIT状态详解" class="headerlink" title="3. TIME-WAIT状态详解"></a>3. TIME-WAIT状态详解</h3><p>为什么Client端要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？</p><p><strong>保证TCP协议的全双工连接能够可靠关闭，保证这次连接的重复数据段从网络中消失</strong></p><p>假设由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，Client端在等待2MSL时间后都没收到信息，说明Server端已经收到自己发送的ACK并且成功关闭了。<br><strong>假设CLient端直接关闭了：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待<span class="number">2</span>倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</span><br></pre></td></tr></table></figure><p><strong>2MSL:Maximum Segment Lifetime 即数据在网络中保存的最大时间。</strong></p><p><em>简单易懂的说法:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</span><br></pre></td></tr></table></figure><h3 id="4-TCP-的有限状态机"><a href="#4-TCP-的有限状态机" class="headerlink" title="4. TCP 的有限状态机"></a>4. TCP 的有限状态机</h3><p>红色为客户端 蓝色为服务端 细箭头为异常变化</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-status-map.png" alt="TCP"></p><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><code>https://www.baidu.com/link?url=_mlor11BLttd1jmMU4k9OP0gqcjNKhZQ9fJuvbMOhkuH9-lVeB-y3VIVK1neZURi_tmR3rg1lj2lfgvvGhTV-q&amp;wd=&amp;eqid=d0144c250007b69c000000035bfdfafc</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了&lt;code&gt;TCP/IP&lt;/code&gt;的三次握手和四次挥手具体步骤及其原因分析。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://www.lixueduan.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(一)--OSI七层模型</title>
    <link href="https://www.lixueduan.com/posts/25470.html"/>
    <id>https://www.lixueduan.com/posts/25470.html</id>
    <published>2018-11-03T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要通过OSI七层模型与常用TCP/IP5层模型介绍了各层的主要作用，包括<code>应用层</code>，<code>运输层</code>，<code>网络层</code>，<code>数据链路层</code>，<code>物理层</code>等。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h2 id="OSI与TCP-IP模型"><a href="#OSI与TCP-IP模型" class="headerlink" title="OSI与TCP/IP模型"></a>OSI与TCP/IP模型</h2><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/osi-tcp-ip-model.png" alt="Model"></p><p><strong><code>应用层:</code>通过应用进程间的交互来完成特定网络应用。</strong></p><p><strong><code>运输层：</code>向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。</strong></p><p><strong><code>网络层：</code>通过路由算法，为报文或分组通过通信子网选择最适当的路径。</strong></p><p><strong><code>数据链路层：</code>其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</strong> </p><p><strong><code>物理层：</code>利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-ip-model.gif" alt=""></p><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><p><strong>主要作用:通过应用进程间的交互来完成特定网络应用。</strong></p><p><strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><h3 id="2-运输层"><a href="#2-运输层" class="headerlink" title="2. 运输层"></a>2. 运输层</h3><p>　<strong>主要任务：向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。</strong></p><p>　<strong>主要作用</strong>：向高层屏蔽下层数据通信的具体细节，即向用户透明的传送报文。</p><p>主要用到的协议：</p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h4 id="2-1-UDP"><a href="#2-1-UDP" class="headerlink" title="2.1 UDP"></a>2.1 UDP</h4><ol><li>UDP 是无连接的；</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li><li>UDP 是面向报文的；</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li><li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ol><h4 id="2-2-TCP"><a href="#2-2-TCP" class="headerlink" title="2.2 TCP"></a>2.2 TCP</h4><ol><li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li><li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ol><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><p><strong>主要任务：通过路由算法，为报文或分组通过通信子网选择最适当的路径。</strong>该层控制数据链路层与物理层之间的信息转发，建立、维持与终止网络的连接。具体的说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p><p><strong>一般的，数据链路层是解决统一网络内节点之间的通信，而网络层主要解决不同子网之间的通信。例如路由选择问题。</strong></p><p>在实现网络层功能时，需要解决的主要问题如下：</p><p><strong>寻址</strong>：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一 个唯一的地址。由于各个子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）</p><p><strong>交换：</strong>规定不同的交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者包括报文转发技术和分组转发技术。<br><strong>路由算法：</strong>当源节点和路由节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径，由发送端传送的接受端。<br><strong>连接服务：</strong>与数据链路层的流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测</p><h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h3><p><strong>其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</strong> </p><p><strong>主要功能</strong>：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p><p><strong>具体工作</strong>：接受来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上一层的数据帧，拆装为位流形式的数据转发到物理层；并且还负责处理接受端发回的确认帧的信息，以便提供可靠的数据传输。</p><p>该层通常又被分为 介质访问控制(MAC)和逻辑链路控制(LLC)两个子层：<br> <strong>MAC子层</strong>的主要任务是<strong>解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制。</strong><br><strong>LLC子层</strong>的主要任务是<strong>建立和维护网络连接，执行差错校验、流量控制和链路控制。</strong></p><h3 id="5-物理层"><a href="#5-物理层" class="headerlink" title="5. 物理层"></a>5. 物理层</h3><p><strong>主要功能：利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。</strong></p><p><strong>作用</strong>：实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质与物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p><p><strong>透明传输的意义就是：不管传的是什么，所采用的设备只是起一个通道作用，把要传输的内容完好的传到对方！</strong></p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><h3 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h3><p><code>https://blog.csdn.net/yaopeng_2005/article/details/7064869</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要通过OSI七层模型与常用TCP/IP5层模型介绍了各层的主要作用，包括&lt;code&gt;应用层&lt;/code&gt;，&lt;code&gt;运输层&lt;/code&gt;，&lt;code&gt;网络层&lt;/code&gt;，&lt;code&gt;数据链路层&lt;/code&gt;，&lt;code&gt;物理层&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://www.lixueduan.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十二）--观察者模式</title>
    <link href="https://www.lixueduan.com/posts/48bcf013.html"/>
    <id>https://www.lixueduan.com/posts/48bcf013.html</id>
    <published>2018-10-25T14:00:00.000Z</published>
    <updated>2019-01-05T13:54:21.709Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java23种设计模式中的观察者模式，并结合实例描述了观察者模式的具体实现和优缺点分析。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-观察者模式介绍"><a href="#1-观察者模式介绍" class="headerlink" title="1. 观察者模式介绍"></a>1. 观察者模式介绍</h2><blockquote><p>让多个观察者对象同时监听某一个主题对象，这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。<br>在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。</p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/design_pattern/twelve-observer.jpeg" alt=""></p><p><strong>该模式包含四个角色</strong></p><ul><li><strong>抽象被观察者角色</strong>：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</li><li><strong>抽象观察者角色</strong>：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li><li><strong>具体被观察者角色</strong>：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</li><li><strong>具体观察者角色</strong>：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</li></ul><h2 id="2-观察者模式实现"><a href="#2-观察者模式实现" class="headerlink" title="2. 观察者模式实现"></a>2. 观察者模式实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象观察者</span></span><br><span class="line"><span class="comment"> * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象被观察者接口</span></span><br><span class="line"><span class="comment"> * 声明了添加、删除、通知观察者方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体观察者</span></span><br><span class="line"><span class="comment"> * 实现update方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(age + <span class="string">"岁的"</span> + name + <span class="string">"收到推送的消息："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体被观察者</span></span><br><span class="line"><span class="comment"> * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> <span class="keyword">implements</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observerList = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observerList.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observerList.isEmpty()) &#123;</span><br><span class="line">            observerList.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observerList.size(); i++) &#123;</span><br><span class="line">            Observer observer = observerList.get(i);</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        System.out.println(<span class="string">"推送消息："</span> + message);</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyServer myServer = <span class="keyword">new</span> MyServer();</span><br><span class="line">        User lillusory = <span class="keyword">new</span> User(<span class="string">"lillusory"</span>, <span class="number">22</span>);</span><br><span class="line">        User Az = <span class="keyword">new</span> User(<span class="string">"Az"</span>, <span class="number">17</span>);</span><br><span class="line">        myServer.registerObserver(lillusory);</span><br><span class="line">        myServer.registerObserver(Az);</span><br><span class="line">        myServer.PushMessage(<span class="string">"第一条推送消息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        myServer.removeObserver(Az);<span class="comment">//Az取消注册后就收不到消息</span></span><br><span class="line">        User yiqixing = <span class="keyword">new</span> User(<span class="string">"意琦行"</span>, <span class="number">999</span>);</span><br><span class="line">        myServer.registerObserver(yiqixing);<span class="comment">//新增的观察者只能收到后面的消息</span></span><br><span class="line">        myServer.PushMessage(<span class="string">"第二条推送消息"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">        推送消息：第一条推送消息</span><br><span class="line">                <span class="number">22</span>岁的lillusory收到推送的消息：第一条推送消息</span><br><span class="line">                <span class="number">17</span>岁的Az收到推送的消息：第一条推送消息</span><br><span class="line">                -------------------------------</span><br><span class="line">                推送消息：第二条推送消息</span><br><span class="line">                <span class="number">22</span>岁的lillusory收到推送的消息：第二条推送消息</span><br><span class="line">                <span class="number">999</span>岁的意琦行收到推送的消息：第二条推送消息</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>优点：</strong></p><p>1.降低重复代码，使得代码更清晰、更易读、更易扩展</p><p>2.解耦，使得代码可维护性更好，修改代码的时候可以尽量少改地方</p><p><strong>应用场景：</strong></p><p>1.对一个对象状态的更新需要其他对象同步更新</p><p>2.对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节，如消息推送.</p><p><strong>观察者模式在Java中的应用及解读</strong></p><p>JDK是有直接支持观察者模式的，就是java.util.Observer这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called whenever the observed object is changed. An</span></span><br><span class="line"><span class="comment">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's</span></span><br><span class="line"><span class="comment">     * observers notified of the change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是观察者的接口，定义的观察者只需要实现这个接口就可以了。update()方法，被观察者对象的状态发生变化时，被观察者的notifyObservers()方法就会调用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector obs;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** Construct an Observable with zero Observers. */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    obs = <span class="keyword">new</span> Vector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds an observer to the set of observers for this object, provided </span></span><br><span class="line"><span class="comment">     * that it is not the same as some observer already in the set. </span></span><br><span class="line"><span class="comment">     * The order in which notifications will be delivered to multiple </span></span><br><span class="line"><span class="comment">     * observers is not specified. See the class comment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o   an observer to be added.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException   if the parameter o is null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">        obs.addElement(o);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是被观察者的父类，也就是主题对象。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>https://www.cnblogs.com/xrq730/p/4908686.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java23种设计模式中的观察者模式，并结合实例描述了观察者模式的具体实现和优缺点分析。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十一）--模板方法模式</title>
    <link href="https://www.lixueduan.com/posts/57ae709c.html"/>
    <id>https://www.lixueduan.com/posts/57ae709c.html</id>
    <published>2018-10-24T14:00:00.000Z</published>
    <updated>2019-01-05T13:50:13.383Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java23种设计模式中的模板方法模式，并结合实例描述了模板方法模式的具体实现和优缺点分析。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-模板方法模式介绍"><a href="#1-模板方法模式介绍" class="headerlink" title="1. 模板方法模式介绍"></a>1. 模板方法模式介绍</h2><p><strong>模板方法模式是类的行为模式。</strong></p><blockquote><p> 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。</p><p> 这就是模板方法模式的用意。</p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/design_pattern/eleven-template.png" alt=""></p><p>　　<strong>抽象模板(Abstract Template)角色有如下责任：</strong></p><ul><li><p>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</p></li><li><p>定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p></li></ul><p>　　<strong>具体模板(Concrete Template)角色又如下责任：</strong></p><ul><li><p>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</p></li><li><p>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p></li></ul><h2 id="2-模板方法模式实现"><a href="#2-模板方法模式实现" class="headerlink" title="2. 模板方法模式实现"></a>2. 模板方法模式实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">假设炒菜有三个步骤，A下菜，B炒菜，C起锅。</span><br><span class="line">那么可以写一个抽象类，因为所有的菜都可以看成这三个步骤。</span><br><span class="line">然后炒菜和起锅这两个步骤也是一样的，当然炒菜可能也不一样╮(╯▽╰)╭。在抽象类中可以直接实现，然后下菜这个步骤应为是不同的菜所以不同。写成抽象类，等子类去实现。</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstract</span> <span class="title">Class</span> </span>&#123;  </span><br><span class="line">   <span class="comment">//模板方法，用来控制炒菜的流程 （炒菜的流程是一样的-复用）</span></span><br><span class="line">    <span class="comment">//申明为final，不希望子类覆盖这个方法，防止更改流程的执行顺序</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cookProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.MethodA();</span><br><span class="line">       <span class="keyword">this</span>.MethodB();</span><br><span class="line">       <span class="keyword">this</span>.MethodC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：下菜是不一样的，由子类实现</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title">MethodA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//第二步：是一样的，所以直接实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炒啊炒啊炒~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//步骤C 起锅</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">MethodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"菜炒好了，起锅~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现类继承抽象类</span></span><br><span class="line"><span class="comment">//炒白菜</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass_BaiCai</span> <span class="keyword">extends</span> <span class="title">test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"往锅里加的是白菜~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//炒肉</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass_Meat</span> <span class="keyword">extends</span> <span class="title">test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">MethodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"往锅里加的是肉~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> <span class="title">Method</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒 - 白菜</span></span><br><span class="line">        ConcreteClass_BaoCai BaiCai = <span class="keyword">new</span> ConcreteClass_BaoCai();</span><br><span class="line">        BaiCai.cookProcess();</span><br><span class="line"><span class="comment">//炒 - 肉</span></span><br><span class="line">        ConcreteClass_ Meat  meat= <span class="keyword">new</span> ConcreteClass_Meat();</span><br><span class="line">        meat.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">往锅里加的是白菜~</span><br><span class="line">炒啊炒啊炒~</span><br><span class="line">菜炒好了，起锅~</span><br><span class="line">往锅里加的是肉~</span><br><span class="line">炒啊炒啊炒~</span><br><span class="line">菜炒好了，起锅~</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>模板方法模式在Java中的应用</strong></p><p>最常见的就是Servlet了。</p><p><strong>HttpServlet担任抽象模板角色</strong></p><p>　　　　模板方法：由service()方法担任。</p><p>　　　　基本方法：由doPost()、doGet()等方法担任。</p><p><strong>MyServlet担任具体模板角色</strong></p><p>自定义的servlet置换掉了父类HttpServlet中七个基本方法中的其中两个，分别是doGet()和doPost()。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>https://www.cnblogs.com/qiumingcheng/p/5219664.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java23种设计模式中的模板方法模式，并结合实例描述了模板方法模式的具体实现和优缺点分析。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十）--策略模式</title>
    <link href="https://www.lixueduan.com/posts/a7982bdc.html"/>
    <id>https://www.lixueduan.com/posts/a7982bdc.html</id>
    <published>2018-10-23T14:00:00.000Z</published>
    <updated>2019-01-05T13:54:00.482Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java23种设计模式中的策略模式，并结合实例描述了策略模式的具体实现和策略模式的优缺点分析。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-策略模式介绍"><a href="#1-策略模式介绍" class="headerlink" title="1. 策略模式介绍"></a>1. 策略模式介绍</h2><blockquote><p><strong>策略模式是对算法的包装</strong></p><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/design_pattern/ten-bridge.gif" alt=""></p><p>　　这个模式涉及到三个角色：</p><p>　　●　　环境(Context)角色：持有一个Strategy的引用。</p><p>　　●　　抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p><p>　　●　　具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。</p><h2 id="2-策略模式实现"><a href="#2-策略模式实现" class="headerlink" title="2. 策略模式实现"></a>2. 策略模式实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口抽象策略 定义一个两个整数间的计算方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略A 加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略B 减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略C 乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略D 除法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyD</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"除数不能为零"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义具体的环境角色，持有Strategy接口的引用</span></span><br><span class="line"><span class="comment">// 并且有get和set方法可以完成策略更换</span></span><br><span class="line"><span class="comment">// 在环境角色中调用接口的方法完成动作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.calculate(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//加</span></span><br><span class="line">            Context contextA = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">            System.out.println(contextA.calculate(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">            <span class="comment">//减</span></span><br><span class="line">            Context contextB = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">            System.out.println(contextB.calculate(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">            <span class="comment">//乘</span></span><br><span class="line">            Context contextC = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyC());</span><br><span class="line">            System.out.println(contextC.calculate(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">            <span class="comment">//除</span></span><br><span class="line">            Context contextD = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyD());</span><br><span class="line">            System.out.println(contextD.calculate(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="number">12</span></span><br><span class="line">    <span class="number">8</span></span><br><span class="line">    <span class="number">20</span></span><br><span class="line">    <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>策略模式的重心不是如何实现算法</strong>（就如同工厂模式的重心不是工厂中如何产生具体子类一样），而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><p><strong>优点</strong></p><p>1.让代码更优雅，避免了多重条件if…else语句。</p><p>2.策略模式提供了管理相关算法簇的办法，恰当使用继承可以把公共代码移到父类，从而避免了代码重复。</p><p><strong>缺点</strong></p><p>1.客户端必须知道所有的策略类，并自行决定使用 哪一个策略，这意味着客户端必须理解这些算法的区别，以便选择恰当的算法</p><p>2.如果备选策略很多，对象的数据会很多</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>https://www.cnblogs.com/xrq730/p/4906313.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java23种设计模式中的策略模式，并结合实例描述了策略模式的具体实现和策略模式的优缺点分析。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（九）--享元模式</title>
    <link href="https://www.lixueduan.com/posts/34e634e7.html"/>
    <id>https://www.lixueduan.com/posts/34e634e7.html</id>
    <published>2018-10-22T14:00:00.000Z</published>
    <updated>2019-01-05T13:51:16.052Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java23种设计模式中的享元模式，并结合实例描述了享元模式的具体实现，具体优缺点和单例模式的对比。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-享元模式介绍"><a href="#1-享元模式介绍" class="headerlink" title="1. 享元模式介绍"></a>1. 享元模式介绍</h2><p>享元模式：“享”就是分享之意，指一物被众人共享，而这也正是该模式的终旨所在。</p><blockquote><p>享元模式有点类似于单例模式，都是只生成一个对象来被共享使用。存储这些共享实例对象的地方称为<strong>享元池</strong> 。享元对象能做到共享的关键是区分了<strong>内部状态(Intrinsic State)</strong>和<strong>外部状态(Extrinsic State)</strong>。</p><p> <strong>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享</strong>。如围棋中的的黑棋白棋，不会随外部环境的变化而变化，无论在任何环境下黑棋始终是黑棋。</p><p><strong>外部状态是随环境改变而改变的、不可以共享的状态</strong>。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。比如每颗棋子的位置是不同的。</p></blockquote><p>围棋中的黑棋和白棋可以是共享的对象，不用每次都创建一个新的对象。这样就只需要创建黑棋和白棋两个对象了。颜色是不会变得，所以是内部状态。落下得位置是随机的，所以作为外部状态。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/design_pattern/nine-flyweight.jpg" alt=""></p><h2 id="2-单纯享元模式"><a href="#2-单纯享元模式" class="headerlink" title="2. 单纯享元模式"></a>2. 单纯享元模式</h2><p>　　在单纯的享元模式中，所有的享元对象都是可以共享的。</p><p>　　单纯享元模式所涉及到的角色如下：</p><p>　　●　　<strong>抽象享元(Flyweight)角色 ：</strong>给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p><p>　　●　　<strong>具体享元(ConcreteFlyweight)角色：</strong>实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p><p>　　<strong>●　　享元工厂(FlyweightFactory)角色</strong> ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//围棋棋子类：抽象享元类  </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IgoChessman</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getColor</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Coordinates coord)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"棋子颜色："</span> + <span class="keyword">this</span>.getColor() + <span class="string">"，棋子位置："</span> + coord.getX() + <span class="string">"，"</span> + coord.getY() );    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//黑色棋子类：具体享元角色A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackIgoChessman</span> <span class="keyword">extends</span> <span class="title">IgoChessman</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"黑色"</span>;  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//白色棋子类：具体享元角色B </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteIgoChessman</span> <span class="keyword">extends</span> <span class="title">IgoChessman</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"白色"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//围棋棋子工厂类：享元端角色，享元工厂类 使用单例模式进行设计  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IgoChessmanFactory</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IgoChessmanFactory instance = <span class="keyword">new</span> IgoChessmanFactory();  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hashtable ht; <span class="comment">//使用Hashtable来存储享元对象，充当享元池</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IgoChessmanFactory</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ht = <span class="keyword">new</span> Hashtable();  </span><br><span class="line">        IgoChessman black,white;  </span><br><span class="line">        black = <span class="keyword">new</span> BlackIgoChessman();  </span><br><span class="line">        ht.put(<span class="string">"b"</span>,black);  </span><br><span class="line">        white = <span class="keyword">new</span> WhiteIgoChessman();  </span><br><span class="line">        ht.put(<span class="string">"w"</span>,white);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//返回享元工厂类的唯一实例  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IgoChessmanFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//通过key来获取存储在Hashtable中的享元对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IgoChessman <span class="title">getIgoChessman</span><span class="params">(String color)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> (IgoChessman)ht.get(color);    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//坐标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinates</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coordinates</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.x = x;  </span><br><span class="line">        <span class="keyword">this</span>.y = y;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.x = x;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.y = y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        IgoChessman black1,black2,black3,white1,white2;  </span><br><span class="line">        IgoChessmanFactory factory;  </span><br><span class="line">        <span class="comment">//获取享元工厂对象  </span></span><br><span class="line">        factory = IgoChessmanFactory.getInstance();  </span><br><span class="line">        <span class="comment">//通过享元工厂获取三颗黑子  </span></span><br><span class="line">        black1 = factory.getIgoChessman(<span class="string">"b"</span>);  </span><br><span class="line">        black2 = factory.getIgoChessman(<span class="string">"b"</span>);  </span><br><span class="line">        black3 = factory.getIgoChessman(<span class="string">"b"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"判断两颗黑子是否相同："</span> + (black1==black2));  </span><br><span class="line">        <span class="comment">//通过享元工厂获取两颗白子  </span></span><br><span class="line">        white1 = factory.getIgoChessman(<span class="string">"w"</span>);  </span><br><span class="line">        white2 = factory.getIgoChessman(<span class="string">"w"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"判断两颗白子是否相同："</span> + (white1==white2));  </span><br><span class="line">        <span class="comment">//显示棋子，同时设置棋子的坐标位置  </span></span><br><span class="line">        black1.display(<span class="keyword">new</span> Coordinates(<span class="number">1</span>,<span class="number">2</span>));  </span><br><span class="line">        black2.display(<span class="keyword">new</span> Coordinates(<span class="number">3</span>,<span class="number">4</span>));  </span><br><span class="line">        black3.display(<span class="keyword">new</span> Coordinates(<span class="number">1</span>,<span class="number">3</span>));  </span><br><span class="line">        white1.display(<span class="keyword">new</span> Coordinates(<span class="number">2</span>,<span class="number">5</span>));  </span><br><span class="line">        white2.display(<span class="keyword">new</span> Coordinates(<span class="number">2</span>,<span class="number">4</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">判断两颗黑子是否相同：<span class="keyword">true</span></span><br><span class="line">判断两颗白子是否相同：<span class="keyword">true</span></span><br><span class="line">棋子颜色：黑色，棋子位置：<span class="number">1</span>，<span class="number">2</span></span><br><span class="line">棋子颜色：黑色，棋子位置：<span class="number">3</span>，<span class="number">4</span></span><br><span class="line">棋子颜色：黑色，棋子位置：<span class="number">1</span>，<span class="number">3</span></span><br><span class="line">棋子颜色：白色，棋子位置：<span class="number">2</span>，<span class="number">5</span></span><br><span class="line">棋子颜色：白色，棋子位置：<span class="number">2</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="3-复合享元模式"><a href="#3-复合享元模式" class="headerlink" title="3. 复合享元模式"></a>3. 复合享元模式</h2><p>　　在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p><p>　　复合享元角色所涉及到的角色如下：</p><p>　　●　　<strong>抽象享元(Flyweight)角色 ：</strong>给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p><p>　　●　　<strong>具体享元(ConcreteFlyweight)角色：</strong>实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p><p>　　<strong>●　  复合享元(ConcreteCompositeFlyweight)角色</strong> ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。</p><p>　　<strong>●　  享元工厂(FlyweightFactory)角色</strong> ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象享元角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个示意性方法，参数state是外部状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Character intrinsicState = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，内部状态作为参数传入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(Character state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsicState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部状态作为参数传入方法中，改变方法的行为，</span></span><br><span class="line"><span class="comment">     * 但是并不改变对象的内部状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Intrinsic State = "</span> + <span class="keyword">this</span>.intrinsicState);</span><br><span class="line">        System.out.println(<span class="string">"Extrinsic State = "</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复合享元角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompositeFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character,Flyweight&gt; files = <span class="keyword">new</span> HashMap&lt;Character,Flyweight&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个新的单纯享元对象到聚集中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Character key , Flyweight fly)</span></span>&#123;</span><br><span class="line">        files.put(key,fly);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部状态作为参数传入到方法中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        Flyweight fly = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Object o : files.keySet())&#123;</span><br><span class="line">            fly = files.get(o);</span><br><span class="line">            fly.operation(state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character,Flyweight&gt; files = <span class="keyword">new</span> HashMap&lt;Character,Flyweight&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复合享元工厂方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">factory</span><span class="params">(List&lt;Character&gt; compositeState)</span></span>&#123;</span><br><span class="line">        ConcreteCompositeFlyweight compositeFly = <span class="keyword">new</span> ConcreteCompositeFlyweight();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Character state : compositeState)&#123;</span><br><span class="line">            compositeFly.add(state,<span class="keyword">this</span>.factory(state));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compositeFly;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单纯享元工厂方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">factory</span><span class="params">(Character state)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先从缓存中查找对象</span></span><br><span class="line">        Flyweight fly = files.get(state);</span><br><span class="line">        <span class="keyword">if</span>(fly == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果对象不存在则创建一个新的Flyweight对象</span></span><br><span class="line">            fly = <span class="keyword">new</span> ConcreteFlyweight(state);</span><br><span class="line">            <span class="comment">//把这个新的Flyweight对象添加到缓存中</span></span><br><span class="line">            files.put(state, fly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Character&gt; compositeState = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">        compositeState.add(<span class="string">'a'</span>);</span><br><span class="line">        compositeState.add(<span class="string">'b'</span>);</span><br><span class="line">        compositeState.add(<span class="string">'c'</span>);</span><br><span class="line">        compositeState.add(<span class="string">'a'</span>);</span><br><span class="line">        compositeState.add(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">        FlyweightFactory flyFactory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight compositeFly1 = flyFactory.factory(compositeState);</span><br><span class="line">        Flyweight compositeFly2 = flyFactory.factory(compositeState);</span><br><span class="line">        compositeFly1.operation(<span class="string">"Composite Call"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"复合享元模式是否可以共享对象："</span> + (compositeFly1 == compositeFly2));</span><br><span class="line"></span><br><span class="line">        Character state = <span class="string">'a'</span>;</span><br><span class="line">        Flyweight fly1 = flyFactory.factory(state);</span><br><span class="line">        Flyweight fly2 = flyFactory.factory(state);</span><br><span class="line">        System.out.println(<span class="string">"单纯享元模式是否可以共享对象："</span> + (fly1 == fly2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><strong>优点：</strong></p><p>节约系统的开销，可以少创建对象。<br>外部状态不会影响内部状态，可以在不同环境下进行共享哦。<br><strong>缺点：</strong></p><p>享元模式使逻辑变得更加复杂，需要将享元对象分出内部状态和外部状态。</p><p>并且为了使对象可以共享，外部状态在很多情况下是必须有的，当读取外部状态时明显会增加运行时间。</p><p><strong>享元模式使用的场景：</strong></p><p>当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。</p><p><strong>与单例模式的区别：</strong></p><p>享元模式的目的是共享，避免多次创建耗费资源，减少不会要额内存消耗 。</p><p>单例模式的目的是限制创建多个对象以避免冲突等 。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p><code>http://blog.csdn.net/lovelion&gt;</code></p><p><code>https://blog.csdn.net/Hmily_hui/article/details/80917975</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java23种设计模式中的享元模式，并结合实例描述了享元模式的具体实现，具体优缺点和单例模式的对比。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（八）--外观模式</title>
    <link href="https://www.lixueduan.com/posts/22a51705.html"/>
    <id>https://www.lixueduan.com/posts/22a51705.html</id>
    <published>2018-10-20T14:00:00.000Z</published>
    <updated>2019-01-05T13:50:03.144Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java23种设计模式中的 模式，并结合实例描述了 模式的具体实现和性能分析测试。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-外观模式介绍"><a href="#1-外观模式介绍" class="headerlink" title="1. 外观模式介绍"></a>1. 外观模式介绍</h2><blockquote><p>它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。</p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/design_pattern/seven-proxy.png" alt=""></p><p>外观模式结构：</p><p>SubSystem: 子系统角色。表示一个系统的子系统或模块。</p><p>Facade: 外观角色，客户端通过操作外观角色从而达到控制子系统角色的目的。对于客户端来说，外观角色好比一道屏障，对客户端屏蔽了子系统的具体实现。</p><h2 id="2-外观模式实现"><a href="#2-外观模式实现" class="headerlink" title="2. 外观模式实现"></a>2. 外观模式实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子系统A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemA startUp"</span>);</span><br><span class="line">    &#125; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemA shutDown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemB startUp"</span>);</span><br><span class="line">    &#125; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemB shutDown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统C</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemC startUp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemC shutDown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystemA subSystemA;</span><br><span class="line">    <span class="keyword">private</span> SubSystemB subSystemB;</span><br><span class="line">    <span class="keyword">private</span> SubSystemC subSystemC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA = <span class="keyword">new</span> SubSystemA();</span><br><span class="line">        subSystemB = <span class="keyword">new</span> SubSystemB();</span><br><span class="line">        subSystemC = <span class="keyword">new</span> SubSystemC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA.startUp();</span><br><span class="line">        subSystemB.startUp();</span><br><span class="line">        subSystemC.startUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA.shutDown();</span><br><span class="line">        subSystemB.shutDown();</span><br><span class="line">        subSystemC.shutDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">            facade.startUp();</span><br><span class="line">            facade.shutDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    SubSystemA startUp</span><br><span class="line">    SubSystemB startUp</span><br><span class="line">    SubSystemC startUp</span><br><span class="line">    SubSystemA shutDown</span><br><span class="line">    SubSystemB shutDown</span><br><span class="line">    SubSystemC shutDown</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>外观模式的优点</strong></p><p>外观模式有如下几个优点：</p><p>1、松散耦合</p><p>外观模式松散了客户端和子系统的耦合关系，让子系统内部的模块能更容易扩展和维护</p><p>2、简单易用</p><p>客户端不需要了解系统内部的实现，也不需要和众多子系统内部的模块交互，只需要和外观类交互就可以了</p><p>3、更好地划分层次</p><p>通过合理使用Facade，可以帮助我们更好地划分层次。有些方法是系统对内的，有些方法是对外的，把需要暴露给外部的功能集中到Facade中，这样既方便客户端使用，也很好地隐藏了内部的细节</p><p><strong>外观模式在Java中的应用</strong></p><p>Tomcat中有很多场景都使用到了外观模式，因为Tomcat中有很多不同的组件，每个组件需要相互通信，但又不能将自己内部数据过多地暴露给其他组件。用外观模式隔离数据是个很好的方法，比如Request上使用外观模式。</p><p>比如Servlet，doGet和doPost方法，参数类型是接口HttpServletRequest和接口HttpServletResponse，那么Tomcat中传递过来的真实类型到底是什么呢？</p><p>在真正调用Servlet前，会经过很多Tomcat方法，传递给Tomcat的request和response的真正类型是一个Facade类。</p><p>因为Request类中很多方法都是组件内部之间交互用的，比如setComet、setReuqestedSessionId等方法，这些方法并不对外公开，但又必须设置为public，因为还要和内部组件交互使用。最好的解决方法就是通过使用一个Facade类，屏蔽掉内部组件之间交互的方法，只提供外部程序要使用的方法。</p><p>如果不使用Facade，直接传递的是HttpServletRequest和HttpServletResponse，那么熟悉容器内部运作的开发者可以分别把ServletRequest和ServletResponse向下转型为HttpServletRequest和HttpServletResponse，这样就有安全性的问题了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>https://www.cnblogs.com/xrq730/p/4908822.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java23种设计模式中的 模式，并结合实例描述了 模式的具体实现和性能分析测试。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（七）--代理模式</title>
    <link href="https://www.lixueduan.com/posts/ae2a93bd.html"/>
    <id>https://www.lixueduan.com/posts/ae2a93bd.html</id>
    <published>2018-10-19T14:00:00.000Z</published>
    <updated>2019-01-05T13:53:03.379Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Java23种设计模式中的代理模式，并结合实例描述了各种代理模式的具体实现和对比。包括：<code>JDK静态代理</code>，<code>JDK动态代理</code>，<code>cglib动态代理</code>.</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-代理模式介绍"><a href="#1-代理模式介绍" class="headerlink" title="1. 代理模式介绍"></a>1. 代理模式介绍</h2><blockquote><p><strong>给某一对象提供一个代理对象，并由代理对象控制对原对象的引用</strong>。</p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/design_pattern/seven-proxy.png" alt=""></p><p><strong>代理模式的结构</strong></p><p>有些情况下，一个客户不想或者不能够直接引用一个对象，可以通过代理对象在客户端和目标对象之间起到中介作用。代理模式中的角色有：</p><p>1、抽象对象角色</p><p>声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象</p><p>2、目标对象角色</p><p>定义了代理对象所代表的目标对象</p><p>3、代理对象角色</p><p>代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象</p><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</span><br><span class="line"></span><br><span class="line">代理类和被代理类必须实现同一个接口</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类和被代理类需要实现的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生 被代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造方法赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在执行代理方法前后可以执行其他的方法 代理模式的一个很大的优点</span></span><br><span class="line">        System.out.println(<span class="string">"Before"</span>);</span><br><span class="line">        <span class="comment">//在代理类的方法中 间接访问被代理对象的方法</span></span><br><span class="line">        person.sayHello(str);</span><br><span class="line">        System.out.println(<span class="string">"After"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//测试代码</span></span><br><span class="line">            <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//被代理的对象</span></span><br><span class="line">                    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">                    <span class="comment">//将被代理对象传递给代理对象</span></span><br><span class="line">                    PersonProxy personProxy = <span class="keyword">new</span> PersonProxy(student);</span><br><span class="line">                    <span class="comment">//代理对象调用方法</span></span><br><span class="line">                    personProxy.sayHello(<span class="string">"hello proxy"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//输出结果</span></span><br><span class="line">            Before</span><br><span class="line">            hello proxy</span><br><span class="line">            After</span><br></pre></td></tr></table></figure><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><blockquote><p>代理类在程序运行时创建的代理方式被成为动态代理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"><span class="comment">//引入被增强类的实例</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span> <span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao=userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDao <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UserDao userDaoProxy=(Demo.UserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(),</span><br><span class="line">userDao.getClass().getInterfaces(), <span class="keyword">this</span>);<span class="comment">//直接用当前类实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">return</span> userDaoProxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////调用被代理对象的任何方法都相当于在调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"想要增强的方法"</span>.equals(method.getName())) &#123;<span class="comment">//判断是不是想要增强的方法</span></span><br><span class="line"><span class="comment">//是想增强的方法 则对方法进行增强</span></span><br><span class="line">System.out.println(<span class="string">"before"</span>);</span><br><span class="line">method.invoke(UserDao, args);</span><br><span class="line">System.out.println(<span class="string">"after"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通方法就正常执行</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(UserDao, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较重要的两个地方 </span></span><br><span class="line"><span class="number">1</span>..InvocationHandler</span><br><span class="line">InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line">InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。</span><br><span class="line"><span class="comment">//对代理对象的增强就在这里进行 实现该接口 重写此方法 可以用匿名内部类或者直接用生成代理的那个类实现该接口</span></span><br><span class="line">-proxy 代理对象</span><br><span class="line">-method 代理对象调用的方法</span><br><span class="line">-args 调用的方法中的参数</span><br><span class="line">因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。</span><br><span class="line">需要创建一个类实现InvocationHandler接口</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span>..生成代理对象</span><br><span class="line">    Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler);</span><br><span class="line">第三个参数就要用到InvocationHandler接口的实现类</span><br><span class="line"><span class="comment">//参数1  类加载器  增强哪个对象就写哪个类的类加载器 myCar.getClass().getClassLoader();</span></span><br><span class="line"><span class="comment">//告诉虚拟机用哪个字节码加载器加载内存中创建出来的字节码文件 一般是application类加载器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数2 字节码数组 被代理类实现的所有接口的字节码数组 </span></span><br><span class="line"><span class="comment">//   告诉虚拟机内存中正在你被创建的字节码文件中应该有哪些方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数3 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上  、</span></span><br><span class="line"><span class="comment">//  告诉虚拟机字节码上的那些方法如何处理 （用户自定义增强操作等 写在实现InvocationHandler接口的那个类中）</span></span><br></pre></td></tr></table></figure><p>同样是上边的Person接口 和Student被代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">           <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicTest</span> </span>&#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">               Student studentB = <span class="keyword">new</span> Student();</span><br><span class="line">               <span class="comment">//获取被代理对实现的所有接口的字节码</span></span><br><span class="line">               Class[] interfaces = Student.class.getInterfaces;</span><br><span class="line">               <span class="comment">//创建一个与代理对象相关联的InvocationHandler 将被代理对象传过去</span></span><br><span class="line">               DynamicInvocationHandler dynamicInvocationHandler = <span class="keyword">new</span> DynamicInvocationHandler(studentB);</span><br><span class="line"><span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">               ClassLoader classLoader = StudentB.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//生成代理对象 返回的时Object类型 只能强转为接口类型（Person） 不能强转为子类类型(Student)</span></span><br><span class="line">               Person person = (Person) Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler);<span class="comment">//这里需要创建一个类实现InvocationHandler接口 重写invoke方法</span></span><br><span class="line">               <span class="comment">//代理对象调用方法</span></span><br><span class="line">               person.sayHello(<span class="string">"hello Dynamic"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;            </span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">           Before</span><br><span class="line">           hello Dynamic</span><br><span class="line">           After</span><br></pre></td></tr></table></figure><p><strong>小结：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.通过 Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler);生成代理对象，</span><br><span class="line"><span class="number">2</span>.创建InvocationHandler接口实现类 重写invoke方法 实现具体的方法增强</span><br><span class="line"><span class="number">3</span>.调用对象的方法最后都是调用InvocationHandler接口的invoke方法</span><br><span class="line"><span class="number">4</span>.只能增强接口中有的方法</span><br></pre></td></tr></table></figure><h2 id="4-CGLIB动态代理"><a href="#4-CGLIB动态代理" class="headerlink" title="4. CGLIB动态代理"></a>4. CGLIB动态代理</h2><blockquote><p>JDK代理要求被代理的类必须实现接口，有很强的局限性。</p><p>而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。</p><p>cglib原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。由于是通过子类来代理父类，因此不能代理被final字段修饰的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"><span class="comment">//引入被增强类的实例</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span> <span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao=userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDao <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.创建Cglib的核心类对象</span></span><br><span class="line">Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line"><span class="comment">//2.设置父类 Cglib采用继承方式实现代理  所以需要设置父类</span></span><br><span class="line">enhancer.setSuperclass(userDao.getClass());</span><br><span class="line"><span class="comment">//3.设置回调(类似于invocationhandler)</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">//还是直接用当前类去实现MethodInterceptor接口 </span></span><br><span class="line"><span class="comment">//4.创建代理对象</span></span><br><span class="line">UserDao proxy = (UserDao) enhancer.create();</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似于JDK动态代理的invoke方法 在这里对方法实现增强</span></span><br><span class="line"><span class="comment">//调用被代理对象的任何方法都相当于在调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object Proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"save"</span>.equals(method.getName())) &#123;<span class="comment">//判断是不是想要增强的方法</span></span><br><span class="line"><span class="comment">//是想增强的方法 则对方法进行增强</span></span><br><span class="line">System.out.println(<span class="string">"before"</span>);</span><br><span class="line">methodProxy.invoke(Proxy, args);</span><br><span class="line">System.out.println(<span class="string">"after"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> methodProxy.invoke(Proxy, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-代理模式比较"><a href="#5-代理模式比较" class="headerlink" title="5. 代理模式比较"></a>5. 代理模式比较</h2><table><thead><tr><th>代理方式</th><th>实现</th><th>优点</th><th>缺点</th><th>特点</th></tr></thead><tbody><tr><td>JDK静态代理</td><td>代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td><td>实现简单，容易理解</td><td>代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td><td>好像没啥特点</td></tr><tr><td>JDK动态代理</td><td>代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td><td>不需要硬编码接口，代码复用率高</td><td>只能够代理实现了接口的委托类</td><td>底层使用反射机制进行方法的调用</td></tr><tr><td>CGLIB动态代理</td><td>代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理</td><td>可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td><td>不能对final类以及final方法进行代理</td><td>底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td></tr></tbody></table><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><p><code>https://www.cnblogs.com/xrq730/p/4907999.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了Java23种设计模式中的代理模式，并结合实例描述了各种代理模式的具体实现和对比。包括：&lt;code&gt;JDK静态代理&lt;/code&gt;，&lt;code&gt;JDK动态代理&lt;/code&gt;，&lt;code&gt;cglib动态代理&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
