<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[配置linux的网络]]></title>
    <url>%2Fposts%2Fb0d13a6d.html</url>
    <content type="text"><![CDATA[本章主要讲了linux如何配置网络，让虚拟机能够连上外网，如何让虚拟机和主机联通，同时介绍了ssh客户端工具连接虚拟机。 点击阅读更多系列文章我的个人博客–&gt;幻境云图 1. Xshell在安装好虚拟机后就可以正常使用了。但是在正常工作中不可能真的在服务器上操作，一般都是通过ssh客户端工具连接服务器进行操作。 这里用到的客户端工具是Xshell,通过该工具连上服务器后就可以在自己的电脑上操作了。而且还可以开多个窗口，比较方便。 这里新建连接时需要输入要连接的服务器的IP和端口号，账户和密码，端口号默认是22，一般不用改。 2. 网络配置2.1 桥接模式和NAT模式按照上面的方法就可以连上虚拟机了，但是现在虚拟机的IP是自动获取的，每次重启后都IP都会变，这肯定不行呀，所以我们需要为虚拟机设置静态IP. 由于我们这里使用的是NAT模式。这个模式下虚拟机可以上网，但是无法和主机联通。 桥接模式和NAT模式的区别： 桥接模式下虚拟机可以看做一台真正的独立的电脑，所以桥接模式下需要为虚拟机分配独立的IP，在家里到时无所谓，在公司的话由于IP和电脑绑定的，所以需要网络管理人员给你的虚拟机分配一个IP才行。 NAT模式下，虚拟机会动态获取IP,虽然有自己的IP但是最终上网还是通过主机上网的。所以NAT模式下不用分配独立的IP,但是NAT模式下主机和虚拟机无法联通。 为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。 为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。 为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。 2.2 设置静态IP在设置静态IP前我们需要知道主机的IP. windows下命令行输入 ipconfig 即可获取到本机IP. 然后通过VMware软件对网络进行配置。 接着在虚拟机中配置具体网络信息。 2.3 网络配置2.3.1 配置文件网络配置文件在/etc/sysconfig/network-scripts/ifcfg-ens33目录下，一般是叫ifcfg-ens33 编辑配置文件 命令：vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置如下 ： 其中ip地址必须和主机在同一网段下，网关就是上边的那个网关。DNS可填可不填。 1234567BOOTPROTO="static" # 手动分配ipONBOOT="yes" # 该网卡是否随网络服务启动IPADDR="192.168.1.111" # 该网卡ip地址就是你要配置的固定IPGATEWAY="192.168.1.2" # 网关NETMASK="255.255.255.0" # 子网掩码 固定值DNS1="8.8.8.8" # DNS，8.8.8.8为Google提供的免费DNS服务器的IP地址DNS2="192.168.1.2" 2.3.2 配置网络工作命令：vi /etc/sysconfig/network 内容：NETWORKING=yes # 网络是否工作，此处一定不能为no 2.3.3 配置公共DNS服务vi /etc/resolv.conf 12nameserver 8.8.8.8nameserver 192.168.1.2 2.3.4 关闭防火墙12systemctl stop firewalld # 临时关闭防火墙systemctl disable firewalld # 禁止开机启动 2.3.5 重启网络服务service network restart 到此为止网络配置就完成了，现在虚拟机的IP重启后不会变了，也可以连上外网了，还可以和主机联通了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超详细的CentOS7安装教程]]></title>
    <url>%2Fposts%2F4d7cca6f.html</url>
    <content type="text"><![CDATA[这是一个十分详细的CentOS7的安装教程，对自己的安装过程做了一个记录。主要记录了如何通过VMware虚拟机安装Linux，从软件下载到虚拟机安装等等。 点击阅读更多Linux入门系列文章我的个人博客–&gt;幻境云图 1. 准备工作1.1 VMware下载百度网盘下载（内含注册机） 链接: https://pan.baidu.com/s/1wz4hdNQBikTvyUMNokSVYg提取码: yed7 怎么安装就不用写了吧。 1.2 CentOS下载http://mirrors.163.com/centos/7.6.1810/isos/x86_64/ 2. CentOS 7安装 创建虚拟机，这里我们选择自定义安装类型。 然后选择版本，需要注意兼容问题，一般是向下兼容，14上的虚拟机复制到15上可以用，15的复制到14上可能会用不了。 这里选择稍后再安装。 接着选择系统，这里是CentOS 7 64位。 这个是保存的文件名字。 这里一般默认的就行了,电脑配置好的可以调高点。 网络这里,如果仅仅是让虚拟机能上网，两种模式都可以的，用桥接的话只要你在局域网内有合法的地址，比如你的ADSL猫是带路由功能的，如果是在单位，那就要网络管理人员给你合法IP才行。NAT模式下，虚拟机从属于主机，也就是访问外部网络必须通过主机来访问，因此虚拟机的IP只有主机才能识别。而桥接模式下，虚拟机和主机是平行关系，共享一张网卡（使用网卡的多个接口），可以直接访问外部网络。 这些都默认的就行了。 这个是虚拟机文件的名字。 这里选择自定义硬件。 选择镜像文件。 到这里就结束了，点击开启虚拟机后会自动开始安装。 选择安装CentOS 7 语言选择 调一下时间和地区。 选择要安装的软件，新手还是安装一个GUI比较好。 查看一下网络连接 开始安装。 安装过程中可以设置一下账号密码，一个root账户，一个普通账户。 然后耐心等待安装完成就好了。 安装完成后重启就可以登录系统了。 3. 快照快照相当于windows中的还原点。在安装好后可以拍摄一张快照，方便恢复或者克隆虚拟机。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronize和Volatile底层实现原理]]></title>
    <url>%2Fposts%2Fcf1a701a.html</url>
    <content type="text"><![CDATA[最近在看并发编程的艺术这本书，希望加深对并发这块的理解。毕竟并发相关还是十分重要的。本文主要是关于第二章Java并发机制的底层实现原理的相关笔记。主要包括volatile,synchronized,原子操作等实现原理的分析。 点击阅读更多系列文章我的个人博客–&gt;幻境云图 1. 上下文切换多线程 即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。 什么是上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。 所以任务从保存到再加载的过程就是一次上下文切换。 上下文切换也会影响多线程的执行速度 因为线程有创建和上下文切换的开销，所以有时候并发不一定比串行快。 减少上下文切换的办法 减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。 CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。 2. volatile关键字如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。 有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，其中就包括了Lock前缀.Lock前缀的指令在多核处理器下会引发了两件事情。 1）将当前处理器缓存行的数据写回到系统内存。 Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。 如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。 2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。 3. synchronized原理与应用Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。 Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象。当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 3.1 底层实现JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。 代码块同步是使用monitorenter和monitorexit指令实现的. 而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。 monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。 3.2 Java对象头synchronized用的锁是存在Java对象头里的。 java的对象头由以下三部分组成： 1，Mark Word 2，指向类的指针 3，数组长度（只有数组对象才有） 3.3 锁的升级与对比Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。 偏向锁 HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁解除 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程. 轻量级锁 （1）轻量级锁加锁线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。（2）轻量级锁解锁轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 优缺点比较 4. 原子操作的实现原理原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。 4.1 处理器如何实现原子操作处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 第一个机制是通过总线锁保证原子性。 所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 第二个机制是通过缓存锁定来保证原子性。 总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。 所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效. 4.2 Java如何实现原子操作使用循环CAS实现原子操作 JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。 CAS实现原子操作的三大问题 1.ABA问题 但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。 ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。 2.循环时间长开销大 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 3.只能保证一个共享变量的原子操作 操作多个共享变量时无法使用CAS操作，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。 使用锁机制实现原子操作 锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。 参考本文内容来自Java并发编程的艺术]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客之迁移（四）]]></title>
    <url>%2Fposts%2F33469.html</url>
    <content type="text"><![CDATA[本章主要记录了如何通过使用Github的分支功能解决更换电脑后博客更新不方便的问题，让你的博客能在各个电脑上灵活切换。在也不用担心换电脑后博客配置丢失等问题了。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 点击阅读更多系列文章 到此为止，我们已经完成了差不多所有的步骤。 1.搭建博客 2.优化主题 3.部署收录 新问题： ​ 现在博客只能在自己的电脑上更新，如果换电脑了就很麻烦。配置文件主题什么的都要重新弄。所以网上找了找多台电脑同时操作的办法，我们可以利用Github的分支功能。 ​ 将博客文件夹下所有文件全push到Github。这样换电脑后直接pull就可以了。 1. 新建分支 1.在Github的lillusory.github.io（hexo仓库）上新建一个分支，例如Hexo，并切换到该分支. 2.并在该仓库Settings-&gt;Branches-&gt;Default branch中将默认分支设为Hexo.Hexo分支是博客的开发环境，用来写博客，保存原始文件,master分支用于显示，保存生产的静态文件。 3.新建分支后将博客目录下的所有文件上传到该分支，注意由于一个git仓库中不能包含其他仓库，所以需要删除掉主题文件夹中的.git目录。 4.如果按照前面的博文添加了背景，则需要删掉站点目录\themes\next\source\lib\canvas-nest文件夹中的.git目录。以后需要更新主题时，可以先克隆到本地在复制到相应目录. 2. 写博客在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m &quot;这里写备注&quot;、git push origin 这里写分支名字指令将改动推送到GitHub（此时当前分支应为hexo）。 然后才执行hexo g -d发布网站到master分支上。 3. 博客迁移当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 克隆仓库 使用git clone git@github.com:illusorycloud/illusorycloud.github.io.git拷贝仓库（默认分支为hexo）；//修改成自己的 安装插件 在前面克隆下的项目中安装插件 执行命令npm install hexo、npm install、npm install hexo-deployer-git 4. 参考如何在多台电脑上更新博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客之部署（三）]]></title>
    <url>%2Fposts%2F41257.html</url>
    <content type="text"><![CDATA[本章主要记录了如何将博客部署至云端，怎么设置个性域名，怎么将自己的网站提交到百度Google。让自己的网站能够出现在各大搜索引擎的具体方法和过程，希望能对大家有帮助。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 点击阅读更多系列文章 1. 购买个性域名估计大家折腾了这么久也就是为 了拥有一个自己的个性站点,所以强烈建议大家为自己的博客站点配置一个独一无二的个性域名.我这里选择阿里旗下的万网。我的域名是www.lixueduan.com 大家可以选择一个自己喜欢的域名。等部署完毕就可以通过域名访问自己的博客了。 问题： GithubPages/CodingPages Github Pages是Github免费提供给开发者的一款托管个人网站的产品。 Coding Pages也是Coding免费提供给开发者的一款托管个人网站的产品。 关于为什么要部署两次 虽然可以根据自定义域名来访问自己的博客了，但是百度谷歌上都搜索不到，那岂不是很难受╮(╯▽╰)╭。 所以接下来为了让自己的博客能够被搜索出来，就需要让百度谷歌收录我们的网站。在部署收录过程中发现，Github屏蔽了百度的爬虫，所以搭建上GithubPages的话无法提交至百度，只有Google可以收录。 所以为了让百度收录我们网站，就得在Coding上也搭建一个。 同时在搭建的过程中发现如果先搭建在Github上，然后再搭建Coding时会出现DNS解析冲突。所以需要：先搭建Coding上的，再搭建Github上的，国外的访问则走Github，国内的访问会走Coding，完美 2. 部署到CodingPages2.1 注册coding账户 点击这里注册Coding](https://coding.net/) 2.2 创建新项目 注册好后创建一个项目用来部署个人博客，项目路径和项目名称最好和用户名一致 2.3 开启CodingPages 点击Pages服务，然后一键开启。 部署master分支 自定义域名 可以填两个 www.xxx.com 和xxx.com 绑定自定义域名的时候需要在买域名的地方(我这里是阿里的万网)配置DNS解析 1234567添加两条CNAME解析主机记录 一个@，一个www//@就是无前缀，xxx.com, www就是www.xxx.com解析路线 默认就行记录值 lillusory.coding.me //这里改成自己的 然后可以开启Https访问。 到这里就可以通过个性域名访问啦。不过现在博客代码还没有push到项目里。 2.4 Push代码到Coding配置SSH key 首先需要配置一个SSHkey，Git有Http协议和Git协议两种。我们这里使用Git协议就需要配置一个SSH key,等会部署到Github上也需要配置这个。 具体配置方法如下： Git 配置及SSH key 修改站点配置文件 这里只配置了Coding，可以先把Github的注释掉 12345678# Deployment 部署到云端相关配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: github: git@github.com:illusorycloud/illusorycloud.github.io.git coding: git@git.coding.net:illusorycloud/illusorycloud.git branch: master 地址在这里： 配置好后，运行hexo g时就可以把博客部署到Coding上了，也可以通过个性域名访问了。 3. 收录到百度3.1 网站添加直接百度搜索你的域名,比如我的www.lixueduan.com ，如果没有收录就会提示暂未收录，点击提交网址。 点击这个链接进入百度站长平台，登录成功后选择`用户中心–&gt;站点管理–&gt;添加网站 输入自己的网站，如www.lixueduan.com 协议头如果开启了https就选https 3.2 网站验证然后会验证这个网站是不是你的，选CNAME验证 然后去域名哪里添加一条解析即可。 记录类型–&gt;CNAME 主机记录—&gt;前面那一串l3rUDBLOMX 记录值–&gt;后面那个ziyuan.baidu.com 其他的都按默认的就行了，添加后别删除，需要一直留着。 3.3 站点地图接下来我们需要生成网站地图sitemap,使用sitemap方式向百度提交我们的网址 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件 12npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 在站点配置文件中添加如下代码 12345678Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了. 然后将博客重新部署后就可以直接访问站点地图了。如https://www.lixueduan.com/baidusitemap.xml 然后将这个站点地图提交到百度 站点管理--&gt;站点属性--&gt;链接提交--&gt;自动提交--&gt;sitemap 完成后就算是提交成功了，百度比较慢，要好几天才能收录。 4. 部署到GitHub步骤和Coding差不多的。 4.1 注册Github账号点这里注册Github账号 4.2 创建新仓库也是名字必须和用户名一样，必须按照这个格式username.github.io，例如lillusorycloud.github.io 创建好仓库后找到Setings 往下拉，找到Github Pages 设置Custom domain填下自定义域名，如www.lixueduan.com.如果有Enforce HTTPS选项也可以勾上。 4.3 Push代码到Github配置SSH key 首先需要配置一个SSHkey，Git有Http协议和Git协议两种。我们这里使用Git协议就需要配置一个SSH key,等会部署到Github上也需要配置这个。 具体配置方法： Git 配置及SSH key 修改站点配置文件 repository中添加一个github 12345678# Deployment 部署到云端相关配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: github: git@github.com:illusorycloud/illusorycloud.github.io.git coding: git@git.coding.net:illusorycloud/illusorycloud.git branch: master 配置好后，运行hexo g时就可以把博客同时部署到Coding和Github上了，也可以通过个性域名访问了。 5. 收录到Google和百度差不多。 5.1 网站添加首先进入Google站点平台 然后添加资源，注意http和https 5.2 验证所有权然后验证所有权,选择DNS供应商 供应商选择其他，然后选择添加CNAME记录，在域名解析中添加一条记录。也是添加后不要删除。 5.3 站点地图验证后就可以添加站点地图了 提交成功后,我们的站点就已经被Google收录了.大概一天就能收录成功，比百度块一些。 6. 总结本文主要讲了怎么将博客部署到Coding和Github和怎么让百度,Google收录我们的网站。 7.参考Hexo官方文档 基于Hexo的个人博客 Hex博客搭建]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门系列（一）之HelloWorld]]></title>
    <url>%2Fposts%2F22f8f0ac.html</url>
    <content type="text"><![CDATA[本文主要介绍了SpringBoot是什么、怎么使用和为什么要用SpringBoot。使用Spring boot ，可以轻松的创建独立运行的程序，非常容易构建独立的服务组件，是实现分布式架构、微服务架构利器。Spring boot简化了第三方包的引用，通过提供的starter，简化了依赖包的配置。 1. SpringBoot介绍Spring boot的优点 轻松创建独立的Spring应用程序。 内嵌Tomcat、jetty等web容器，不需要部署WAR文件。 提供一系列的“starter” 来简化的Maven配置。 开箱即用，尽可能自动配置Spring。 2.创建SpringBoot项目如果使用的是IDEA则非常方便的创建SpringBoot项目，在新建项目的时候选择Spring initializr填写一些基本信息后就可以了。 Eclipse的话就需要去官网构建。 maven构建项目 1、访问http://start.spring.io/ 2、选择构建工具Maven Project、Spring Boot版本等一些工程基本信息 3、点击Generate Project下载项目压缩包 4、解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK！ 2. controller@SpringBootApplication SpringBoot启动类注解 3 hello12345678910@Controllerpublic class HelloController &#123; @RequestMapping("/gethello") @ResponseBody public Map&lt;String, Object&gt; getHello() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("msg", "hello"); return map; &#125;&#125; 3. 整合Servlet3.1 方式一 扫描注解注册Servlet1234567@WebServlet(name = "FirstServlet",urlPatterns = "/first")public class FirstServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; @WebServlet(name = “FirstServlet”,urlPatterns = “/first”) 相当于web.xml中的以下配置 12345678&lt;servlet&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.demo.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/firse&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; @ServletComponentScan 让SpringBoot在启动时扫描@WebServlet注解 123456789@SpringBootApplication@ServletComponentScanpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 3.2 方式二 通过方法注册Servlet该方式 创建servlet后不用任何注解，直接在启动器中注册servlet 12345678910111213@SpringBootApplicationpublic class app &#123; public static void main(String[] args) &#123; SpringApplication.run(app.class, args); &#125; @Bean public ServletRegistrationBean Register()&#123; ServletRegistrationBean bean=new ServletRegistrationBean(new FirstServlet()); bean.addUrlMappings("/first"); return bean; &#125;&#125; 4. 整合Filter4.1 方式一 扫描注解注册Filter123456789@WebFilter(filterName = &quot;firstFilter&quot;,urlPatterns =&quot;/first&quot;)public class FirstFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;进入Filter&quot;); filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;放行Filter&quot;); &#125;&#125; @WebFilter(filterName = “firstFilter”,urlPatterns =”/first”) 4.2 方式二 通过方法注册Servlet123456@Beanpublic FilterRegistrationBean RegisterFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean&lt;&gt;(new FirstFilter()); bean.addUrlPatterns(&quot;/first&quot;); return bean;&#125; 5. 整合Listener5.1 方式一 扫描注解注册Listener123456789101112@WebListenerpublic class FirstListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; &#125;&#125; @WebListener 5.2 方式二 通过方法注册Listener12345@Beanpublic ServletListenerRegistrationBean&lt;FirstListener&gt; registerListener() &#123; ServletListenerRegistrationBean&lt;FirstListener&gt; bean = new ServletListenerRegistrationBean&lt;&gt;(new FirstListener()); return bean;&#125; 6. 访问静态资源1.从classpath/static目录下（名称必须是static） 2.ServletContext根目录下 src/main/webapp(名称必须是webapp) 访问路径：localhost:8080/filename 7.文件上传页面123456&lt;body&gt;&lt;form action="fileuploadController" method="post" enctype="multipart/form-data"&gt; 上传文件&lt;input type="file" name="filename"&gt;&lt;br&gt; &lt;input type="submit" value="上传"&gt;&lt;/form&gt;&lt;/body&gt; controller123456789101112//@Controller@RestController //对方法返回值会自动做json格式转换 不用@responseBody了public class fileuploadController &#123; @RequestMapping("/fileuploadController") public Map&lt;String,Object&gt; fileUpload(MultipartFile filename) throws IOException &#123; System.out.println(filename.getOriginalFilename()); filename.transferTo(new File("e:/"+filename.getOriginalFilename())); Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put("msg","ok"); return map; &#125;&#125; 文件大小限制application.properties 12spring.servlet.multipart.max-request-size=200MBspring.servlet.multipart.max-file-size=200MB 8.总结8.1注解方式 Servlet @WebServlet(name = “FirstServlet”,urlPatterns = “/first”) Filter @WebFilter(filterName = “firstFilter”,urlPatterns =”/first”) Listener @WebListener 启动器 @ServletComponentScan 8.2 方法注册不用加注解 1234567891011121314151617181920//---------Servlet------------------ @Bean public ServletRegistrationBean Register()&#123; ServletRegistrationBean bean=new ServletRegistrationBean(new FirstServlet()); bean.addUrlMappings("/first"); return bean; &#125;//---------Filter------------------ @Beanpublic FilterRegistrationBean RegisterFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean&lt;&gt;(new FirstFilter()); bean.addUrlPatterns("/first"); return bean;&#125;//---------Linster------------------ @Beanpublic ServletListenerRegistrationBean&lt;FirstListener&gt; registerListener() &#123; ServletListenerRegistrationBean&lt;FirstListener&gt; bean = new ServletListenerRegistrationBean&lt;&gt;(new FirstListener()); return bean;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客之优化（二）]]></title>
    <url>%2Fposts%2F58273.html</url>
    <content type="text"><![CDATA[本章主要包含了博客主题优化相关内容，第三方服务和插件的配置与使用。如：炫酷头像动态背景、链接变色、鼠标点击效果、站点字数、访客数统计等。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 点击阅读更多系列文章 0. 选择主题你可以点击这里选择你喜欢的Themes,里面有大量美观的主题 我这里用的是简约著称的Next主题. 下载主题 使用git命令下载该主题到本地. git clone https://github.com/theme-next/hexo-theme-next themes/next clone成功后,你的Themes文件夹下就会有next主题文件了. Hexo配置文件: 都叫_config.yml 一份位于站点根目录下，主要包含 Hexo 本身的配置,称为 站点配置文件 另一份位于主题目录下主要用于配置主题相关的选项,称为主题配置文件 开启主题 站点配置文件进行修改: 将theme: landscape修改为 theme: next 1. 侧边栏头像设置新版next注意引入了该功能,直接在主题配置文件修改即可,如下: 123456789# Sidebar Avatar 头像avatar: url: /images/avatar.gif # 圆形头像 rounded: true # 透明度 0~1之间 opacity: 1 # 头像旋转 rotated: true 2. 设置个人社交图标链接直接在主题配置文件修改即可,如下: 123456789101112131415161718192021# Social Links. 社交链接 前面为链接地址 后面是图标 social: GitHub: https://github.com/illusorycloud || github E-Mail: mailto:xueduan.li@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype# 图标配置 social_icons: #是否显示图标 enable: true #是否只显示图标 icons_only: false #是否开启图标变化(就是刷新后会变颜色) transition: false 3. 添加菜单项1.先在主题配置文件修改 12345678menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive AAAAA: /BBBBB/ || CCC其中AAA 为菜单项的名字,BBB是路径,CCC是菜单项显示的图标 next 使用的是 Font Awesome 提供的图标 ,在这里可以选择自己喜欢的图标. 2.生成上述路径的文件 git命令行输入 hexo new page BBB –其中BBB替换为具体的名字,会在站点目录\source下新增一个BBB文件夹,文件夹中有一个index.md文件，需要在文件头中增加一句type: XXX,例如type: categories。这样就会在这个页面显示所有的分类了。 3.修改主题文件下的对应语言的配置文件,这里是中文就修改zh-CN.yml 12345menu: home: 首页 archives: 归档 AAAA : XXXXAAA为上边的菜单项名字,XXX为中文的名字 4. 添加RSS 1.安装插件 首先在Git中运行npm install --save hexo-generator-feed命令,安装插件,插件会放在 node_modules文件夹里面. 2.修改站点配置文件 安装好插件后,打开站点配置文件_config.yml`,在末尾加入以下代码: 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 3.修改主题配置文件 打开主题配置文件_config.yml,找到rss 添加配置:rss: /atom.xml 5. 设置酷炫动态背景next主题提供了两种背景可以选择. 第一种背景（我是用的这种） 新版本的next主题的话直接在主题配置文件中,找到canvas-nest 修改为canvas-nest: true, 123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 进入theme/next目录 执行命令git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 第二种背景 12345678# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 也是需要下载依赖 进入theme/next目录 执行命令：git clone https://github.com/theme-next/theme-next-three source/lib/three 4个背景中只能开启一种背景,不然会出错 6. 设置网站logo把你的图片放在themes/next/source/images里 打开主题配置文件_config.yml ,找到字段favicon: 都修改为对应路径 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 7. 实现点击出现桃心效果themes/next/source/js/src里面 新建一个love.js, 复制下面的代码进去 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 然后打开\themes\next\layout\_layout.swig文件,在末尾 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 8. 修改文章内链接文本样式鼠标移动到连接上变颜色 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 9. 设置顶部滚动加载条打开next\layout\_partials\head文件，在文件末尾添加以下代码: 123456789101112131415&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 10. 在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout\_macro 中新建 page-end-tag.swig 文件,并添加以下内容： 123456&lt;!--文字可以自己修改--&gt;&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #A2CD5A;font-size:15px;"&gt;------------------本文到此结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读------------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加下面的代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'page-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记page_end_tag: enabled: true 11. 静态资源压缩Hexo自动生成的html中有很多空白的地方,会影响加载速度,所以最好还是压缩一下. 这里使用hexo-neat插件来压缩。 安装插件 npm install hexo-neat --save 在站点配置文件添加配置 1234567891011121314151617181920212223242526# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude: # 压缩css 跳过min.cssneat_css: enable: true exclude: - '**/*.min.css' # 压缩js 跳过min.jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' - '**/love.js'# 压缩博文配置结束 3.使用 以后再执行hexo g命令时就会自动压缩了 12. 主页文章添加阴影效果打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 13. 修改文章底部的的标签样式打开模板文件/themes/next/layout/_macro/post.swig，找到rel=&quot;tag&quot;&gt;#字段， 将# 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;,其中tag是你选择标签图标的名字,也是可以自定义的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 14. 实现文章字数统计和预计阅读时间1.在站点根目录下使用GitBash命令安装 hexo-wordcount插件: 1npm install hexo-symbols-count-time --save 2.在全局配置文件_config.yml中激活插件: 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 3.在主题的配置文件_config.yml中进行如下配置: 1234567#字数统计symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 4 wpm: 275 到此,我们就实现了文章字数统计和预估时间的显示功能 15. 在文章底部增加版权信息修改主题配置文件,找到creative_commons字段 12345678910# Creative Commons 4.0 International License.# https://creativecommons.org/share-your-work/licensing-types-examples# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: #选择一个License license: by-nc-sa #是否在侧边栏显示 sidebar: false #是否在文章末尾显示 post: true 16. 文章置顶打开文件：node_modules/hexo-generator-index/lib/generator.js,将原来的代码用下面的代码替换掉 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 写文章的时候,在标题加上top值,数值越大排在越前面. 1234tag: hexo copyright: truepassword: xxxtop: 150 17. 在网站底部加上访问量Next主题配置这个就比较方便了 打开主题配置文件，找到如下配置： 12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 将enable的值由false改为true，便可以看到页脚出现访问量. 另外本地预览时访客数异常是正常的,部署至云端后就不会出现这样的问题. 18. 网站搜索功能1.安装插件 ​ 站点目录下执行命令npm install hexo-generator-searchdb --save 2.修改站点配置文件 12345search: path: search.xml field: post format: html limit: 10000 3.修改主题配置文件 1234567891011# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: enable # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 重新开启服务后即可看到效果。 TODO开启留言评论功能//TODO 待更新 参考Hexo官方文档 Next官方文档]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客之搭建（一）]]></title>
    <url>%2Fposts%2F18973.html</url>
    <content type="text"><![CDATA[本文主要记录了如何搭建自己的博客。基于Hexo框架在本地搭建自己博客的全过程，包括了环境准备到Hexo初始化，再到服务的开启等。 这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。 点击阅读更多系列文章 1. 环境准备 Git Git下载地址 Node.js Node.js下载地址 小白式安装，一直下一步就ok了。 都安装好后就可以开始安装Hexo啦. 2. 安装Hexo 1.新建一个文件夹,用于安装Hexo,以后这个就是放博客文件的. 2.在此文件夹右键,Git Bash Here,打开Git 3.安装Hexo 命令npm install -g hexo 4.初始化Hexo 命令hexo init 5.安装组件 命令npm install 到此为止,Hexo就算是安装完成了。 3. 开启服务 1.hexo generate或者简写hexo g 编译,生成静态文件,就是生成一个个html文件. 2.开启服务hexo server或者hexo s 成功开启后就可以在本地访问了。 http://localhost:4000 假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，hexo server -p 端口号来改变端口号 如hexo server -p 5000 将端口号换为5000,默认是4000 3.常用命令 hexo clean 清除缓存文件 hexo deploy或者hexo d 部署网站到云端,这个后面再讲。 参考Hexo官方文档]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(五)--从输入URL到页面加载的过程中发生了什么]]></title>
    <url>%2Fposts%2F5863.html</url>
    <content type="text"><![CDATA[本文主要对用户从浏览器输入URL到页面加载的这一过程进行了具体分析与叙述。包括：DNS解析、发送HTTP请求、TCP连接、服务器响应、浏览器解析渲染页面等。 计算机网络系列文章 计算机网络(一)–OSI七层模型 计算机网络(二)–TCP三次握手四次挥手 计算机网络(三)–TCP如何保证传输可靠性 计算机网络(四)–HTTP与HTTPS 计算机网络(五)–从输入URL到页面加载的过程中发生了什么–从输入URL到页面加载的过程中发生了什么) 总体来说分为以下几个过程: 1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面 6.连接结束 1. DNS解析解析域名，找到主机IP。如百度对应的IP为180.97.33.108 ,浏览器输入IP也可以访问到百度。 （1）浏览器会缓存DNS一段时间，一般2-30分钟不等。如果有缓存，直接返回IP，否则下一步。 （2）缓存中无法找到IP，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回IP，否则下一步。（在计算机本地目录etc下有一个hosts文件，hosts文件中保存有域名与IP的对应解析，通常也可以修改hosts科学上网或破解软件。） （3）进行了（1）（2）本地查询无果，只能借助于网络。路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这时一般都能够得到相应的IP。如果还是无果，只能借助于DNS递归解析了。 （4）这时，ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com顶级域名服务器，到baidu的域名服务器。 到这里，浏览器就获得了IP。在DNS解析过程中，常常会解析出不同的IP。比如，电信的是一个IP，网通的是另一个IP。这是采取了智能DNS的结果，降低运营商间访问延时，在多个运营商设置主机房，就近访问主机。电信用户返回电信主机IP，网通用户返回网通主机IP。当然，劫持DNS，也可以屏蔽掉一部分网点的访问，某防火长城也加入了这一特性。 2. TCP连接浏览器与网站建立TCP连接 浏览器利用IP直接与网站主机通信。浏览器发出TCP（SYN标志位为1）连接请求，主机返回TCP（SYN，ACK标志位均为1）应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认。浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP链接建立完成。 3. 发送HTTP请求浏览器发起HTTP请求 其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 请求行 请求行包括：请求方法，URL ， 协议版本 12请求行：请求方法 URL 协议版本 eg: GET index.html HTTP/1.1 请求报头 请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。常见的请求报头有: Accept,Accept-Charset,Accept-Encoding,Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 请求正文 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json 浏览器向主机发起一个HTTP请求。请求中包含访问的URL，也就是http://www.baidu.com/ ，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。 4. 服务器响应服务器对请求做出响应并返回HTTP响应报文。自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，例如Tomcat。 HTTP响应报文也是由三部分组成: 响应行, 响应报头和响应报文。 响应行 响应行包括：协议版本 状态码 状态码描述 12响应行包括：协议版本 状态码 状态码描述 eg: HTTP/1.1 200 OK 响应报头 常见的响应报头字段有: Server, Connection…。 响应报文 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 5. 浏览器解析渲染页面返回状态码200 OK，表示服务器可以相应请求，返回报文，由于在报头中Content-type:“text/html”，浏览器以HTML形式呈现，而不是下载文件。 浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的? 浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 重定向 负载均衡 但是，对于大型网站存在多个主机站点，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200 OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。 补充一点的就是，重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于lixueduan.com，www.lixueduan.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。 6. 连接结束在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 7. 计算机网络常见问题看完系列文章，下面这些问题应该也不是问题了。 1.TCP三次握手和四次挥手 2.在浏览器中输入url地址-&gt;&gt;显示主页的过程 3.HTTP和HTTPS的区别 4.TCP、UDP协议的区别 5.常见的状态码。 8. 参考https://segmentfault.com/a/1190000006879700]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(四)--HTTP与HTTPS]]></title>
    <url>%2Fposts%2F21307.html</url>
    <content type="text"><![CDATA[本文主要介绍了HTTP、HTTPS的基本概念及两者的区别，HTTPS的工作原理及优缺点，最后介绍了HTTP的响应状态码。 计算机网络系列文章 计算机网络(一)–OSI七层模型 计算机网络(二)–TCP三次握手四次挥手 计算机网络(三)–TCP如何保证传输可靠性 计算机网络(四)–HTTP与HTTPS 计算机网络(五)–从输入URL到页面加载的过程中发生了什么–从输入URL到页面加载的过程中发生了什么) 1. HTTP和HTTPS基本概念 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 12HTTP--&gt; HTTP--&gt;TCP--&gt;IPHTTPS-&gt; HTTP--&gt;SSL--&gt;TCP--&gt;IP HTTPS协议的主要作用：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 2. HTTP与HTTPS的区别 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。 HTTPS和HTTP的区别: 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 3. HTTPS工作原理 我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 SSL协议的握手过程 分为五个步骤: 第一步，客户端给出SSL协议版本号、一个客户端生成的随机数1（Client random），以及客户端支持的加密方法。 第二步，服务端根据客服端支持的加密方法选出双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数2（Server random）。 第三步，客户端确认数字证书有效，然后生成一个新的随机数3（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。 第四步，服务端使用自己的私钥，获取客户端发来的随机数3（即Premaster secret）。到这里双方都拥有三个随机数了，为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。 第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。 第六步，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。 第七步，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。 4. HTTPS的优缺点 优点: （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 （4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高” 缺点: （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 5. HTTP响应状态码状态码以3位数字和原因短语组成，例如 200 OK 。 数字的第一位指定了响应类型，后两位无分类。响应类别一共有5种： 1XX Informational(信息性状态码) 2XX Success(成功状态码) 3XX Redirection(重定向状态码) 4XX Client Error(客户端错误状态码) 5XX Server Error(服务器错误状态码) 1234567891011121314151617181920212223200：请求成功 处理方式：获得响应的内容，进行处理 201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到 202：请求被接受，但处理尚未完成 处理方式：阻塞等待 204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL 304 请求的资源未更新 处理方式：丢弃 400 非法请求 处理方式：丢弃 401 未授权 处理方式：丢弃 403 禁止 处理方式：丢弃 404 没有找到 处理方式：丢弃 5XX 回应代码以“5”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求 处理方式：丢弃 6. HTTP长连接、短连接在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 https加密是在传输层 https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。 当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。 7. 参考https://www.cnblogs.com/qiangxia/p/5261813.html https://www.cnblogs.com/wqhwe/p/5407468.html http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(三)--TCP如何保证传输可靠性]]></title>
    <url>%2Fposts%2F18422.html</url>
    <content type="text"><![CDATA[本文主要叙述了TCP协议是如何保证传输的可靠性的，主要保证手段包括：序列号、校验和 、流量控制、拥塞控制、停止等待协议、超时重传、连接管理等。 计算机网络系列文章 计算机网络(一)–OSI七层模型 计算机网络(二)–TCP三次握手四次挥手 计算机网络(三)–TCP如何保证传输可靠性 计算机网络(四)–HTTP与HTTPS 计算机网络(五)–从输入URL到页面加载的过程中发生了什么–从输入URL到页面加载的过程中发生了什么) 1. 主要保证方式 序列号:应用数据被分割成 TCP 认为最适合发送的数据块,同时给每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 停止等待协议(确认应答) 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 连接管理: 三次握手四次挥手,保证可靠的连接，是保证可靠性的前提。 2. 停止等待协议 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组； 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认； 1) 无差错情况: 发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。 2) 出现差错情况（超时重传）: [ 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。 3) 确认丢失和确认迟到 确认丢失：当确认消息在传输过程丢失 A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施： 丢弃这个重复的M1消息，不向上层交付。 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。 确认迟到 ：确认消息在传输过程中迟到 [A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下： A收到重复的确认后，直接丢弃。 B收到重复的M1后，也直接丢弃重复的M1。 3. ARQ协议即自动重传请求 ARQ 协议(Automatic Repeat reQuest )，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。 优点： 简单 缺点： 信道利用率低 4. 连续ARQ协议连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。 优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。 缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。 5. 流量控制 滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。 TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。 TCP 利用滑动窗口实现流量控制的机制。 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 6. 拥塞控制防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降 拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 几种拥塞控制方法 ​ 慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 慢开始和拥塞避免 ​ 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。 ​ 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。 拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 快重传与快恢复 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。 7.参考https://blog.csdn.net/liuchenxia8/article/details/80428157 https://blog.csdn.net/yangbodong22011/article/details/48473183]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(二)--TCP三次握手四次挥手]]></title>
    <url>%2Fposts%2F25338.html</url>
    <content type="text"><![CDATA[本文主要介绍了TCP/IP的三次握手和四次挥手具体步骤及其原因分析。 计算机网络系列文章 计算机网络(一)–OSI七层模型 计算机网络(二)–TCP三次握手四次挥手 计算机网络(三)–TCP如何保证传输可靠性 计算机网络(四)–HTTP与HTTPS 计算机网络(五)–从输入URL到页面加载的过程中发生了什么–从输入URL到页面加载的过程中发生了什么) 1. 三次握手 step1:第一次握手建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。 step2:第二次握手服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RCVD状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。 step3:第三次握手 客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTABLISHED (TCP连接成功)**状态，完成三次握手。 123456建立连接前要确认客户端和服务端的接收和发送功能是否正常。第一次客户端发送SYN时 什么也确认不了第二次服务端发送SYN+ACK 可以确认服务端发送功能正常第三次 客户端收到服务端发送的YSN+ACK 可以确认客户端发送接收功能正常最后客户端发送ACK 服务端接收到后 可以确认服务端发送功能正常到此就确认完毕了。 2. 四次挥手 step1：第一次挥手首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。 客户端进入FIN_WAIT1状态 1我（Client端）没有数据要发给你（Server端）了&quot;，但是如果你（Server端）还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK step2：第二次挥手服务器收到这个FIN进入CLOSE_WAIT状态，然后它给客户端发送一个ACK，确认ack为收到的序号加一。 客户端收到ACK应答后进入FIN_WAIT2状态 1告诉Client端，你的请求我收到了，但是我（Server端）还没准备好，请继续你等我的消息&quot; step3：第三次挥手服务端关闭服务器到客户端的连接，发送一个FIN给客户端。服务端进入LAST_ACK状态 1告诉Client端，好了，我（Server端）这边数据发完了，准备好关闭连接了 step4：第四次挥手 客户端收到FIN后，进入TIME_WAIT状态 并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。 服务端收到客户端回复的ACK后立即关闭，服务端进入CLOASED状态 而客户端要等待2MSL后关闭 进入CLOASED状态 1Client端收到FIN报文后，&quot;就知道可以关闭连接了，所以发送ACK。但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后没有立即，而是进入TIME_WAIT状态，如果Server端没有收到ACK那么自己还可以重传。Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 3. TIME-WAIT状态详解为什么Client端要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？ 保证TCP协议的全双工连接能够可靠关闭，保证这次连接的重复数据段从网络中消失 假设由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，Client端在等待2MSL时间后都没收到信息，说明Server端已经收到自己发送的ACK并且成功关闭了。假设CLient端直接关闭了： 1231.由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。2.如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。 2MSL:Maximum Segment Lifetime 即数据在网络中保存的最大时间。 简单易懂的说法: 1假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 4. TCP 的有限状态机红色为客户端 蓝色为服务端 细箭头为异常变化 5. 参考https://www.baidu.com/link?url=_mlor11BLttd1jmMU4k9OP0gqcjNKhZQ9fJuvbMOhkuH9-lVeB-y3VIVK1neZURi_tmR3rg1lj2lfgvvGhTV-q&amp;wd=&amp;eqid=d0144c250007b69c000000035bfdfafc]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(一)--OSI七层模型]]></title>
    <url>%2Fposts%2F25470.html</url>
    <content type="text"><![CDATA[本文主要通过OSI七层模型与常用TCP/IP5层模型介绍了各层的主要作用，包括应用层，运输层，网络层，数据链路层，物理层等。 计算机网络系列文章 计算机网络(一)–OSI七层模型 计算机网络(二)–TCP三次握手四次挥手 计算机网络(三)–TCP如何保证传输可靠性 计算机网络(四)–HTTP与HTTPS 计算机网络(五)–从输入URL到页面加载的过程中发生了什么–从输入URL到页面加载的过程中发生了什么) OSI与TCP/IP模型 应用层:通过应用进程间的交互来完成特定网络应用。 运输层：向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。 网络层：通过路由算法，为报文或分组通过通信子网选择最适当的路径。 数据链路层：其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。 物理层：利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。 1. 应用层主要作用:通过应用进程间的交互来完成特定网络应用。 应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。 2. 运输层 主要任务：向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。 主要作用：向高层屏蔽下层数据通信的具体细节，即向用户透明的传送报文。 主要用到的协议： 传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 2.1 UDP UDP 是无连接的； UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP 是面向报文的； UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）； UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 2.2 TCP TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 3. 网络层主要任务：通过路由算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与物理层之间的信息转发，建立、维持与终止网络的连接。具体的说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。 一般的，数据链路层是解决统一网络内节点之间的通信，而网络层主要解决不同子网之间的通信。例如路由选择问题。 在实现网络层功能时，需要解决的主要问题如下： 寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一 个唯一的地址。由于各个子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址） 交换：规定不同的交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者包括报文转发技术和分组转发技术。路由算法：当源节点和路由节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径，由发送端传送的接受端。连接服务：与数据链路层的流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测 4. 数据链路层其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。 主要功能：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 具体工作：接受来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上一层的数据帧，拆装为位流形式的数据转发到物理层；并且还负责处理接受端发回的确认帧的信息，以便提供可靠的数据传输。 该层通常又被分为 介质访问控制(MAC)和逻辑链路控制(LLC)两个子层： MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制。LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。 5. 物理层主要功能：利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。 作用：实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质与物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。 透明传输的意义就是：不管传的是什么，所采用的设备只是起一个通道作用，把要传输的内容完好的传到对方！ 在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。 6. 参考https://blog.csdn.net/yaopeng_2005/article/details/7064869]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（十二）--观察者模式]]></title>
    <url>%2Fposts%2F48bcf013.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的观察者模式，并结合实例描述了观察者模式的具体实现和优缺点分析。 设计模式系列文章 Java23种设计模式 1. 观察者模式介绍 让多个观察者对象同时监听某一个主题对象，这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。 该模式包含四个角色 抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。 具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。 2. 观察者模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*** * 抽象观察者 * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。 * */public interface Observer &#123; void update(String message);&#125;/*** * 抽象被观察者接口 * 声明了添加、删除、通知观察者方法 */public interface Observerable &#123; void registerObserver(Observer o); void removeObserver(Observer o); void notifyObserver();&#125;/** * 具体观察者 * 实现update方法 */public class User implements Observer &#123; private String name; private int age; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public void update(String message) &#123; System.out.println(age + "岁的" + name + "收到推送的消息：" + message); &#125;&#125;/** * 具体被观察者 * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现 */public class MyServer implements Observerable &#123; private List&lt;Observer&gt; observerList; private String message; public MyServer() &#123; observerList = new ArrayList&lt;Observer&gt;(); &#125; @Override public void registerObserver(Observer o) &#123; observerList.add(o); &#125; @Override public void removeObserver(Observer o) &#123; if (!observerList.isEmpty()) &#123; observerList.remove(o); &#125; &#125; @Override public void notifyObserver() &#123; for (int i = 0; i &lt; observerList.size(); i++) &#123; Observer observer = observerList.get(i); observer.update(message); &#125; &#125; public void PushMessage(String message) &#123; this.message = message; System.out.println("推送消息：" + message); notifyObserver(); &#125;&#125;//测试public class Test &#123; public static void main(String[] args) &#123; MyServer myServer = new MyServer(); User lillusory = new User("lillusory", 22); User Az = new User("Az", 17); myServer.registerObserver(lillusory); myServer.registerObserver(Az); myServer.PushMessage("第一条推送消息"); System.out.println("-------------------------------"); myServer.removeObserver(Az);//Az取消注册后就收不到消息 User yiqixing = new User("意琦行", 999); myServer.registerObserver(yiqixing);//新增的观察者只能收到后面的消息 myServer.PushMessage("第二条推送消息"); &#125;&#125;//输出 推送消息：第一条推送消息 22岁的lillusory收到推送的消息：第一条推送消息 17岁的Az收到推送的消息：第一条推送消息 ------------------------------- 推送消息：第二条推送消息 22岁的lillusory收到推送的消息：第二条推送消息 999岁的意琦行收到推送的消息：第二条推送消息 3. 总结优点： 1.降低重复代码，使得代码更清晰、更易读、更易扩展 2.解耦，使得代码可维护性更好，修改代码的时候可以尽量少改地方 应用场景： 1.对一个对象状态的更新需要其他对象同步更新 2.对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节，如消息推送. 观察者模式在Java中的应用及解读 JDK是有直接支持观察者模式的，就是java.util.Observer这个接口： 12345678910111213public interface Observer &#123; /** * This method is called whenever the observed object is changed. An * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's * observers notified of the change. * * @param o the observable object. * @param arg an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt; * method. */ void update(Observable o, Object arg);&#125; 这就是观察者的接口，定义的观察者只需要实现这个接口就可以了。update()方法，被观察者对象的状态发生变化时，被观察者的notifyObservers()方法就会调用这个方法： 12345678910111213141516171819202122232425262728public class Observable &#123; private boolean changed = false; private Vector obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector(); &#125; /** * Adds an observer to the set of observers for this object, provided * that it is not the same as some observer already in the set. * The order in which notifications will be delivered to multiple * observers is not specified. See the class comment. * * @param o an observer to be added. * @throws NullPointerException if the parameter o is null. */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; ...&#125; 这是被观察者的父类，也就是主题对象。 4. 参考https://www.cnblogs.com/xrq730/p/4908686.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（十一）--模板方法模式]]></title>
    <url>%2Fposts%2F57ae709c.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的模板方法模式，并结合实例描述了模板方法模式的具体实现和优缺点分析。 设计模式系列文章 Java23种设计模式 1. 模板方法模式介绍模板方法模式是类的行为模式。 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。 这就是模板方法模式的用意。 抽象模板(Abstract Template)角色有如下责任： 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任： 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 2. 模板方法模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960假设炒菜有三个步骤，A下菜，B炒菜，C起锅。那么可以写一个抽象类，因为所有的菜都可以看成这三个步骤。然后炒菜和起锅这两个步骤也是一样的，当然炒菜可能也不一样╮(╯▽╰)╭。在抽象类中可以直接实现，然后下菜这个步骤应为是不同的菜所以不同。写成抽象类，等子类去实现。//抽象类public abstract class Abstract Class &#123; //模板方法，用来控制炒菜的流程 （炒菜的流程是一样的-复用） //申明为final，不希望子类覆盖这个方法，防止更改流程的执行顺序 public final void cookProcess()&#123; this.MethodA(); this.MethodB(); this.MethodC(); &#125; //第一步：下菜是不一样的，由子类实现 public abstract void MethodA(); //第二步：是一样的，所以直接实现 public void MethodB()&#123; System.out.println("炒啊炒啊炒~"); &#125; //步骤C 起锅 public void MethodC()&#123; System.out.println("菜炒好了，起锅~"); &#125;&#125;//具体实现类继承抽象类//炒白菜public class ConcreteClass_BaiCai extends test&#123; @Override public void MethodA() &#123; System.out.println("往锅里加的是白菜~"); &#125;&#125;//炒肉public class ConcreteClass_Meat extends test&#123; @Override public void MethodA() &#123; System.out.println("往锅里加的是肉~"); &#125;&#125;public class Template Method&#123; public static void main(String[] args)&#123;//炒 - 白菜 ConcreteClass_BaoCai BaiCai = new ConcreteClass_BaoCai(); BaiCai.cookProcess();//炒 - 肉 ConcreteClass_ Meat meat= new ConcreteClass_Meat(); meat.cookProcess(); &#125;&#125;//输出往锅里加的是白菜~炒啊炒啊炒~菜炒好了，起锅~往锅里加的是肉~炒啊炒啊炒~菜炒好了，起锅~ 3. 总结模板方法模式在Java中的应用 最常见的就是Servlet了。 HttpServlet担任抽象模板角色 模板方法：由service()方法担任。 基本方法：由doPost()、doGet()等方法担任。 MyServlet担任具体模板角色 自定义的servlet置换掉了父类HttpServlet中七个基本方法中的其中两个，分别是doGet()和doPost()。 4. 参考https://www.cnblogs.com/qiumingcheng/p/5219664.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（十）--策略模式]]></title>
    <url>%2Fposts%2Fa7982bdc.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的策略模式，并结合实例描述了策略模式的具体实现和策略模式的优缺点分析。 设计模式系列文章 Java23种设计模式 1. 策略模式介绍 策略模式是对算法的包装 策略模式定义了一系列的算法，并将每一个算法封装起来，而且它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 这个模式涉及到三个角色： ● 环境(Context)角色：持有一个Strategy的引用。 ● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 ● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 2. 策略模式实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//定义一个接口抽象策略 定义一个两个整数间的计算方法public interface Strategy &#123; public abstract int calculate(int a, int b);&#125;//具体策略A 加法public class ConcreteStrategyA implements Strategy &#123; @Override public int calculate(int a, int b) &#123; return a + b; &#125;&#125;//具体策略B 减法public class ConcreteStrategyB implements Strategy &#123; @Override public int calculate(int a, int b) &#123; return a - b; &#125;&#125;//具体策略C 乘法public class ConcreteStrategyC implements Strategy &#123; @Override public int calculate(int a, int b) &#123; return a * b; &#125;&#125;//具体策略D 除法public class ConcreteStrategyD implements Strategy &#123; @Override public int calculate(int a, int b) &#123; if (b != 0) &#123; return a / b; &#125; else &#123; throw new RuntimeException("除数不能为零"); &#125; &#125;&#125;//定义具体的环境角色，持有Strategy接口的引用// 并且有get和set方法可以完成策略更换// 在环境角色中调用接口的方法完成动作。public class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public int calculate(int a, int b) &#123; return strategy.calculate(a, b); &#125;&#125;//测试 public class StrategyTest &#123; public static void main(String[] args) &#123; //加 Context contextA = new Context(new ConcreteStrategyA()); System.out.println(contextA.calculate(10, 2)); //减 Context contextB = new Context(new ConcreteStrategyB()); System.out.println(contextB.calculate(10, 2)); //乘 Context contextC = new Context(new ConcreteStrategyC()); System.out.println(contextC.calculate(10, 2)); //除 Context contextD = new Context(new ConcreteStrategyD()); System.out.println(contextD.calculate(10, 2)); &#125; &#125; //输出 12 8 20 5 3. 总结策略模式的重心不是如何实现算法（就如同工厂模式的重心不是工厂中如何产生具体子类一样），而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 优点 1.让代码更优雅，避免了多重条件if…else语句。 2.策略模式提供了管理相关算法簇的办法，恰当使用继承可以把公共代码移到父类，从而避免了代码重复。 缺点 1.客户端必须知道所有的策略类，并自行决定使用 哪一个策略，这意味着客户端必须理解这些算法的区别，以便选择恰当的算法 2.如果备选策略很多，对象的数据会很多 4. 参考https://www.cnblogs.com/xrq730/p/4906313.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（九）--享元模式]]></title>
    <url>%2Fposts%2F34e634e7.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的享元模式，并结合实例描述了享元模式的具体实现，具体优缺点和单例模式的对比。 设计模式系列文章 Java23种设计模式 1. 享元模式介绍享元模式：“享”就是分享之意，指一物被众人共享，而这也正是该模式的终旨所在。 享元模式有点类似于单例模式，都是只生成一个对象来被共享使用。存储这些共享实例对象的地方称为享元池 。享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。如围棋中的的黑棋白棋，不会随外部环境的变化而变化，无论在任何环境下黑棋始终是黑棋。 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。比如每颗棋子的位置是不同的。 围棋中的黑棋和白棋可以是共享的对象，不用每次都创建一个新的对象。这样就只需要创建黑棋和白棋两个对象了。颜色是不会变得，所以是内部状态。落下得位置是随机的，所以作为外部状态。 2. 单纯享元模式 在单纯的享元模式中，所有的享元对象都是可以共享的。 单纯享元模式所涉及到的角色如下： ● 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。 ● 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。 ● 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//围棋棋子类：抽象享元类 abstract class IgoChessman &#123; public abstract String getColor(); public void display(Coordinates coord)&#123; System.out.println("棋子颜色：" + this.getColor() + "，棋子位置：" + coord.getX() + "，" + coord.getY() ); &#125; &#125; //黑色棋子类：具体享元角色Aclass BlackIgoChessman extends IgoChessman &#123; public String getColor() &#123; return "黑色"; &#125; &#125; //白色棋子类：具体享元角色B class WhiteIgoChessman extends IgoChessman &#123; public String getColor() &#123; return "白色"; &#125; &#125; //围棋棋子工厂类：享元端角色，享元工厂类 使用单例模式进行设计 class IgoChessmanFactory &#123; private static IgoChessmanFactory instance = new IgoChessmanFactory(); private static Hashtable ht; //使用Hashtable来存储享元对象，充当享元池 private IgoChessmanFactory() &#123; ht = new Hashtable(); IgoChessman black,white; black = new BlackIgoChessman(); ht.put("b",black); white = new WhiteIgoChessman(); ht.put("w",white); &#125; //返回享元工厂类的唯一实例 public static IgoChessmanFactory getInstance() &#123; return instance; &#125; //通过key来获取存储在Hashtable中的享元对象 public static IgoChessman getIgoChessman(String color) &#123; return (IgoChessman)ht.get(color); &#125; &#125; //坐标类class Coordinates &#123; private int x; private int y; public Coordinates(int x,int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return this.x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return this.y; &#125; public void setY(int y) &#123; this.y = y; &#125; &#125; //测试代码class Client &#123; public static void main(String args[]) &#123; IgoChessman black1,black2,black3,white1,white2; IgoChessmanFactory factory; //获取享元工厂对象 factory = IgoChessmanFactory.getInstance(); //通过享元工厂获取三颗黑子 black1 = factory.getIgoChessman("b"); black2 = factory.getIgoChessman("b"); black3 = factory.getIgoChessman("b"); System.out.println("判断两颗黑子是否相同：" + (black1==black2)); //通过享元工厂获取两颗白子 white1 = factory.getIgoChessman("w"); white2 = factory.getIgoChessman("w"); System.out.println("判断两颗白子是否相同：" + (white1==white2)); //显示棋子，同时设置棋子的坐标位置 black1.display(new Coordinates(1,2)); black2.display(new Coordinates(3,4)); black3.display(new Coordinates(1,3)); white1.display(new Coordinates(2,5)); white2.display(new Coordinates(2,4)); &#125; &#125; //输出判断两颗黑子是否相同：true判断两颗白子是否相同：true棋子颜色：黑色，棋子位置：1，2棋子颜色：黑色，棋子位置：3，4棋子颜色：黑色，棋子位置：1，3棋子颜色：白色，棋子位置：2，5棋子颜色：白色，棋子位置：2，4 3. 复合享元模式 在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。 复合享元角色所涉及到的角色如下： ● 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。 ● 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。 ● 复合享元(ConcreteCompositeFlyweight)角色 ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。 ● 享元工厂(FlyweightFactory)角色 ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//抽象享元角色类public interface Flyweight &#123; //一个示意性方法，参数state是外部状态 public void operation(String state);&#125;//具体享元角色类public class ConcreteFlyweight implements Flyweight &#123; private Character intrinsicState = null; /** * 构造函数，内部状态作为参数传入 * @param state */ public ConcreteFlyweight(Character state)&#123; this.intrinsicState = state; &#125; /** * 外部状态作为参数传入方法中，改变方法的行为， * 但是并不改变对象的内部状态。 */ @Override public void operation(String state) &#123; System.out.println("Intrinsic State = " + this.intrinsicState); System.out.println("Extrinsic State = " + state); &#125;&#125;//复合享元角色public class ConcreteCompositeFlyweight implements Flyweight &#123; private Map&lt;Character,Flyweight&gt; files = new HashMap&lt;Character,Flyweight&gt;(); /** * 增加一个新的单纯享元对象到聚集中 */ public void add(Character key , Flyweight fly)&#123; files.put(key,fly); &#125; /** * 外部状态作为参数传入到方法中 */ @Override public void operation(String state) &#123; Flyweight fly = null; for(Object o : files.keySet())&#123; fly = files.get(o); fly.operation(state); &#125; &#125;&#125;//工厂类public class FlyweightFactory &#123; private Map&lt;Character,Flyweight&gt; files = new HashMap&lt;Character,Flyweight&gt;(); /** * 复合享元工厂方法 */ public Flyweight factory(List&lt;Character&gt; compositeState)&#123; ConcreteCompositeFlyweight compositeFly = new ConcreteCompositeFlyweight(); for(Character state : compositeState)&#123; compositeFly.add(state,this.factory(state)); &#125; return compositeFly; &#125; /** * 单纯享元工厂方法 */ public Flyweight factory(Character state)&#123; //先从缓存中查找对象 Flyweight fly = files.get(state); if(fly == null)&#123; //如果对象不存在则创建一个新的Flyweight对象 fly = new ConcreteFlyweight(state); //把这个新的Flyweight对象添加到缓存中 files.put(state, fly); &#125; return fly; &#125;&#125;//测试代码public class Client &#123; public static void main(String[] args) &#123; List&lt;Character&gt; compositeState = new ArrayList&lt;Character&gt;(); compositeState.add('a'); compositeState.add('b'); compositeState.add('c'); compositeState.add('a'); compositeState.add('b'); FlyweightFactory flyFactory = new FlyweightFactory(); Flyweight compositeFly1 = flyFactory.factory(compositeState); Flyweight compositeFly2 = flyFactory.factory(compositeState); compositeFly1.operation("Composite Call"); System.out.println("---------------------------------"); System.out.println("复合享元模式是否可以共享对象：" + (compositeFly1 == compositeFly2)); Character state = 'a'; Flyweight fly1 = flyFactory.factory(state); Flyweight fly2 = flyFactory.factory(state); System.out.println("单纯享元模式是否可以共享对象：" + (fly1 == fly2)); &#125;&#125; 4. 总结优点： 节约系统的开销，可以少创建对象。外部状态不会影响内部状态，可以在不同环境下进行共享哦。缺点： 享元模式使逻辑变得更加复杂，需要将享元对象分出内部状态和外部状态。 并且为了使对象可以共享，外部状态在很多情况下是必须有的，当读取外部状态时明显会增加运行时间。 享元模式使用的场景： 当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。 与单例模式的区别： 享元模式的目的是共享，避免多次创建耗费资源，减少不会要额内存消耗 。 单例模式的目的是限制创建多个对象以避免冲突等 。 5. 参考http://blog.csdn.net/lovelion&gt; https://blog.csdn.net/Hmily_hui/article/details/80917975]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（八）--外观模式]]></title>
    <url>%2Fposts%2F22a51705.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的 模式，并结合实例描述了 模式的具体实现和性能分析测试。 设计模式系列文章 Java23种设计模式 1. 外观模式介绍 它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。 外观模式结构： SubSystem: 子系统角色。表示一个系统的子系统或模块。 Facade: 外观角色，客户端通过操作外观角色从而达到控制子系统角色的目的。对于客户端来说，外观角色好比一道屏障，对客户端屏蔽了子系统的具体实现。 2. 外观模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//子系统Apublic class SubSystemA &#123; public void startUp()&#123; System.out.println("SubSystemA startUp"); &#125; public void shutDown()&#123; System.out.println("SubSystemA shutDown"); &#125;&#125;//子系统Bpublic class SubSystemB &#123; public void startUp()&#123; System.out.println("SubSystemB startUp"); &#125; public void shutDown()&#123; System.out.println("SubSystemB shutDown"); &#125;&#125;//子系统Cpublic class SubSystemC &#123; public void startUp() &#123; System.out.println("SubSystemC startUp"); &#125; public void shutDown() &#123; System.out.println("SubSystemC shutDown"); &#125;&#125;//外观角色public class Facade &#123; private SubSystemA subSystemA; private SubSystemB subSystemB; private SubSystemC subSystemC; public Facade() &#123; subSystemA = new SubSystemA(); subSystemB = new SubSystemB(); subSystemC = new SubSystemC(); &#125; public void startUp() &#123; subSystemA.startUp(); subSystemB.startUp(); subSystemC.startUp(); &#125; public void shutDown() &#123; subSystemA.shutDown(); subSystemB.shutDown(); subSystemC.shutDown(); &#125;&#125; //测试 public class test &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.startUp(); facade.shutDown(); &#125; &#125; //输出 SubSystemA startUp SubSystemB startUp SubSystemC startUp SubSystemA shutDown SubSystemB shutDown SubSystemC shutDown 3. 总结外观模式的优点 外观模式有如下几个优点： 1、松散耦合 外观模式松散了客户端和子系统的耦合关系，让子系统内部的模块能更容易扩展和维护 2、简单易用 客户端不需要了解系统内部的实现，也不需要和众多子系统内部的模块交互，只需要和外观类交互就可以了 3、更好地划分层次 通过合理使用Facade，可以帮助我们更好地划分层次。有些方法是系统对内的，有些方法是对外的，把需要暴露给外部的功能集中到Facade中，这样既方便客户端使用，也很好地隐藏了内部的细节 外观模式在Java中的应用 Tomcat中有很多场景都使用到了外观模式，因为Tomcat中有很多不同的组件，每个组件需要相互通信，但又不能将自己内部数据过多地暴露给其他组件。用外观模式隔离数据是个很好的方法，比如Request上使用外观模式。 比如Servlet，doGet和doPost方法，参数类型是接口HttpServletRequest和接口HttpServletResponse，那么Tomcat中传递过来的真实类型到底是什么呢？ 在真正调用Servlet前，会经过很多Tomcat方法，传递给Tomcat的request和response的真正类型是一个Facade类。 因为Request类中很多方法都是组件内部之间交互用的，比如setComet、setReuqestedSessionId等方法，这些方法并不对外公开，但又必须设置为public，因为还要和内部组件交互使用。最好的解决方法就是通过使用一个Facade类，屏蔽掉内部组件之间交互的方法，只提供外部程序要使用的方法。 如果不使用Facade，直接传递的是HttpServletRequest和HttpServletResponse，那么熟悉容器内部运作的开发者可以分别把ServletRequest和ServletResponse向下转型为HttpServletRequest和HttpServletResponse，这样就有安全性的问题了。 4. 参考https://www.cnblogs.com/xrq730/p/4908822.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（七）--代理模式]]></title>
    <url>%2Fposts%2Fae2a93bd.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的代理模式，并结合实例描述了各种代理模式的具体实现和对比。包括：JDK静态代理，JDK动态代理，cglib动态代理. 设计模式系列文章 Java23种设计模式 1. 代理模式介绍 给某一对象提供一个代理对象，并由代理对象控制对原对象的引用。 代理模式的结构 有些情况下，一个客户不想或者不能够直接引用一个对象，可以通过代理对象在客户端和目标对象之间起到中介作用。代理模式中的角色有： 1、抽象对象角色 声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象 2、目标对象角色 定义了代理对象所代表的目标对象 3、代理对象角色 代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象 2. 静态代理123由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。代理类和被代理类必须实现同一个接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//代理类和被代理类需要实现的接口public interface Person &#123; public void sayHello(String str);&#125;//学生 被代理类public class Student implements Person &#123; @Override public void sayHello(String str) &#123; System.out.println(str); &#125;&#125;//代理类public class PersonProxy implements Person &#123; //被代理的对象 private Person person; //通过构造方法赋值 public PersonProxy(Person person) &#123; this.person = person; &#125; @Override public void sayHello(String str) &#123; //在执行代理方法前后可以执行其他的方法 代理模式的一个很大的优点 System.out.println("Before"); //在代理类的方法中 间接访问被代理对象的方法 person.sayHello(str); System.out.println("After"); &#125;&#125; //测试代码 public class ProxyTest &#123; public static void main(String[] args) &#123; //被代理的对象 Student student = new Student(); //将被代理对象传递给代理对象 PersonProxy personProxy = new PersonProxy(student); //代理对象调用方法 personProxy.sayHello("hello proxy"); &#125; &#125; //输出结果 Before hello proxy After 3. 动态代理 代理类在程序运行时创建的代理方式被成为动态代理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class JDKProxy implements InvocationHandler&#123; //引入被增强类的实例 private UserDao userDao; public JDKProxy (UserDao userDao) &#123; this.userDao=userDao; &#125; public UserDao createProxy() &#123; UserDao userDaoProxy=(Demo.UserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(), userDao.getClass().getInterfaces(), this);//直接用当前类实现InvocationHandler接口 return userDaoProxy; &#125; ////调用被代理对象的任何方法都相当于在调用这个方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if ("想要增强的方法".equals(method.getName())) &#123;//判断是不是想要增强的方法 //是想增强的方法 则对方法进行增强 System.out.println("before"); method.invoke(UserDao, args); System.out.println("after"); &#125; //普通方法就正常执行 return method.invoke(UserDao, args); &#125;&#125;//比较重要的两个地方 1..InvocationHandlerInvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125;InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。//对代理对象的增强就在这里进行 实现该接口 重写此方法 可以用匿名内部类或者直接用生成代理的那个类实现该接口-proxy 代理对象-method 代理对象调用的方法-args 调用的方法中的参数因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。需要创建一个类实现InvocationHandler接口 2..生成代理对象 Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler);第三个参数就要用到InvocationHandler接口的实现类//参数1 类加载器 增强哪个对象就写哪个类的类加载器 myCar.getClass().getClassLoader();// 告诉虚拟机用哪个字节码加载器加载内存中创建出来的字节码文件 一般是application类加载器//参数2 字节码数组 被代理类实现的所有接口的字节码数组 // 告诉虚拟机内存中正在你被创建的字节码文件中应该有哪些方法//参数3 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 、// 告诉虚拟机字节码上的那些方法如何处理 （用户自定义增强操作等 写在实现InvocationHandler接口的那个类中） 同样是上边的Person接口 和Student被代理类 12345678910111213141516171819202122//测试代码 public class DynamicTest &#123; public static void main(String[] args) &#123; //创建一个实例对象，这个对象是被代理的对象 Student studentB = new Student(); //获取被代理对实现的所有接口的字节码 Class[] interfaces = Student.class.getInterfaces; //创建一个与代理对象相关联的InvocationHandler 将被代理对象传过去 DynamicInvocationHandler dynamicInvocationHandler = new DynamicInvocationHandler(studentB); //获取被代理对象的类加载器 ClassLoader classLoader = StudentB.getClass().getClassLoader(); //生成代理对象 返回的时Object类型 只能强转为接口类型（Person） 不能强转为子类类型(Student) Person person = (Person) Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler);//这里需要创建一个类实现InvocationHandler接口 重写invoke方法 //代理对象调用方法 person.sayHello("hello Dynamic"); &#125; &#125; //输出结果 Before hello Dynamic After 小结： 12341.通过 Proxy.newProxyInstance(classLoader, interfaces, dynamicInvocationHandler);生成代理对象，2.创建InvocationHandler接口实现类 重写invoke方法 实现具体的方法增强3.调用对象的方法最后都是调用InvocationHandler接口的invoke方法4.只能增强接口中有的方法 4. CGLIB动态代理 JDK代理要求被代理的类必须实现接口，有很强的局限性。 而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。 cglib原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。由于是通过子类来代理父类，因此不能代理被final字段修饰的方法。 1234567891011121314151617181920212223242526272829303132public class CglibProxy implements MethodInterceptor&#123; //引入被增强类的实例 private UserDao userDao; public CglibProxy (UserDao userDao) &#123; this.userDao=userDao; &#125; public UserDao createProxy() &#123; //1.创建Cglib的核心类对象 Enhancer enhancer=new Enhancer(); //2.设置父类 Cglib采用继承方式实现代理 所以需要设置父类 enhancer.setSuperclass(userDao.getClass()); //3.设置回调(类似于invocationhandler) enhancer.setCallback(this);//还是直接用当前类去实现MethodInterceptor接口 //4.创建代理对象 UserDao proxy = (UserDao) enhancer.create(); return proxy; &#125; //类似于JDK动态代理的invoke方法 在这里对方法实现增强 //调用被代理对象的任何方法都相当于在调用这个方法 public Object intercept(Object Proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; if ("save".equals(method.getName())) &#123;//判断是不是想要增强的方法 //是想增强的方法 则对方法进行增强 System.out.println("before"); methodProxy.invoke(Proxy, args); System.out.println("after"); &#125; return methodProxy.invoke(Proxy, args); &#125;&#125; 5. 代理模式比较 代理方式 实现 优点 缺点 特点 JDK静态代理 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口 实现简单，容易理解 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 好像没啥特点 JDK动态代理 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理 不需要硬编码接口，代码复用率高 只能够代理实现了接口的委托类 底层使用反射机制进行方法的调用 CGLIB动态代理 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 不能对final类以及final方法进行代理 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 6. 参考https://www.cnblogs.com/xrq730/p/4907999.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（六）--装饰者模式]]></title>
    <url>%2Fposts%2F75903408.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的装饰者模式，并结合实例描述了装饰者模式的具体实现和优缺点分析。 设计模式系列文章 Java23种设计模式 1. 装饰者模式介绍在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。 它是通过创建一个包装对象，也就是装饰来包裹真实的对象。是继承关系的一个替代方案。 装饰模式由4种角色组成：（1）抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加职责的对象。（2）具体构件（Concrete Component）角色：定义一个将要接收附加职责的类。（3）装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口，从外类来扩展Component类的功能，但对于Component类来说，是无需知道Decorato的存在的。（4）具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的职责。 2. 装饰者模式具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public interface Component &#123; public Double getPrice();//返回价格 public String getName();//返回商品名&#125;public class ConcreteComponent implements Component &#123; private String milk = "牛奶";//买了一盒牛奶 private Double price_milk=5.5; @Override public Double getPrice() &#123; return price_milk; &#125; @Override public String getName() &#123; return milk; &#125;&#125;//抽象装饰角色public class Decorator implements Component &#123; private ConcreteComponent cc; public Decorator(ConcreteComponent cc) &#123; this.cc = cc; &#125; @Override public Double getPrice() &#123; return cc.getPrice();//具体由子类描述 &#125; @Override public String getName() &#123; return cc.getName(); &#125;&#125;//具体装饰角色1 牛奶不够 加一个面包public class ConcreteDecorator extends Decorator &#123; private String bread = "面包";//又买了一个面包 private Double price_bread = 6.8;//面包价格 public ConcreteDecorator(ConcreteComponent cc) &#123; super(cc); &#125; @Override public Double getPrice() &#123; return super.getPrice() + price_bread;//加面包价格 &#125; @Override public String getName() &#123; return super.getName() + bread;//加面包 &#125;&#125;//具体装饰角色2 不想喝牛奶 要吃苹果public class ConcreteDecorator2 extends Decorator &#123; private String apple = "苹果";//买了一个苹果 private Double price_apple = 15.2; public ConcreteDecorator2(ConcreteComponent cc) &#123; super(cc); &#125; @Override public String getName() &#123; return apple;//只买了苹果 牛奶不要了 &#125; @Override public Double getPrice() &#123; return price_apple; &#125;&#125; //测试 public class test &#123; public static void main(String[] args) &#123; ConcreteComponent cc = new ConcreteComponent(); ConcreteDecorator cd = new ConcreteDecorator(cc); System.out.println("name:" + cd.getName() + "" + "price:" + cd.getPrice()); System.out.println("------------------------------------"); ConcreteDecorator2 cd2 = new ConcreteDecorator2(cc); System.out.println("name:" + cd2.getName() + "" + "price:" + cd2.getPrice()); &#125; &#125; //输出 name:牛奶面包price:12.3 ----------------------------------- name:苹果price:15.2 3. 总结优点 1.装饰者模式可以提供比继承更多的灵活性。装饰器模式允许系统动态决定贴上一个需要的装饰，或者除掉一个不需要的装饰。继承关系是不同，继承关系是静态的，它在系统运行前就决定了。 2.通过使用不同的具体装饰器以及这些装饰类的排列组合，设计师可以创造出很多不同的行为组合。 缺点 由于使用装饰器模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是另一方面，由于使用装饰器模式会产生比使用继承关系更多的对象，更多的对象会使得查错变得困难，特别是这些对象看上去都很像。 装饰者模式和代理模式对比 装饰者模式主要对功能进行扩展，代理模式主要是添加一些无关业务的功能，比如日志，验证等 使用代理模式,代理和真实对象之间的关系在编译时就已经确定了,而装饰器者能够在运行时递归的被构造.(代理模式会在代理类中创建真实处理类的一个实例,所以可以确定代理和真实对象的关系,而装饰器模式是将原始对象作为一个参数传给装饰器类) 装饰模式：以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；代理模式：给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用； 装饰者模式在Java中的应用 装饰器模式在Java体系中的经典应用是Java I/O 抽象构件角色:InputStream 具体构建角色:ByteArrayInputStream、FileInputStream、ObjectInputStream、PipedInputStream等 装饰角色；FilterInputStream –&gt;实现了InputStream内的所有抽象方法并且持有一个InputStream的引用 具体装饰角色:InflaterInputStream、BufferedInputStream、DataInputStream等 4. 参考https://www.cnblogs.com/xrq730/p/4908940.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（五）--适配器模式]]></title>
    <url>%2Fposts%2Fa340063f.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式之适配器模式，并结合实例描述了适配器模式的具体实现和优缺点分析。 设计模式系列文章 Java23种设计模式 1. 适配器模式介绍 适配器模式将一个接口转换成客户希望的另外一个接口。它使得原来由于接口不兼容而不能在一起工作的那些类可以一起工作。 把一个类的接口变换成客户端所期待的另一种接口 用到的对象 Target — 定义Client使用的与特定领域相关的接口。 Client — 与符合Target接口的对象协同。 Adaptee — 定义一个已经存在的接口，这个接口需要适配。 Adapter — 对Adaptee的接口与Target接口进行适配 2. 类适配器模式原理： 通过继承来实现适配器功能。 当我们要访问的类A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，但我们又不能改变类A。 在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要继承我们访问类A，这样我们就能继续访问当前类A中的方法（虽然它目前不是我们的菜），然后再实现接口B，这样我们可以在适配器P中访问接口B的方法了。 12345678910111213141516171819202122232425262728293031//目标接口 需要方法Bpublic interface Target &#123; void B();&#125;//被适配类 只有A方法 但是Client需要B方法public class Adaptee &#123; public void A() &#123; System.out.println("Function A"); &#125;&#125;//适配类 继承被适配类的同时实现目标接口public class Adapter extends Adaptee implements Target &#123; @Override public void B() &#123; System.out.println("Function B"); &#125;&#125;//测试public class FactoryTest &#123; public static void main(String[] args) &#123; Target target = new Adapter(); ((Adapter) target).A(); target.B(); &#125;&#125;//输出 Function A Function B 3. 对象适配器模式原理 基本思路和类的适配器模式相同，只是将 Adapter 类作修改，这次不继承 Adaptee 类，而是持有 Adaptee 类的实例，以达到解决兼容性的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142//目标接口 需要方法Bpublic interface Target &#123; void B();&#125;//被适配类 只有A方法 但是Client需要B方法public class Adaptee &#123; public void A() &#123; System.out.println("Function A"); &#125;&#125;//适配类 传入被适配类对象，实现目标接口public class Adapter implements Target &#123; private Adaptee adaptee; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void B() &#123; System.out.println("Function B"); &#125; public void A() &#123; adaptee.A(); &#125;&#125;//测试 public class FactoryTest &#123; public static void main(String[] args) &#123; Adaptee adaptee = new Adaptee(); Target target = new Adapter(adaptee); ((Adapter) target).A(); target.B(); &#125; &#125;//输出 Function A Function B 4. 总结适配器模式优点 1、有更好的复用性。系统需要使用现有的类，但此类接口不符合系统需要，通过适配器模式让这些功能得到很好的复用 2、有更好的扩展性。实现适配器，可以调用自己开发的功能 缺点 过多使用适配器会使得系统非常凌乱，明明调用的是A接口，内部却被适配成了B接口。因此除非必要，不推荐使用适配器，而是直接对系统重构 适配器模式在JDK中的应用 InputStreamReader/OutputStreanWriter 创建InputStreamReader对象的时候必须在构造函数中传入一个InputStream实例，然后InputStreamReader的作用就是将InputStream适配到Reader。很显然，适配器就是InputStreamReader，源角色就是InputStream代表的实例对象，目标接口就是Reader类。 5. 参考https://www.cnblogs.com/xrq730/p/4906487.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（四）--原型模式]]></title>
    <url>%2Fposts%2Fa340063f.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的原型模式，并结合实例描述了原型模式的具体实现和应用场景，优缺点分析等。 设计模式系列文章 Java23种设计模式 1. 原型模式介绍1.1 原型模式 原型模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。简单地说原型模式就是创建复杂对象的时候使用克隆手段来代替新建一个对象。当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。 原型模式主要包含如下三个角色： Prototype：抽象原型类。声明克隆自身的接口。 ConcretePrototype：具体原型类。实现克隆的具体操作。 Client：客户类。让一个原型克隆自身，从而获得一个新的对象。 1.2 克隆我们需要知道，Java中的对象克隆分为浅克隆和深克隆。 浅克隆：将一个对象克隆后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深克隆：将一个对象克隆后，不论是基本数据类型还有引用类型，都是重新创建的。 简单来说，就是深克隆进行了完全彻底的克隆，而浅克隆不彻底。 2. 原型模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//实现Cloneable接口浅复制，Serializable接口深复制public class Book implements Cloneable, Serializable &#123; private String title; private int page; private Author author; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getPage() &#123; return page; &#125; public void setPage(int page) &#123; this.page = page; &#125; public Author getAuthor() &#123; return author; &#125; public void setAuthor(Author author) &#123; this.author = author; &#125; public Book clone() &#123; Book book = null; try &#123; book = (Book) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return book; &#125; public Book deepClone() throws IOException, ClassNotFoundException &#123; // 写入当前对象的二进制流 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 读出二进制流产生的新对象 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (Book) ois.readObject(); &#125;&#125;//Author类 Book中引用public class Author implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;//测试 public class FactoryTest &#123; public static void main(String[] args) &#123; try &#123; Author author = new Author(); author.setAge(22); author.setName("illusoryCloud"); Book book = new Book(); book.setAuthor(author); book.setPage(222); book.setTitle("MyBook"); Book clone = book.clone(); Book deepClone = book.deepClone(); //深浅克隆的对象和原型都不是同一个对象 //浅克隆对象的引用类型和原型相同，浅克隆，指向原来的地址 System.out.println(book == clone); // false System.out.println(book.getPage() == clone.getPage()); // true System.out.println(book.getTitle() == clone.getTitle()); // true System.out.println(book.getAuthor() == clone.getAuthor()); // true System.out.println("--------------------------------------"); //深复制对象的引用类型和原型不相同，创建了新的引用对象 System.out.println(book == deepClone); // false System.out.println(book.getPage() == deepClone.getPage()); // true System.out.println(book.getTitle() == deepClone.getTitle()); // false System.out.println(book.getAuthor() == deepClone.getAuthor()); // false &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 3. 总结为什么要用原型模式 通过复制已有的对象，可以简化对象的创建过程，提高创建对象的效率。 深克隆保存对象状态，实现撤销恢复功能。 缺点： 在实现深克隆时需要编写复杂的代码。 需要为每一个类写一个克隆方法，如果要深克隆，则类中的每一层对象的类都得支持深克隆，代码比较复杂。 应用场景 创建对象成本高。 当一个系统应该独立于它的产品创建、构成和表示时，要使用原型模式。 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 原型模式在Java中的应用及解读 只要是实现了Cloneable接口的类都可以算是原型模式的应用，比如ArrayList。 1234567891011121314151617public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ... public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; ...&#125; 程序中获取到了一个ArrayList的实例arrayList，我们完全可以通过调用arrayList.clone()方法获取到原ArrayList的拷贝。 4. 参考https://www.cnblogs.com/xrq730/p/4905907.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（三）--建造者模式]]></title>
    <url>%2Fposts%2F52453.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的建造者模式，并结合实例描述了建造者模式的具体实现和优缺点及建造者模式和工厂模式的差别分析等。 设计模式系列文章 Java23种设计模式 1. 建造者模式介绍 建造者模式是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。。 建造者模式通常包括下面几个角色： （1） Builder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。 （2） ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。 （3）Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 （4）Product：要创建的复杂对象 2. 建造者模式实例以创建一个Person为例： Product（要创建的对象）： 12345678910111213141516171819202122232425262728293031//首先创建一个Person对象，简单的一些属性和get，set方法public class Person &#123; private String name; private String address; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Builder（给出一个抽象接口，以规范产品对象的各个组成成分的建造 ） 12345678910//然后创建一个接口 建造对象的标准public interface Builder &#123; void builderName(); void builderAddress(); void builderAge(); Person builderPerson();&#125; ConcreteBuilder（实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//接着创建一个构造具体对象的类，实现前面的标准（接口）public class BuildMe implements Builder &#123; Person person; //构造方法创建一个对象 public BuildMe() &#123; person = new Person(); &#125; //然后为对象添加各种属性 @Override public void builderName() &#123; person.setName("lillusory"); &#125; @Override public void builderAddress() &#123; person.setAddress("重庆"); &#125; @Override public void builderAge() &#123; person.setAge(22); &#125; //最后返回该对象 @Override public Person builderPerson() &#123; return person; &#125;&#125;//这里可以根据不同的逻辑或需求，实现不同的（产品）public class BuildZhangSan implements Builder &#123; Person person; public BuildZhangSan() &#123; person = new Person(); &#125; @Override public void builderName() &#123; person.setName("张三"); &#125; @Override public void builderAddress() &#123; person.setAddress("北京"); &#125; @Override public void builderAge() &#123; person.setAge(20); &#125; @Override public Person builderPerson() &#123; return person; &#125;&#125; Director（调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建 ） 12345678910//最后创建一个Director指导者？类来创建对象//只负责保证对象各部分完整创建 不知道具体细节public class Director &#123; public Person construcPerson(Builder builder) &#123; builder.builderName(); builder.builderAddress(); builder.builderAge(); return builder.builderPerson(); &#125;&#125; 测试 123456789101112131415161718192021public class FactoryTest &#123; public static void main(String[] args) &#123; Director director = new Director(); Person person = director.construcPerson(new BuildMe()); System.out.println(person.getName()); System.out.println(person.getAddress()); System.out.println(person.getAge()); cPerson zhangSan = director.construcPerson(new BuildZhangSan()); System.out.println(zhangSan.getName()); System.out.println(zhangSan.getAddress()); System.out.println(zhangSan.getAge()); &#125;&#125;//输出 lillusory 重庆 22 张三 北京 20 3. 总结建造者模式优点： 1.将对象本身与对象的创建过程解耦，使得相同的创建过程可以创建不同的对象。 2.可以更加精细地控制产品的创建过程 3.增加新的具体建造者无须修改原有类库的代码，符合开闭原则 与工厂模式的区别： 工厂模式注重的是整体对象的创建方法，只为了获取对象，关注整体 建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象，关注细节。建造者模式一般用来创建更为复杂的对象]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（二）--工厂模式]]></title>
    <url>%2Fposts%2F34710.html</url>
    <content type="text"><![CDATA[本章主要介绍了设计模式中的工厂模式，并结合实例描述了工厂模式的具体实现和使用场景。包括：普通工厂模式、工厂方法模式、抽象工厂模式等。 设计模式系列文章 Java23种设计模式 1. 工厂模式介绍工厂模式可以分为普通工厂模、工厂方法模式和抽象工厂模式。 简单工厂模式：建立一个工厂类，根据传入的参数对实现了同一接口的一些类进行实例的创建。 工厂方法模式：是对普通工厂方法模式的改进，提供多个工厂方法，分别创建对象。 抽象工厂模式：创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 工厂模式优点： (1) 解耦：把对象的创建和使用的过程分开 (2)减少重复代码: 若创建对象的过程很复杂，有一定的代码量，且很多地方都要用到，那么就会有很多重复代码。 (3) 降低维护成本 ：创建过程都由工厂统一管理，发生业务逻辑变化，只需要在工厂里修改即可。 适用场景 （1）需要创建的对象较少。 （2）客户端不关心对象的创建过程。 2. 简单工厂模式 1234567891011121314151617181920212223242526272829303132333435363738public interface Fruit &#123; void eat();&#125;public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println("Apple"); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println("Orange"); &#125;&#125;//水果工厂 根据不同参数创建不同的水果对象public class FruitFactory &#123; public static Fruit creatFruit(String fruit)&#123; if (fruit.equals("Apple")) &#123; return new Apple(); &#125; else if (fruit.equals("Orange")) &#123; return new Orange(); &#125; else &#123; System.out.println("error unknow fruit ~"); return null; &#125; &#125;&#125;public class FactoryTest &#123; @Test public void testFactory() &#123; Fruit apple = FruitFactory.creatFruit("Apple"); apple.eat(); &#125;&#125; 3. 工厂方法模式123456789101112public interface ThreadFactory &#123; /** * Constructs a new &#123;@code Thread&#125;. Implementations may also initialize * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or &#123;@code null&#125; if the request to * create a thread is rejected */ Thread newThread(Runnable r);&#125; 具体的线程工厂可以implements这个接口并实现newThread(Runnable r)方法，来生产具体线程工厂想要生产的线程。 1234567891011121314151617181920212223242526272829303132//抽象水果工厂public interface FruitFactory &#123; Fruit creatFruit();&#125;//苹果工厂public class AppleFactory implements FruitFactory&#123; @Override public Fruit creatFruit() &#123; return new Apple(); &#125;&#125;//橘子工厂public class OrangeFactory implements FrutiFactory &#123; @Override public Fruit creatFruit() &#123; return new Orange(); &#125;&#125;//测试public class FactoryTest &#123; @Test public void testFactory() &#123; AppleFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.creatFruit(); apple.eat(); OrangeFactory orangeFactory = new OrangeFactory(); Fruit orange = orangeFactory.creatFruit(); orange.eat(); &#125;&#125; 4. 抽象工厂模式 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//两个接口 Fruit Juicepublic interface Fruit &#123; void eat();&#125;public interface Juice &#123; void drink();&#125;//四个对象 苹果 橘子 苹果汁 橘子汁public class Apple implements Fruit &#123; @Override public void eat() &#123; System.out.println("Apple"); &#125;&#125;public class Orange implements Fruit &#123; @Override public void eat() &#123; System.out.println("Orange"); &#125;&#125;public class AppleJuice implements Juice &#123; @Override public void drink() &#123; System.out.println("AppleJuice"); &#125;&#125;public class OrangeJuice implements Juice &#123; @Override public void drink() &#123; System.out.println("OrangeJuice"); &#125;&#125;//抽象工厂 生产水果和果汁public interface AbstractFactory &#123; Fruit creatFruit(); Juice creatJuice();&#125;//具体工厂 生产苹果相关产品public class AppleFactory implements AbstractFactory &#123; @Override public Fruit creatFruit() &#123; return new Apple(); &#125; @Override public Juice creatJuice() &#123; return new AppleJuice(); &#125;&#125;//具体工厂 生产橘子相关产品public class OrangeFactory implements AbstractFactory &#123; @Override public Fruit creatFruit() &#123; return new Orange(); &#125; @Override public Juice creatJuice() &#123; return new OrangeJuice(); &#125;&#125;//测试 @Test public void testFactory()&#123; AppleFactory appleFactory=new AppleFactory(); Fruit apple = appleFactory.creatFruit(); Juice appleJuice= appleFactory.creatJuice(); apple.eat(); appleJuice.drink(); OrangeFactory orangeFactory=new OrangeFactory(); Fruit orange= orangeFactory.creatFruit(); Juice orangeJuice= orangeFactory.creatJuice(); orange.eat(); orangeJuice.drink(); &#125; 5. 总结工厂模式的优点？为什么要使用工厂模式 工厂都是用来封装对象的具体创建过程，减少重复代码，降低对象变化时的维护成本，将对象创建过程和使用相解耦。 工厂方法模式使用继承，抽象工厂使用对象组合；两者利用抽象的原则，将具体的实例化过程延迟到子类。 工厂利用的最重要和基本的原则——依赖抽象，不要依赖具体类。 应用场景 简单工厂：适合创建同一级别的不同对象。 工厂方法：为每种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品。 抽象工厂模式：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。 工厂模式在Java中的应用 简单工厂模式 JDK中的简单工厂模式有很多应用，比较典型的比如线程池。我们使用线程池的时候，可以使用ThreadPoolExecutor，根据自己的喜好传入corePoolSize、maximumPoolSize、keepAliveTimem、unit、workQueue、threadFactory、handler这几个参数，new出一个指定的ThreadPoolExecutor出来。 工厂方法模式 123456789101112public interface ThreadFactory &#123; /** * Constructs a new &#123;@code Thread&#125;. Implementations may also initialize * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or &#123;@code null&#125; if the request to * create a thread is rejected */ Thread newThread(Runnable r);&#125; 这是一个生产线程的接口,具体的线程工厂可以implements这个接口并实现newThread(Runnable r)方法，来生产具体线程工厂想要生产的线程。 6. 参考https://blog.csdn.net/d1562901685/article/details/77623237 https://www.cnblogs.com/xrq730/p/4905578.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（十三）--组合模式]]></title>
    <url>%2Fposts%2Fa340063f.html</url>
    <content type="text"><![CDATA[本文主要介绍了Java23种设计模式中的 模式，并结合实例描述了 模式的具体实现和性能分析测试。 设计模式系列文章 Java23种设计模式 1. 组合模式介绍组合模式：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 所谓组合模式，其实说的是对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局 以Windows文件系统为例，文件夹下可能有文件，也可能还有一个文件夹。文件夹可以包含文件和文件夹，但文件却没有这些功能。所以实现的时候需要单独实现。如果用组合模式的话，将文件和文件夹看成一个整体。都是文件。当做抽象的文件。 2. 组合模式实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//抽象文件类 public abstract class AbstractFiles &#123; public abstract void add(AbstractFiles af); public abstract void remove(AbstractFiles af); public abstract AbstractFiles get(int i); public abstract void killVirus();&#125;//具体文件类型 图片文件 没有的方法就不实现 叶子节点public class ImageFile extends AbstractFiles &#123; private String name; public ImageFile(String name) &#123; this.name=name; &#125; @Override public void add(AbstractFiles af) &#123; System.out.println("不支持该方法"); &#125; @Override public void remove(AbstractFiles af) &#123; System.out.println("不支持该方法"); &#125; @Override public AbstractFiles get(int i) &#123; System.out.println("不支持该方法"); return null; &#125; @Override public void killVirus() &#123; System.out.println("开始进行--"+name+"--文件杀毒"); &#125;&#125;//文件夹类型的文件 实现所有方法 树枝节点public class Folder extends AbstractFiles &#123; //文件夹类，所有的都可以用 private ArrayList&lt;AbstractFiles&gt; list = new ArrayList&lt;AbstractFiles&gt;(); private String name; public Folder(String name) &#123; this.name=name; &#125; @Override public void add(AbstractFiles af) &#123; list.add(af); System.out.println("添加成功"); &#125; @Override public void remove(AbstractFiles af) &#123; // TODO Auto-generated method stub if(list.remove(af)) &#123; System.out.println("删除成功"); &#125;else&#123; System.out.println("删除失败"); &#125; &#125; @Override public AbstractFiles get(int i) &#123; return list.get(i); &#125; @Override public void killVirus() &#123; // TODO Auto-generated method stub System.out.println("对文件夹"+name+"进行杀毒"); //递归调用 for(Object o:list) &#123; ((AbstractFiles)o).killVirus(); &#125; &#125;&#125;//测试代码public class Client &#123; public static void main(String[] args) &#123; //创建一个文件类型 AbstractFiles f1 = new Folder("主文件夹"); //创建文件 AbstractFiles file1= new ImageFile("孙悟空。png"); AbstractFiles file2= new ImageFile("龙珠.jpg"); AbstractFiles file3= new ImageFile("帅哥威.gif"); f1.add(file1); f1.add(file2); f1.add(file3); f1.killVirus(); file1.killVirus(); &#125; 参考https://blog.csdn.net/qq_40709468/article/details/81990084]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式（一）--单例模式]]></title>
    <url>%2Fposts%2F53093.html</url>
    <content type="text"><![CDATA[本文主要介绍了设计模式的六大原则，并结合实例描述了各种单例模式的具体实现和性能分析测试。包括：饿汉式、静态内部类、懒汉式、双重校验锁、枚举等。 设计模式系列文章 Java23种设计模式 1. 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 2、里氏代换原则（Liskov Substitution Principle） 其官方描述比较抽象，可自行百度。实际上可以这样理解： （1）子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。 （2）返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。 （3）还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。而不能声明抛出父类没有声明的异常。 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 Java 中一般认为有 23 种设计模式，总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录 模式、状态模式、访问者模式、中介者模式、解释器模式。 比较常用的有：工厂方法模式、抽象工厂模式、单例模式、建造者模式、适配器模式、代理模式、享元模式、策略模式、观察者模式。 2. 单例模式2.1 单利模式介绍作用：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 应用场景： 1.配置文件访问类，不用每次使用时都new一个 2.数据库连接池 保证项目中只有一个连接池存在。 2.2 单利模式实现1. 饿汉式12345678910111213public class Singleton &#123; //类变量在类准备阶段就初始化了然后放在&lt;clinit&gt;构造方法中 //一旦外部调用了静态方法，那么就会初始化完成。 //一个类的&lt;clinit&gt;只会执行一次 private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 这种方式实现的单例：类加载时就创建实例。由classloder保证了线程安全。 2. 静态内部类1234567891011121314public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 这种方式实现的单例：实现了lazy loading 使用时才创建实例，由classloder保证了线程安全。 饿汉式/静态内部类是如何保证线程安全的： 在《深入理解JAVA虚拟机》中，有这么一句话: 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。 3. 懒汉式12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种方式实现的单例：实现了lazy loading 使用时才创建实例。synchronized保证了线程安全，但效率低。 4. 双重校验锁1234567891011121314151617181920212223public class Singleton &#123; private static volatile Singleton singleton; private Singleton() &#123; &#125; public static Singleton singleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton();//非原子操作 &#125; &#125; &#125; return singleton; &#125;&#125;//singleton = new Singleton(); 非原子操作 分为三步// 1.给singleton分配内存// 2.调用 Singleton 的构造函数来初始化成员变量// 3.将给singleton对象指向分配的内存空间（此时singleton才不为null）// 指令重排序--&gt;执行命令时虚拟机可能会对以上3个步骤交换位置 最后可能是132这种 分配内存并修改指针后未初始化 多线程获取时可能会出现问题。//volatile关键字会禁止指令重排序 即可避免这种问题。 这种方式实现的单例：实现了lazy loading 使用时才创建实例。synchronized保证了线程安全，volatile禁止指令重排序保证了多线程获取时不为空。但要JDK1.5以上才行。 5. 枚举12345678910111213141516public enum Singleton &#123; //定义一个枚举的元素，它就是 Singleton 的一个实例 INSTANCE; public void doSomeThing() &#123; System.out.println("枚举方法实现单例"); &#125; &#125;public class Test &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.INSTANCE; singleton.doSomeThing();//output:枚举方法实现单例 &#125;&#125; 这种方式也是《Effective Java 》以及《Java与模式》的作者推荐的方式，不过工作中却很少看到用。 3. 性能测试五种单例实现方式，在100个线程下，每个线程访问1千万次实例的用时. Tables 实现方式 用时(毫秒) 1 饿汉式 13 2 懒汉式 10778 3 双重检查 15 4 静态内部类 14 5 枚举 12 (*注意:由于不同电脑之间的性能差异，测试的结果可能不同) 根据不同场合选择具体的实现方式，一般情况下我是使用的静态内部类或者DCL双重校验锁方式。 4. 总结为什么要使用单例模式？什么场景适合使用单例模式?单例模式有什么好处 1.单例模式能够保证一个类仅有唯一的实例，避免创建多个实例。并提供一个全局访问点，优化和共享资源访问。 2.当一个对象需要频繁创建和销毁时使用单例模式能节省系统资源。 应用场景： 1.配置文件访问类，不用每次使用时都new一个 2.数据库连接池 保证项目中只有一个连接池存在。 单例模式的缺点： 单例模式一般没有接口，扩展很困难，若要扩展只能修改代码。 单例模式在Java中的应用 1234567891011121314151617181920public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don't let anyone else instantiate this class */ private Runtime() &#123;&#125; ...&#125; 5. 参考单例模式性能分析]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 配置及SSH key及使用]]></title>
    <url>%2Fposts%2F49894.html</url>
    <content type="text"><![CDATA[​ 本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以配置SSH key之后，上传代码到Github远程仓库时就不用输入密码了。一般是在C盘用户目录下有一个 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。连接时必须提供一个公钥用于授权，没有的话就要生成一个。 1. Git 配置配置全局用户名和密码，git提交代码时用来显示你身份和联系方式，并不是github用户名和邮箱 12git config --global user.name "lillusory" //改成自己的git config --global user.email "xueduanli@163.com" //改成自己的 2. 生成SSH key2.1 生成秘钥 执行ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; 命令 生成ssh key 然后会叫你输入保存路径，直接按回车即可，保存在C盘用户目录下 然后会提示输入密码和确认密码，不用输入直接按两下回车即可 到这里SSH key就生成好了，接下来就是配置到github上。 2.2 配置SSH key 登陆Github–&gt;点击头像–&gt;Settings–&gt;SSH and GPG keys–&gt;选择SSh keys上的New SSH keys–&gt;name 随便写，key就是刚才生成的文件中的所有内容。 文件默认是在C盘用户目录下，我的是C:\Users\13452\.ssh 文件夹中应该会有两个文件 ：id_rsa和id_rsa.pub id_rsa.pub就是我们要的key, 一般以ssh-rsa开头，以你刚才输的邮箱结尾。 2.3 测试执行ssh -T git@github.com命令验证一下。 可能会提示，无法验证主机的真实性是否要建立连接，输入yes就行了。 如果，看到： Hi xxx! You’ve successfully authenticated, but GitHub does not # provide shell access. 恭喜你，你的设置已经成功了。 3. 参考Git Book]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
