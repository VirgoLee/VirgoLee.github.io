<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/myimages/favicon-32x32-me.png?v=6.6.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/myfavicon-32x32-me.png?v=6.6.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/myfavicon-16x16-me.png?v=6.6.0"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.6.0",sidebar:{position:"right",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><meta name="description" content="本文主要通过源码详细分析了 SpringMVC 框架的执行流程，包括建立 url 和 controller 的关系，通过 url 找到具体的方法，通过反射执行 controller 中的方法等。"><meta name="keywords" content="SpringMVC"><meta property="og:type" content="article"><meta property="og:title" content="SpringMVC系列(一)---执行流程分析"><meta property="og:url" content="https://www.lixueduan.com/posts/cf395c14.html"><meta property="og:site_name" content="幻境云图"><meta property="og:description" content="本文主要通过源码详细分析了 SpringMVC 框架的执行流程，包括建立 url 和 controller 的关系，通过 url 找到具体的方法，通过反射执行 controller 中的方法等。"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-04-17T14:01:40.677Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="SpringMVC系列(一)---执行流程分析"><meta name="twitter:description" content="本文主要通过源码详细分析了 SpringMVC 框架的执行流程，包括建立 url 和 controller 的关系，通过 url 找到具体的方法，通过反射执行 controller 中的方法等。"><link rel="alternate" href="/atom.xml" title="幻境云图" type="application/atom+xml"><link rel="canonical" href="https://www.lixueduan.com/posts/cf395c14.html"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>SpringMVC系列(一)---执行流程分析 | 幻境云图</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-131397277-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-131397277-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?2765db46fe986fa867d3cb9e87afdd69";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">幻境云图</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">有道无术，术尚可求，有术无道，止于术</h1></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lixueduan.com/posts/cf395c14.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="illusoryCloud"><meta itemprop="description" content="幻境云图是一个专注于Java技术分享的博客,记录了一个菜鸟从0开始的Java进阶之路。主要涉及Java知识共享、实践教程、前沿技术共同学习等。包括但不限于Java基础,数据库优化,Spring框架,源码分析,分布式,微服务,并发编程等"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="幻境云图"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">SpringMVC系列(一)---执行流程分析</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-04-02 22:00:00" itemprop="dateCreated datePublished" datetime="2019-04-02T22:00:00+08:00">2019-04-02</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-04-17 22:01:40" itemprop="dateModified" datetime="2019-04-17T22:01:40+08:00">2019-04-17</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/SpringMVC/" itemprop="url" rel="index"><span itemprop="name">SpringMVC</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span title="本文字数">44k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">40 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要通过源码详细分析了 SpringMVC 框架的执行流程，包括建立 url 和 controller 的关系，通过 url 找到具体的方法，通过反射执行 controller 中的方法等。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-Servlet-执行流程"><a href="#1-Servlet-执行流程" class="headerlink" title="1. Servlet 执行流程"></a>1. Servlet 执行流程</h2><p>传统servlet的执行过程分为如下几步：<br>1、浏览器向服务器发送请求<code>http://localhost:8080/demo/hello</code><br>2、服务器接受到请求，并从地址中得到项目名称<code>webproject</code><br>3、然后再从地址中找到名称<code>hello</code>，并与<code>webproject</code>下的<code>web.xml</code>文件进行匹配<br>4、在<code>web.xml</code>中找到一个<code>&lt;url-pattern&gt;hello&lt;/url-pattern&gt;</code>的标签，并且通过他找到<code>servlet-name</code>进而找到<code>&lt;servlet-class&gt;</code><br>5、再拿到<code>servlet-class</code>之后，这个服务器便知道了这个<code>servlet</code>的全类名，通过<code>反射</code>创建这个类的对象，并且调用<code>doGet/doPost</code>方法</p><p>6、方法执行完毕，结果返回到浏览器。结束。</p><h2 id="2-SpringMVC-执行流程"><a href="#2-SpringMVC-执行流程" class="headerlink" title="2. SpringMVC 执行流程"></a>2. SpringMVC 执行流程</h2><p>SpringMVC 中也配置了一个 Servlet,配置的是 org.springframework.web.servlet.DispatcherServlet，所有的请求过来都会找这个 servlet (前端控制器)，DispatcherServlet 继承了 HttpServlet。</p><h3 id="运行过程分析"><a href="#运行过程分析" class="headerlink" title="运行过程分析"></a>运行过程分析</h3><p>1、 用户发送请求至前端控制器<code>DispatcherServlet</code>。</p><p>2、 <code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code>处理器映射器。</p><p>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)<code>HandlerExcutorChain</code>并返回给 DispatcherServlet。</p><p>4、 <code>DispatcherServlet</code>调用<code>HandlerAdapter</code>处理器适配器。</p><p>5、 <code>HandlerAdapter</code>经过适配调用具体的处理器(就是我们写的 Controller )。</p><p>6、 <code>Controller</code>执行完成返回<code>ModelAndView</code>。</p><p>7、 <code>HandlerAdapter</code>将 Controller 执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code>。</p><p>8、 <code>DispatcherServlet</code>将 ModelAndView 传给<code>ViewReslover</code>视图解析器。</p><p>9、 <code>ViewReslover</code>解析后返回具体<code>View</code>(这就是为什么<code>reurn &quot;index&quot;</code>会自动找到 index.html)</p><p>10、<code>DispatcherServle</code>t根据<code>View</code>进行渲染视图（即将模型数据填充至视图中）。</p><p>11、 DispatcherServlet响应用户。</p><h2 id="3-具体过程分析"><a href="#3-具体过程分析" class="headerlink" title="3. 具体过程分析"></a>3. 具体过程分析</h2><h3 id="1-建立-Map-lt-urls-Controller-gt-的关系"><a href="#1-建立-Map-lt-urls-Controller-gt-的关系" class="headerlink" title="1. 建立 Map&lt;urls,Controller&gt; 的关系"></a>1. 建立 Map&lt;urls,Controller&gt; 的关系</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在容器初始化时会建立所有<code>url</code> 和 <code>controller</code>的对应关系,保存到<code>Map&lt;url,controller&gt;</code>中。</p><p><code>DispatcherServlet--&gt;initApplicationContext</code>初始化容器 建立<code>Map&lt;url,controller&gt;</code>关系的部分</p><p>Tomcat启动时会通知 Spring 初始化容器(加载 bean 的定义信息和初始化所有单例 bean ),然后 SpringMVC 会遍历容器中的bean,获取每一个 Controller 中的所有方法访问的 url,然后将 url和 Controller 保存到一个 Map 中;</p><h3 id="2-根据访问url-找到对应-Controller-中处理请求的方法"><a href="#2-根据访问url-找到对应-Controller-中处理请求的方法" class="headerlink" title="2.根据访问url 找到对应 Controller 中处理请求的方法"></a>2.根据访问url 找到对应 Controller 中处理请求的方法</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><code>DispatcherServlet--&gt;doDispatch()</code></p><p>有了前面的 Map 就可以根据 Request快速定位到 Controller,因为最终处理 Request 的是 Controller 中的方法,Map 中只保留了 url 和 Controller 中的对应关系,所以要根据 Request 的 url 进一步确认 Controller 中的 Method.</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>这一步工作的原理就是拼接 Controller 的 url(controller上@RequestMapping的值) 和方法的 url(method 上@RequestMapping的值),与 Request 的 url 进行匹配,找到匹配的那个方法;　　</p><h3 id="3-参数绑定"><a href="#3-参数绑定" class="headerlink" title="3. 参数绑定"></a>3. 参数绑定</h3><p>确定处理请求的 Method 后,接下来的任务就是参数绑定,把 Request 中参数绑定到方法的形式参数上,这一步是整个请求处理过程中最复杂的一个步骤。SpringMVC 提供了两种 Request 参数与方法形参的绑定方法:</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>使用注解进行绑定,我们只要在方法参数前面声明 <code>@RequestParam(&quot;a&quot;)</code>,就可以将 <code>Request</code> 中参数 <code>a</code> 的值绑定到方法的该参数上。</p><h4 id="参数名称"><a href="#参数名称" class="headerlink" title="参数名称"></a>参数名称</h4><p>使用参数名称进行绑定的前提是必须要获取方法中参数的名称,Java 反射只提供了获取方法的参数的类型,并没有提供获取参数名称的方法。SpringMVC 解决这个问题的方法是用 asm 框架读取字节码文件,来获取方法的参数名称。asm 框架是一个字节码操作框架,关于a sm 更多介绍可以参考它的官网。</p><p>个人建议,使用注解来完成参数绑定,这样就可以省去 asm 框架的读取字节码的操作。</p><h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h2><h3 id="1-建立Map-lt-url-controller-gt-的关系"><a href="#1-建立Map-lt-url-controller-gt-的关系" class="headerlink" title="1. 建立Map&lt;url,controller&gt;的关系"></a>1. 建立Map&lt;url,controller&gt;的关系</h3><p>我们首先看第一个步骤,也就是建立<code>Map&lt;url,controller&gt;</code>关系的部分.第一部分的入口类<code>ApplicationObjectSupport</code>的<code>setApplicationContext</code>方法.<code>setApplicationContext</code>方法中核心部分就是初始化容器<code>initApplicationContext(context)</code>,子类<code>AbstractDetectingUrlHandlerMapping</code>实现了该方法,所以我们直接看子类中的初始化容器方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ApplicationObjectSupport类</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(@Nullable ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (context == <span class="keyword">null</span> &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">			<span class="comment">// Reset internal context state.</span></span><br><span class="line">			<span class="keyword">this</span>.applicationContext = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Initialize with passed-in context.</span></span><br><span class="line">			<span class="keyword">if</span> (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">						<span class="string">"Invalid application context: needs to be of type ["</span> + requiredContextClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.applicationContext = context;</span><br><span class="line">			<span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">new</span> MessageSourceAccessor(context);</span><br><span class="line">			initApplicationContext(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Ignore reinitialization if same context passed in.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != context) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">						<span class="string">"Cannot reinitialize with different application context: current one is ["</span> +</span><br><span class="line">						<span class="keyword">this</span>.applicationContext + <span class="string">"], passed-in one is ["</span> + context + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>其中<code>initApplicationContext(context)</code>由子类<code>AbstractDetectingUrlHandlerMapping</code>实现,具体如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Calls the &#123;<span class="doctag">@link</span> #detectHandlers()&#125; method in addition to the</span></span><br><span class="line"><span class="comment">	 * superclass's initialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">		detectHandlers();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 建立当前ApplicationContext中的所有controller和url的对应关系</span></span><br><span class="line"><span class="comment">	 * Register all handlers found in the current ApplicationContext.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The actual URL determination for a handler is up to the concrete</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> #determineUrlsForHandler(String)&#125; implementation. A bean for</span></span><br><span class="line"><span class="comment">	 * which no such URLs could be determined is simply not considered a handler.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException if the handler couldn't be registered</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #determineUrlsForHandler(String)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line">		String[] beanNames = (<span class="keyword">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">				BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">				applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line">        <span class="comment">// 获取ApplicationContext容器中所有bean的Name</span></span><br><span class="line">		<span class="comment">// Take any bean name that we can determine URLs for.</span></span><br><span class="line">		<span class="comment">// 遍历beanNames,并找到这些bean对应的url</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		     <span class="comment">// 找bean上的所有url(controller上的url+方法上的url),该方法由对应的子类实现</span></span><br><span class="line">			String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">				<span class="comment">// URL paths found: Let's consider it a handler.</span></span><br><span class="line">				<span class="comment">// 保存urls和beanName的对应关系,put it to Map&lt;urls,beanName&gt;,该方法在父类AbstractUrlHandlerMapping中实现</span></span><br><span class="line">				registerHandler(urls, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((logger.isDebugEnabled() &amp;&amp; !getHandlerMap().isEmpty()) || logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Detected "</span> + getHandlerMap().size() + <span class="string">" mappings in "</span> + formatMappingName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;       </span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * Determine the URLs for the given handler bean.</span></span><br><span class="line"><span class="comment">    	 * <span class="doctag">@param</span> beanName the name of the candidate bean</span></span><br><span class="line"><span class="comment">    	 * <span class="doctag">@return</span> the URLs determined for the bean, or an empty array if none</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">		    <span class="comment">/** 获取controller中所有方法的url,由子类实现,典型的模板模式 **/</span></span><br><span class="line">    	<span class="keyword">protected</span> <span class="keyword">abstract</span> String[] determineUrlsForHandler(String beanName);</span><br></pre></td></tr></table></figure><p></p><p><code>determineUrlsForHandler(String beanName)</code>方法的作用是获取每个<code>Controller</code>中的<code>url</code>,不同的子类有不同的实现,这是一个典型的模板设计模式.因为开发中我们用的最多的就是用注解来配置<code>Controller`</code>中的url<code>,</code>BeanNameUrlHandlerMapping<code>是</code>AbstractDetectingUrlHandlerMapping<code>的子类,我们看</code>BeanNameUrlHandlerMapping<code>是如何查</code>beanName<code>上所有映射的</code>url`.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanNameUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractDetectingUrlHandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Checks name and aliases of the given bean for URLs, starting with "/".</span></span><br><span class="line"><span class="comment">	 * 找出名字或者别名是以 / 开头的bean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">		List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (beanName.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			urls.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliases = obtainApplicationContext().getAliases(beanName);</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alias.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">				urls.add(alias);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-根据访问url找到对应controller中处理请求的方法"><a href="#2-根据访问url找到对应controller中处理请求的方法" class="headerlink" title="2. 根据访问url找到对应controller中处理请求的方法"></a>2. 根据访问url找到对应controller中处理请求的方法</h3><p>下面我们开始分析第二个步骤,第二个步骤是由请求触发的,所以入口为<code>DispatcherServlet.DispatcherServlet</code>的核心方法为<code>doService()</code>,<code>doService()</code>中的核心逻辑由<code>doDispatch()</code>实现,我们查看<code>doDispatch()</code>的源代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order.</span></span><br><span class="line"><span class="comment"> * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters</span></span><br><span class="line"><span class="comment"> * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment"> * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 中央控制器,控制请求的转发 **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   HttpServletRequest processedRequest = request;</span><br><span class="line">   HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">      Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 1.检查是否是文件上传的请求</span></span><br><span class="line">         processedRequest = checkMultipart(request);</span><br><span class="line">         multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">         <span class="comment">// 2.取得处理当前请求的controller,这里也称为hanlder,处理器</span></span><br><span class="line">         <span class="comment">// 第一个步骤的意义就在这里体现了.这里并不是直接返回controller,</span></span><br><span class="line">         <span class="comment">// 而是返回的HandlerExecutionChain请求处理器链对象,</span></span><br><span class="line">         <span class="comment">// 该对象封装了handler和interceptors.</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">         <span class="comment">//3. 获取处理request的处理器适配器handler adapter </span></span><br><span class="line">         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">         <span class="comment">// 处理 last-modified 请求头</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">         <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">			 <span class="comment">// 4.拦截器的预处理方法</span></span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">          <span class="comment">// 5.实际的处理器处理请求,返回结果视图对象</span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">		 <span class="comment">// 结果视图对象的处理</span></span><br><span class="line">         applyDefaultViewName(processedRequest, mv);</span><br><span class="line">         <span class="comment">// 6.拦截器的后处理方法</span></span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">         <span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">         <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">         dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//将结果解析为ModelAndView</span></span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="comment">// 请求成功响应之后的方法</span></span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">            <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">         <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步:<code>getHandler(processedRequest)</code>方法实际上就是从<code>HandlerMapping</code>中找到<code>url</code>和<code>Controller</code>的对应关系.这也就是第一个步骤:建立<code>Map&lt;url,Controller&gt;</code>的意义.我们知道,最终处理<code>Request</code>的是<code>Controller</code>中的方法,我们现在只是知道了<code>Controller</code>,还要进一步确认<code>Controller</code>中处理<code>Request</code>的方法.由于下面的步骤和第三个步骤关系更加紧密,直接转到第三个步骤.</p><h3 id="3-反射调用处理请求的方法-返回结果视图"><a href="#3-反射调用处理请求的方法-返回结果视图" class="headerlink" title="3. 反射调用处理请求的方法,返回结果视图"></a>3. 反射调用处理请求的方法,返回结果视图</h3><p>上面的方法中,第2步其实就是从第一个步骤中的<code>Map&lt;urls,beanName&gt;</code>中取得<code>Controller</code>,然后经过拦截器的预处理方法,到最核心的部分–第5步调用<code>Controller</code>的方法处理请求.在第2步中我们可以知道处理<code>Request</code>的<code>Controller</code>,第5步就是要根据<code>url</code>确定<code>Controller</code>中处理请求的方法,然后通过反射获取该方法上的注解和参数,解析方法和参数上的注解,最后反射调用方法获取<code>ModelAndView</code>结果视图。</p><p>第5步调用的就是<code>RequestMappingHandlerAdapter</code>的<code>handle().handle()</code>中的核心逻辑由<code>invokeHandlerMethod(request, response, handler)</code>实现。</p><blockquote><p>handle().handle()–&gt;handleInternal(request, response, (HandlerMethod) handler)–&gt;invokeHandlerMethod(request, response, handlerMethod)</p></blockquote><p><code>RequestMappingHandlerAdapter类</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Invoke the &#123;<span class="doctag">@link</span> RequestMapping&#125; handler method preparing a &#123;<span class="doctag">@link</span> ModelAndView&#125;</span></span><br><span class="line"><span class="comment">	 * if view resolution is required.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #createInvocableHandlerMethod(HandlerMethod)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">			ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">			<span class="comment">//创建invocableMetho</span></span><br><span class="line">			ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">				invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">				invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">			&#125;</span><br><span class="line">			invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">			invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">			ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">			mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">			modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">			mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">			AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">			asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">			WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">			asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">			asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">			asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">			asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">				Object result = asyncManager.getConcurrentResult();</span><br><span class="line">				mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">				asyncManager.clearConcurrentResult();</span><br><span class="line">				LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">					String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">					<span class="keyword">return</span> <span class="string">"Resume with async result ["</span> + formatted + <span class="string">"]"</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">				invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//执行ServletInvocableHandlerMethod的invokeAndHandle方法		</span></span><br><span class="line">			invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 封装结果视图</span></span><br><span class="line">			<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			webRequest.requestCompleted();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p><code>invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</code>为参数绑定，后面说</p><p>其中<code>invokeAndHandle</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the method and handle the return value through one of the</span></span><br><span class="line"><span class="comment"> * configured &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type (not resolved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">		Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//执行请求对应的方法，并获得返回值</span></span><br><span class="line">	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">	setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">"No return value handlers"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">				returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeForRequest</code>中的操作也是比较简单的，首先获取<code>request</code>中的参数，然后调用<code>doInvoke(args)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//首先会获取请求的参数，其实就是Controller方法中的参数</span></span><br><span class="line">		Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Arguments: "</span> + Arrays.toString(args));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//调用Controller中的方法</span></span><br><span class="line">		<span class="keyword">return</span> doInvoke(args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p><code>doInvoke</code>方法是在<code>InvocableHandlerMethod`</code>类中，最重要的是调用getBridgedMethod().invoke(getBean(),args)<code>，通过反射机制完成对</code>Controller`中的函数的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvocableHandlerMethod类	</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//反射之前 取消Java的权限控制检查</span></span><br><span class="line">		ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//通过执行controller中的方法</span></span><br><span class="line">			<span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">			assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">			String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">"Illegal argument"</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(text, args), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">			<span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">			Throwable targetException = ex.getTargetException();</span><br><span class="line">			<span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(<span class="string">"Invocation failure"</span>, args), targetException);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p> <strong>注</strong>：桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。</p><p>反正最终就是通过反射来调用<code>Controller</code>中的方法。</p><h3 id="4-参数绑定"><a href="#4-参数绑定" class="headerlink" title="4. 参数绑定"></a>4. 参数绑定</h3><p>resolveHandlerArguments方法实现代码比较长,它最终要实现的目的就是:完成request中的参数和方法参数上数据的绑定.</p><p>springmvc中提供两种request参数到方法中参数的绑定方式:</p><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>使用注解进行绑定,我们只要在方法参数前面声明 <code>@RequestParam(&quot;a&quot;)</code>,就可以将 <code>Request</code> 中参数 <code>a</code> 的值绑定到方法的该参数上。</p><h4 id="参数名称-1"><a href="#参数名称-1" class="headerlink" title="参数名称"></a>参数名称</h4><p>使用参数名称进行绑定的前提是必须要获取方法中参数的名称,Java 反射只提供了获取方法的参数的类型,并没有提供获取参数名称的方法。SpringMVC 解决这个问题的方法是用 asm 框架读取字节码文件,来获取方法的参数名称。asm 框架是一个字节码操作框架,关于a sm 更多介绍可以参考它的官网。</p><p>个人建议,使用注解来完成参数绑定,这样就可以省去 asm 框架的读取字节码的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] resolveHandlerArguments(Method handlerMethod, Object handler,</span><br><span class="line">            NativeWebRequest webRequest, ExtendedModelMap implicitModel) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">　　　　 <span class="comment">// 1.获取方法参数类型的数组</span></span><br><span class="line">        Class[] paramTypes = handlerMethod.getParameterTypes();</span><br><span class="line">　　　　<span class="comment">// 声明数组,存参数的值</span></span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[paramTypes.length];</span><br><span class="line">　　　　<span class="comment">//2.遍历参数数组,获取每个参数的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            MethodParameter methodParam = <span class="keyword">new</span> MethodParameter(handlerMethod, i);</span><br><span class="line">            methodParam.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">            GenericTypeResolver.resolveParameterType(methodParam, handler.getClass());</span><br><span class="line">            String paramName = <span class="keyword">null</span>;</span><br><span class="line">            String headerName = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> requestBodyFound = <span class="keyword">false</span>;</span><br><span class="line">            String cookieName = <span class="keyword">null</span>;</span><br><span class="line">            String pathVarName = <span class="keyword">null</span>;</span><br><span class="line">            String attrName = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line">            String defaultValue = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validate = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> annotationsFound = <span class="number">0</span>;</span><br><span class="line">            Annotation[] paramAnns = methodParam.getParameterAnnotations();</span><br><span class="line">　　　　　　 <span class="comment">// 处理参数上的注解</span></span><br><span class="line">            <span class="keyword">for</span> (Annotation paramAnn : paramAnns) &#123;</span><br><span class="line">                <span class="keyword">if</span> (RequestParam.class.isInstance(paramAnn)) &#123;</span><br><span class="line">                    RequestParam requestParam = (RequestParam) paramAnn;</span><br><span class="line">                    paramName = requestParam.value();</span><br><span class="line">                    required = requestParam.required();</span><br><span class="line">                    defaultValue = parseDefaultValueAttribute(requestParam.defaultValue());</span><br><span class="line">                    annotationsFound++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (RequestHeader.class.isInstance(paramAnn)) &#123;</span><br><span class="line">                    RequestHeader requestHeader = (RequestHeader) paramAnn;</span><br><span class="line">                    headerName = requestHeader.value();</span><br><span class="line">                    required = requestHeader.required();</span><br><span class="line">                    defaultValue = parseDefaultValueAttribute(requestHeader.defaultValue());</span><br><span class="line">                    annotationsFound++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (RequestBody.class.isInstance(paramAnn)) &#123;</span><br><span class="line">                    requestBodyFound = <span class="keyword">true</span>;</span><br><span class="line">                    annotationsFound++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (CookieValue.class.isInstance(paramAnn)) &#123;</span><br><span class="line">                    CookieValue cookieValue = (CookieValue) paramAnn;</span><br><span class="line">                    cookieName = cookieValue.value();</span><br><span class="line">                    required = cookieValue.required();</span><br><span class="line">                    defaultValue = parseDefaultValueAttribute(cookieValue.defaultValue());</span><br><span class="line">                    annotationsFound++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (PathVariable.class.isInstance(paramAnn)) &#123;</span><br><span class="line">                    PathVariable pathVar = (PathVariable) paramAnn;</span><br><span class="line">                    pathVarName = pathVar.value();</span><br><span class="line">                    annotationsFound++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ModelAttribute.class.isInstance(paramAnn)) &#123;</span><br><span class="line">                    ModelAttribute attr = (ModelAttribute) paramAnn;</span><br><span class="line">                    attrName = attr.value();</span><br><span class="line">                    annotationsFound++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Value.class.isInstance(paramAnn)) &#123;</span><br><span class="line">                    defaultValue = ((Value) paramAnn).value();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Valid"</span>.equals(paramAnn.annotationType().getSimpleName())) &#123;</span><br><span class="line">                    validate = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">　　</span><br><span class="line">            <span class="keyword">if</span> (annotationsFound &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Handler parameter annotations are exclusive choices - "</span> +</span><br><span class="line">                        <span class="string">"do not specify more than one such annotation on the same parameter: "</span> + handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotationsFound == <span class="number">0</span>) &#123;<span class="comment">// 如果没有注解</span></span><br><span class="line">                Object argValue = resolveCommonArgument(methodParam, webRequest);</span><br><span class="line">                <span class="keyword">if</span> (argValue != WebArgumentResolver.UNRESOLVED) &#123;</span><br><span class="line">                    args[i] = argValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    args[i] = resolveDefaultValue(defaultValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Class paramType = methodParam.getParameterType();</span><br><span class="line">　　　　　　　　　　  <span class="comment">// 将方法声明中的Map和Model参数,放到request中,用于将数据放到request中带回页面</span></span><br><span class="line">                    <span class="keyword">if</span> (Model.class.isAssignableFrom(paramType) || Map.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">                        args[i] = implicitModel;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (SessionStatus.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">                        args[i] = <span class="keyword">this</span>.sessionStatus;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (HttpEntity.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">                        args[i] = resolveHttpEntityRequest(methodParam, webRequest);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Errors.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Errors/BindingResult argument declared "</span> +</span><br><span class="line">                                <span class="string">"without preceding model attribute. Check your handler method signature!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (BeanUtils.isSimpleProperty(paramType)) &#123;</span><br><span class="line">                        paramName = <span class="string">""</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        attrName = <span class="string">""</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　　<span class="comment">// 从request中取值,并进行赋值操作</span></span><br><span class="line">            <span class="keyword">if</span> (paramName != <span class="keyword">null</span>) &#123;</span><br><span class="line">　　　　　　　　　<span class="comment">// 根据paramName从request中取值,如果没有通过RequestParam注解指定paramName,则使用asm读取class文件来获取paramName</span></span><br><span class="line">                args[i] = resolveRequestParam(paramName, required, defaultValue, methodParam, webRequest, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (headerName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                args[i] = resolveRequestHeader(headerName, required, defaultValue, methodParam, webRequest, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requestBodyFound) &#123;</span><br><span class="line">                args[i] = resolveRequestBody(methodParam, webRequest, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cookieName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                args[i] = resolveCookieValue(cookieName, required, defaultValue, methodParam, webRequest, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pathVarName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                args[i] = resolvePathVariable(pathVarName, methodParam, webRequest, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (attrName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                WebDataBinder binder =</span><br><span class="line">                        resolveModelAttribute(attrName, methodParam, implicitModel, webRequest, handler);</span><br><span class="line">                <span class="keyword">boolean</span> assignBindingResult = (args.length &gt; i + <span class="number">1</span> &amp;&amp; Errors.class.isAssignableFrom(paramTypes[i + <span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">if</span> (binder.getTarget() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    doBind(binder, webRequest, validate, !assignBindingResult);</span><br><span class="line">                &#125;</span><br><span class="line">                args[i] = binder.getTarget();</span><br><span class="line">                <span class="keyword">if</span> (assignBindingResult) &#123;</span><br><span class="line">                    args[i + <span class="number">1</span>] = binder.getBindingResult();</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                implicitModel.putAll(binder.getBindingResult().getModel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　 <span class="comment">// 返回参数值数组</span></span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-反射源码分析"><a href="#5-反射源码分析" class="headerlink" title="5. 反射源码分析"></a>5. 反射源码分析</h3><p>反射相关分析来源于：<code>http://www.sczyh30.com/posts/Java/java-reflection-2/</code></p><p>第三步中的<code>invoke</code>方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">    <span class="comment">//quickCheckMemberAccess 检查方法是否为public 如果是的话跳出本步</span></span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">        <span class="comment">//如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:</span></span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getCallerClass()是一个native方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getCallerClass();</span><br></pre></td></tr></table></figure><p>在OpenJDK的源码中找到此方法的JNI入口(Reflection.c):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jclass JNICALL Java_sun_reflect_Reflection_getCallerClass__</span><br><span class="line">(JNIEnv *env, jclass unused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_GetCallerClass(env, JVM_CALLER_DEPTH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验，其实现为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Object securityCheckCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (caller == clazz) &#123;  <span class="comment">// 快速校验</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// 权限通过校验</span></span><br><span class="line">        &#125;</span><br><span class="line">        Object cache = securityCheckCache;  <span class="comment">// read volatile</span></span><br><span class="line">        Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; Modifier.isProtected(modifiers)</span><br><span class="line">            &amp;&amp; ((targetClass = obj.getClass()) != clazz)) &#123;</span><br><span class="line">            <span class="comment">// Must match a 2-list of &#123; caller, targetClass &#125;.</span></span><br><span class="line">            <span class="keyword">if</span> (cache <span class="keyword">instanceof</span> Class[]) &#123;</span><br><span class="line">                Class&lt;?&gt;[] cache2 = (Class&lt;?&gt;[]) cache;</span><br><span class="line">                <span class="keyword">if</span> (cache2[<span class="number">1</span>] == targetClass &amp;&amp;</span><br><span class="line">                    cache2[<span class="number">0</span>] == caller) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;     <span class="comment">// ACCESS IS OK</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (Test cache[1] first since range check for [1]</span></span><br><span class="line">                <span class="comment">// subsumes range check for [0].)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache == caller) &#123;</span><br><span class="line">            <span class="comment">// Non-protected case (or obj.class == this.clazz).</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// ACCESS IS OK</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If no return, fall through to the slow path.</span></span><br><span class="line">        slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先先执行一次快速校验，一旦调用方法的Class正确则权限检查通过。<br>若未通过，则创建一个缓存，中间再进行一堆检查（比如检验是否为protected属性）。<br>如果上面的所有权限检查都未通过，那么将执行更详细的检查，其实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep all this slow stuff out of line:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slowCheckMemberAccess</span><span class="params">(Class&lt;?&gt; caller, Class&lt;?&gt; clazz, Object obj, <span class="keyword">int</span> modifiers,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Class&lt;?&gt; targetClass)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Success: Update the cache.</span></span><br><span class="line">    Object cache = ((targetClass == clazz)</span><br><span class="line">                    ? caller</span><br><span class="line">                    : <span class="keyword">new</span> Class&lt;?&gt;[] &#123; caller, targetClass &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  The two cache elements are not volatile,</span></span><br><span class="line">    <span class="comment">// but they are effectively final.  The Java memory model</span></span><br><span class="line">    <span class="comment">// guarantees that the initializing stores for the cache</span></span><br><span class="line">    <span class="comment">// elements will occur before the volatile write.</span></span><br><span class="line">    securityCheckCache = cache;         <span class="comment">// write volatile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体意思就是，用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。由于JMM的happens-before规则能够保证缓存初始化能够在写缓存之前发生，因此两个cache不需要声明为volatile。<br>到这里，前期的权限检查工作就结束了。如果没有通过检查则会抛出异常，如果通过了检查则会到下一步。</p><h4 id="调用MethodAccessor的invoke方法"><a href="#调用MethodAccessor的invoke方法" class="headerlink" title="调用MethodAccessor的invoke方法"></a>调用MethodAccessor的invoke方法</h4><p>Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。<br>首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。root对象其声明及注释为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> MethodAccessor methodAccessor;</span><br><span class="line"><span class="comment">// For sharing of MethodAccessors. This branching structure is</span></span><br><span class="line"><span class="comment">// currently only two levels deep (i.e., one root Method and</span></span><br><span class="line"><span class="comment">// potentially many Method objects pointing to it.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If this branching structure would ever contain cycles, deadlocks can</span></span><br><span class="line"><span class="comment">// occur in annotation code.</span></span><br><span class="line"><span class="keyword">private</span> Method  root;</span><br></pre></td></tr></table></figure><p>那么MethodAccessor到底是个啥玩意呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This interface provides the declaration for</span></span><br><span class="line"><span class="comment">    java.lang.reflect.Method.invoke(). Each Method object is</span></span><br><span class="line"><span class="comment">    configured with a (possibly dynamically-generated) class which</span></span><br><span class="line"><span class="comment">    implements this interface.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到MethodAccessor是一个接口，定义了invoke方法。分析其Usage可得它的具体实现类有:</p><ul><li>sun.reflect.DelegatingMethodAccessorImpl</li><li>sun.reflect.MethodAccessorImpl</li><li>sun.reflect.NativeMethodAccessorImpl</li></ul><p>第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建；等第一次调用时才新创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOTE that there is no synchronization used here. It is correct</span></span><br><span class="line"><span class="comment">// (though not efficient) to generate more than one MethodAccessor</span></span><br><span class="line"><span class="comment">// for a given Method. However, avoiding synchronization will</span></span><br><span class="line"><span class="comment">// probably make the implementation more scalable.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflection factory used by subclasses for creating field,</span></span><br><span class="line"><span class="comment">// method, and constructor accessors. Note that this is called</span></span><br><span class="line"><span class="comment">// very early in the bootstrapping process.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ReflectionFactory reflectionFactory =</span><br><span class="line">    AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> sun.reflect.ReflectionFactory.GetReflectionFactoryAction());</span><br></pre></td></tr></table></figure><p>再研究一下sun.reflect.ReflectionFactory类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Permission reflectionFactoryAccessPerm</span><br><span class="line">        = <span class="keyword">new</span> RuntimePermission(<span class="string">"reflectionFactoryAccess"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReflectionFactory soleInstance = <span class="keyword">new</span> ReflectionFactory();</span><br><span class="line">    <span class="comment">// Provides access to package-private mechanisms in java.lang.reflect</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LangReflectAccess langReflectAccess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里设计得非常巧妙</span></span><br><span class="line">    <span class="comment">// "Inflation" mechanism. Loading bytecodes to implement</span></span><br><span class="line">    <span class="comment">// Method.invoke() and Constructor.newInstance() currently costs</span></span><br><span class="line">    <span class="comment">// 3-4x more than an invocation via native code for the first</span></span><br><span class="line">    <span class="comment">// invocation (though subsequent invocations have been benchmarked</span></span><br><span class="line">    <span class="comment">// to be over 20x faster). Unfortunately this cost increases</span></span><br><span class="line">    <span class="comment">// startup time for certain applications that use reflection</span></span><br><span class="line">    <span class="comment">// intensively (but only once per class) to bootstrap themselves.</span></span><br><span class="line">    <span class="comment">// To avoid this penalty we reuse the existing JVM entry points</span></span><br><span class="line">    <span class="comment">// for the first few invocations of Methods and Constructors and</span></span><br><span class="line">    <span class="comment">// then switch to the bytecode-based implementations.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Package-private to be accessible to NativeMethodAccessorImpl</span></span><br><span class="line">    <span class="comment">// and NativeConstructorAccessorImpl</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> noInflation        = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>     inflationThreshold = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这是生成MethodAccessor的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        checkInitted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                               method.getName(),</span><br><span class="line">                               method.getParameterTypes(),</span><br><span class="line">                               method.getReturnType(),</span><br><span class="line">                               method.getExceptionTypes(),</span><br><span class="line">                               method.getModifiers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NativeMethodAccessorImpl acc =</span><br><span class="line">                <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">            DelegatingMethodAccessorImpl res =</span><br><span class="line">                <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">            acc.setParent(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** We have to defer full initialization of this class until after</span></span><br><span class="line"><span class="comment">    the static initializer is run since java.lang.reflect.Method's</span></span><br><span class="line"><span class="comment">    static initializer (more properly, that for</span></span><br><span class="line"><span class="comment">    java.lang.reflect.AccessibleObject) causes this class's to be</span></span><br><span class="line"><span class="comment">    run, before the system properties are set up. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkInitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initted) <span class="keyword">return</span>;</span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// Tests to ensure the system properties table is fully</span></span><br><span class="line">                    <span class="comment">// initialized. This is needed because reflection code is</span></span><br><span class="line">                    <span class="comment">// called very early in the initialization process (before</span></span><br><span class="line">                    <span class="comment">// command-line arguments have been parsed and therefore</span></span><br><span class="line">                    <span class="comment">// these user-settable properties installed.) We assume that</span></span><br><span class="line">                    <span class="comment">// if System.out is non-null then the System class has been</span></span><br><span class="line">                    <span class="comment">// fully initialized and that the bulk of the startup code</span></span><br><span class="line">                    <span class="comment">// has been run.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (System.out == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// java.lang.System not yet fully initialized</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String val = System.getProperty(<span class="string">"sun.reflect.noInflation"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span> &amp;&amp; val.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">                        noInflation = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    val = System.getProperty(<span class="string">"sun.reflect.inflationThreshold"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            inflationThreshold = Integer.parseInt(val);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to parse property sun.reflect.inflationThreshold"</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    initted = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察前面的声明部分的注释，我们可以发现一些有趣的东西。就像注释里说的，实际的MethodAccessor实现有两个版本，一个是Java版本，一个是native版本，两者各有特点。初次启动时Method.invoke()和Constructor.newInstance()方法采用native方法要比Java方法快3-4倍，而启动后native方法又要消耗额外的性能而慢于Java方法。也就是说，Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。</p><p>为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。</p><p>研究ReflectionFactory.newMethodAccessor()生产MethodAccessor对象的逻辑，一开始(native版)会生产NativeMethodAccessorImpl和DelegatingMethodAccessorImpl两个对象。<br>DelegatingMethodAccessorImpl的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates its invocation to another MethodAccessorImpl and can</span></span><br><span class="line"><span class="comment">    change its delegate at run time. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</span><br><span class="line">        setDelegate(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实是一个中间层，方便在native版与Java版的MethodAccessor之间进行切换。<br>然后下面就是native版MethodAccessor的Java方面的声明：<br>sun.reflect.NativeMethodAccessorImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Used only for the first few invocations of a Method; afterward,</span></span><br><span class="line"><span class="comment">    switches to bytecode-based implementation */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次NativeMethodAccessorImpl.invoke()方法被调用时，程序调用计数器都会增加1，看看是否超过阈值；一旦超过，则调用MethodAccessorGenerator.generateMethod()来生成Java版的MethodAccessor的实现类，并且改变DelegatingMethodAccessorImpl所引用的MethodAccessor为Java版。后续经由DelegatingMethodAccessorImpl.invoke()调用到的就是Java版的实现了。<br>到这里，我们已经追寻到native版的invoke方法在Java一侧声明的最底层 - invoke0了，下面我们将深入到HotSpot JVM中去研究其具体实现。</p><h4 id="寻根溯源-在JVM层面探究invoke0方法"><a href="#寻根溯源-在JVM层面探究invoke0方法" class="headerlink" title="寻根溯源 - 在JVM层面探究invoke0方法"></a>寻根溯源 - 在JVM层面探究invoke0方法</h4><p>invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0</span><br><span class="line">(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_InvokeMethod(env, m, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>openjdk/hotspot/src/share/vm/prims/jvm.cpp</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_InvokeMethod"</span>);</span><br><span class="line">  Handle method_handle;</span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) &#123;</span><br><span class="line">    method_handle = Handle(THREAD, JNIHandles::resolve(method));</span><br><span class="line">    <span class="function">Handle <span class="title">receiver</span><span class="params">(THREAD, JNIHandles::resolve(obj))</span></span>;</span><br><span class="line">    <span class="function">objArrayHandle <span class="title">args</span><span class="params">(THREAD, objArrayOop(JNIHandles::resolve(args0)))</span></span>;</span><br><span class="line">    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);</span><br><span class="line">    jobject res = JNIHandles::make_local(env, result);</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::should_post_vm_object_alloc()) &#123;</span><br><span class="line">      oop ret_type = java_lang_reflect_Method::return_type(method_handle());</span><br><span class="line">      assert(ret_type != <span class="literal">NULL</span>, <span class="string">"sanity check: ret_type oop must not be NULL!"</span>);</span><br><span class="line">      <span class="keyword">if</span> (java_lang_Class::is_primitive(ret_type)) &#123;</span><br><span class="line">        <span class="comment">// Only for primitive type vm allocates memory for java object.</span></span><br><span class="line">        <span class="comment">// See box() method.</span></span><br><span class="line">        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_StackOverflowError());</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><p>其关键部分为Reflection::invoke_method:</p><ul><li>openjdk/hotspot/src/share/vm/runtime/reflection.cpp</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) &#123;</span><br><span class="line">  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);</span><br><span class="line">  <span class="keyword">int</span> slot               = java_lang_reflect_Method::slot(method_mirror);</span><br><span class="line">  <span class="keyword">bool</span> override          = java_lang_reflect_Method::override(method_mirror) != <span class="number">0</span>;</span><br><span class="line">  <span class="function">objArrayHandle <span class="title">ptypes</span><span class="params">(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)))</span></span>;</span><br><span class="line"></span><br><span class="line">  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);</span><br><span class="line">  BasicType rtype;</span><br><span class="line">  <span class="keyword">if</span> (java_lang_Class::is_primitive(return_type_mirror)) &#123;</span><br><span class="line">    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rtype = T_OBJECT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">instanceKlassHandle <span class="title">klass</span><span class="params">(THREAD, java_lang_Class::as_Klass(mirror))</span></span>;</span><br><span class="line">  Method* m = klass-&gt;method_with_idnum(slot);</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    THROW_MSG_0(vmSymbols::java_lang_InternalError(), <span class="string">"invoke"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">methodHandle <span class="title">method</span><span class="params">(THREAD, m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> invoke(klass, method, receiver, override, ptypes, rtype, args, <span class="literal">true</span>, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面又会涉及到Java的对象模型(klass和oop)，以后继续补充。笑容逐渐消失。</p><h4 id="寻根溯源-Java版的实现"><a href="#寻根溯源-Java版的实现" class="headerlink" title="寻根溯源 - Java版的实现"></a>寻根溯源 - Java版的实现</h4><p>Java版MethodAccessor的生成使用MethodAccessorGenerator实现，由于代码太长，这里就不贴代码了，只贴一下开头的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Generator for sun.reflect.MethodAccessor and</span></span><br><span class="line"><span class="comment">    sun.reflect.ConstructorAccessor objects using bytecodes to</span></span><br><span class="line"><span class="comment">    implement reflection. A java.lang.reflect.Method or</span></span><br><span class="line"><span class="comment">    java.lang.reflect.Constructor object can delegate its invoke or</span></span><br><span class="line"><span class="comment">    newInstance method to an accessor using native code or to one</span></span><br><span class="line"><span class="comment">    generated by this class. (Methods and Constructors were merged</span></span><br><span class="line"><span class="comment">    together in this class to ensure maximum code sharing.) */</span></span><br></pre></td></tr></table></figure><p>这里又运用了asm动态生成字节码技术（sun.reflect.ClassFileAssembler)。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>大致流程如下：</p><ul><li>1.建立 Map&lt;url,comtroller&gt; 的关系</li><li>2.根据 url 找到具体的处理方法</li><li>3.通过反射调用 controller 中的方法</li><li>4.通过<code>注解</code>或<code>参数名称</code>实现参数绑定</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><code>https://www.cnblogs.com/heavenyes/p/3905844.html#t1</code></p><p><code>sczyh30: http://www.sczyh30.com/posts/Java/java-reflection-2/</code>　</p></div><div><div><div style="text-align:center;color:#a2cd5a;font-size:18px">------------------本文到此结束<i class="fa fa-paw"></i>感谢您的阅读------------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> illusoryCloud</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.lixueduan.com/posts/cf395c14.html" title="SpringMVC系列(一)---执行流程分析">https://www.lixueduan.com/posts/cf395c14.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/SpringMVC/" rel="tag"><i class="fa fa-tag"></i> SpringMVC</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/aada1167.html" rel="next" title="Mybatis系列(一)---SQL 执行流程分析"><i class="fa fa-chevron-left"></i> Mybatis系列(一)---SQL 执行流程分析</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/posts/b93580d5.html" rel="prev" title="Spring系列(一)---Spring IoC 分析">Spring系列(一)---Spring IoC 分析<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="illusoryCloud"><p class="site-author-name" itemprop="name">illusoryCloud</p><p class="site-description motion-element" itemprop="description">有道无术，术尚可求，有术无道，止于术</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">80</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">21</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">23</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/illusorycloud" title="GitHub &rarr; https://github.com/illusorycloud" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:xueduan.li@gmail.com" title="E-Mail &rarr; mailto:xueduan.li@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="links-of-blogroll-item"> <a href="https://www.lixueduan.com/categories/SpringBoot/" title="https://www.lixueduan.com/categories/SpringBoot/">SpringBoot</a></li><li class="links-of-blogroll-item"> <a href="https://www.lixueduan.com/categories/SpringCloud/" title="https://www.lixueduan.com/categories/SpringCloud/">SpringCloud</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Servlet-执行流程"><span class="nav-text">1. Servlet 执行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SpringMVC-执行流程"><span class="nav-text">2. SpringMVC 执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行过程分析"><span class="nav-text">运行过程分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-具体过程分析"><span class="nav-text">3. 具体过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-建立-Map-lt-urls-Controller-gt-的关系"><span class="nav-text">1. 建立 Map&lt;urls,Controller&gt; 的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-根据访问url-找到对应-Controller-中处理请求的方法"><span class="nav-text">2.根据访问url 找到对应 Controller 中处理请求的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述-1"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原理"><span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-参数绑定"><span class="nav-text">3. 参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注解"><span class="nav-text">注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参数名称"><span class="nav-text">参数名称</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-源码分析"><span class="nav-text">4. 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-建立Map-lt-url-controller-gt-的关系"><span class="nav-text">1. 建立Map&lt;url,controller&gt;的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-根据访问url找到对应controller中处理请求的方法"><span class="nav-text">2. 根据访问url找到对应controller中处理请求的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-反射调用处理请求的方法-返回结果视图"><span class="nav-text">3. 反射调用处理请求的方法,返回结果视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-参数绑定"><span class="nav-text">4. 参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注解-1"><span class="nav-text">注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参数名称-1"><span class="nav-text">参数名称</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-反射源码分析"><span class="nav-text">5. 反射源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调用MethodAccessor的invoke方法"><span class="nav-text">调用MethodAccessor的invoke方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻根溯源-在JVM层面探究invoke0方法"><span class="nav-text">寻根溯源 - 在JVM层面探究invoke0方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻根溯源-Java版的实现"><span class="nav-text">寻根溯源 - Java版的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-小结"><span class="nav-text">5. 小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">illusoryCloud</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">591k</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=6.6.0"></script><script src="/js/src/motion.js?v=6.6.0"></script><script src="/js/src/scrollspy.js?v=6.6.0"></script><script src="/js/src/post-details.js?v=6.6.0"></script><script src="/js/src/bootstrap.js?v=6.6.0"></script><script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=document.createRange(),a=window.getSelection(),i=window.pageYOffset||document.documentElement.scrollTop;n.style.top=i+"px",n.style.position="absolute",n.style.opacity="0",n.value=t,n.textContent=t,n.contentEditable=!0,n.readOnly=!1,document.body.appendChild(n),o.selectNode(n),a.removeAllRanges(),a.addRange(o),n.setSelectionRange(0,t.length),document.execCommand("copy")?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script></body></html><script type="text/javascript" src="/js/src/love.js"></script>