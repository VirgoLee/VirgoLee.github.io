<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻境云图</title>
  
  <subtitle>勿在浮沙筑高台</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lixueduan.com/"/>
  <updated>2019-03-05T12:38:04.418Z</updated>
  <id>https://www.lixueduan.com/</id>
  
  <author>
    <name>illusoryCloud</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis入门教程(一)---安装与配置</title>
    <link href="https://www.lixueduan.com/posts/876962d5.html"/>
    <id>https://www.lixueduan.com/posts/876962d5.html</id>
    <published>2019-03-05T14:00:00.000Z</published>
    <updated>2019-03-05T12:38:04.418Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了如何在Linux(CentOS 7)下安装Redis与Redis基本使用与配置。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-Redis安装"><a href="#1-Redis安装" class="headerlink" title="1. Redis安装"></a>1. Redis安装</h2><h3 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h3><p>官网<code>https://redis.io/download</code> 下载文件，这里下的是<code>redis-5.0.3.tar.gz</code></p><p>然后上传到服务器。这里是放在了<code>/usr/software</code>目录下</p><h3 id="1-2-环境准备"><a href="#1-2-环境准备" class="headerlink" title="1.2 环境准备"></a>1.2 环境准备</h3><p><strong>安装编译源码所需要的工具和库</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install gcc gcc-c++ ncurses-devel perl</span><br></pre></td></tr></table></figure><h3 id="1-3-解压安装"><a href="#1-3-解压安装" class="headerlink" title="1.3 解压安装"></a>1.3 解压安装</h3><h4 id="1-解压"><a href="#1-解压" class="headerlink" title="1. 解压"></a>1. 解压</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost software]# tar -zxvf redis-5.0.3.tar.gz -C /usr/local</span><br><span class="line">//解压到/usr/local目录下</span><br></pre></td></tr></table></figure><h4 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h4><p>进入刚才解压的后的文件夹<code>redis-5.0.3</code>进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.3]# make</span><br></pre></td></tr></table></figure><p>如果提示<code>Hint: It&#39;s a good idea to run &#39;make test&#39; ;)</code>就说明编译ok了，接下来进行安装。</p><h4 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h4><p>进入<code>src</code>目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.3]# cd src/</span><br><span class="line">[root@localhost src]# make install</span><br></pre></td></tr></table></figure><p>出现下面的提示代表安装ok</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    CC Makefile.dep</span><br><span class="line"></span><br><span class="line">Hint: It's a good idea to run 'make test' ;)</span><br><span class="line"></span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br></pre></td></tr></table></figure><h4 id="4-文件复制"><a href="#4-文件复制" class="headerlink" title="4. 文件复制"></a>4. 文件复制</h4><p>创建两个文件夹来存放Redis命令和配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# mkdir -p /usr/local/redis/etc</span><br><span class="line">[root@localhost local]# mkdir -p /usr/local/redis/bin</span><br></pre></td></tr></table></figure><p>把<code></code>redis-5.0.3<code>下的</code>redis.conf<code>复制到</code>/usr/local/redis/etc`目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.3]# cp redis.conf /usr/local/redis/etc/</span><br></pre></td></tr></table></figure><p>把<code>redis-5.0.3/src</code>里的<code>mkreleasehdr.sh</code>、<code>redis-benchmark</code>、<code>redis-check-aof</code>、<code>redis-check-rdb</code>、<code>redis-cli</code>、<code>redis-server</code> 文件移动到<code>/usr/local/redis/bin</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-server /usr/local/redis/bin</span><br></pre></td></tr></table></figure><h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h2><h3 id="2-1-前台启动"><a href="#2-1-前台启动" class="headerlink" title="2.1 前台启动"></a>2.1 前台启动</h3><p>启动时并指定配置文件：.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br></pre></td></tr></table></figure><p>出现如下提示代表启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br><span class="line">10869:C 05 Mar 2019 13:33:39.041 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">10869:C 05 Mar 2019 13:33:39.042 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=10869, just started</span><br><span class="line">10869:C 05 Mar 2019 13:33:39.042 # Configuration loaded</span><br><span class="line">10869:M 05 Mar 2019 13:33:39.044 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ ''-._                                             </span><br><span class="line">      _.-``    `.  `_.  ''-._           Redis 5.0.3 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ ''-._                                   </span><br><span class="line"> (    '      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-'    |     PID: 10869</span><br><span class="line">  `-._    `-._  `-./  _.-'    _.-'                                   </span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|                                  </span><br><span class="line"> |    `-._`-._        _.-'_.-'    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'                                   </span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|                                  </span><br><span class="line"> |    `-._`-._        _.-'_.-'    |                                  </span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'                                   </span><br><span class="line">      `-._    `-.__.-'    _.-'                                       </span><br><span class="line">          `-._        _.-'                                           </span><br><span class="line">              `-.__.-'                                               </span><br><span class="line"></span><br><span class="line">10869:M 05 Mar 2019 13:33:39.046 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">10869:M 05 Mar 2019 13:33:39.046 # Server initialized</span><br><span class="line">10869:M 05 Mar 2019 13:33:39.047 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span><br><span class="line">10869:M 05 Mar 2019 13:33:39.047 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">10869:M 05 Mar 2019 13:33:39.047 * DB loaded from disk: 0.000 seconds</span><br><span class="line">10869:M 05 Mar 2019 13:33:39.047 * Ready to accept connections</span><br></pre></td></tr></table></figure><p><strong>退出</strong>：<code>CTRL+C</code></p><h3 id="2-2-后台启动"><a href="#2-2-后台启动" class="headerlink" title="2.2 后台启动"></a>2.2 后台启动</h3><p>(<strong>注意要使用后台启动需要修改<code>redis.conf</code>里的<code>daemonize</code>改为<code>yes</code></strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# vim redis.conf </span><br><span class="line"><span class="meta">#</span>主要修改下面这个daemonize</span><br><span class="line"><span class="meta">#</span> By default Redis does not run as a daemon. Use 'yes' if you need it.</span><br><span class="line"><span class="meta">#</span> Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line"><span class="meta">#</span> daemonize no 把这个改为yes no代表前台启动 yes代表后台启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The working directory.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> The DB will be written inside this directory, with the filename specified</span><br><span class="line"><span class="meta">#</span> above using the 'dbfilename' configuration directive.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> The Append Only File will also be created inside this directory.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Note that you must specify a directory here, not a file name.</span><br><span class="line"><span class="meta">#</span> dir ./  这个是工作区 默认为./ 即上级目录 这里也改一下</span><br><span class="line">dir /usr/local/redis/etc</span><br></pre></td></tr></table></figure><p>再次启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br></pre></td></tr></table></figure><p><strong>验证启动是否成功</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]#/ps aux|grep redis</span><br><span class="line"></span><br><span class="line">root      11012  0.2  0.2 153880  2344 ?        Ssl  13:36   0:00 /usr/local/redis/bin/redis-server 127.0.0.1:6379</span><br><span class="line">root      11126  0.0  0.0 112708   976 pts/2    R+   13:39   0:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p>redis启动成功端口号也是默认的6379。</p><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><h4 id="1-进入客户端"><a href="#1-进入客户端" class="headerlink" title="1. 进入客户端"></a>1. 进入客户端</h4><p>进入redis客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>语法redis-cli -h host -p port -a password</span><br><span class="line"><span class="meta">#</span>连接本机则不用写host和port 这里没设置密码也不用写</span><br><span class="line"></span><br><span class="line">[root@localhost etc]# /usr/local/redis/bin/redis-cli </span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>成功进入Redis客户端</p><p>随意操作一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; set name illusory</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "name"</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"illusory"</span><br><span class="line">127.0.0.1:6379&gt; set age 22</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">"22"</span><br><span class="line">127.0.0.1:6379&gt; quit #退出命令</span><br><span class="line">[root@localhost etc]#</span><br></pre></td></tr></table></figure><p><strong>退出客户端</strong>：<code>quit</code></p><h4 id="2-关闭Redis"><a href="#2-关闭Redis" class="headerlink" title="2. 关闭Redis"></a>2. 关闭Redis</h4><p>退出redis服务的三种方法：</p><ul><li>1.<code>pkill redis-server</code>、</li><li>2.<code>kill 进程号</code>、</li><li>3.<code>/usr/local/redis/bhi/redis-cli shutdown</code></li></ul><h4 id="3-dump-rdb文件"><a href="#3-dump-rdb文件" class="headerlink" title="3. dump.rdb文件"></a>3. dump.rdb文件</h4><p>由于前面配置文件中配置的是<code>dir /usr/local/redis/etc</code>,所以Redis的所有数据都会存储在这个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# ll</span><br><span class="line">total 68</span><br><span class="line">-rw-r--r--. 1 root root    92 Mar  5 13:36 dump.rdb</span><br><span class="line">-rw-r--r--. 1 root root 62174 Mar  5 13:36 redis.conf</span><br></pre></td></tr></table></figure><p>确实有这个文件。<strong>这个文件删除后Redis中的数据就真的没了</strong>。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><p><code>http://www.runoob.com/redis/redis-hashes.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了如何在Linux(CentOS 7)下安装Redis与Redis基本使用与配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://www.lixueduan.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.lixueduan.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门教程(一)---安装与配置</title>
    <link href="https://www.lixueduan.com/posts/876962d5.html"/>
    <id>https://www.lixueduan.com/posts/876962d5.html</id>
    <published>2019-03-05T14:00:00.000Z</published>
    <updated>2019-03-05T15:15:28.701Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了Redis五大基础数据类型与key命令，包括了<code>String</code>、<code>Hash</code>、<code>List</code>、<code>Set</code>、<code>ZSet</code>。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><p>Redis一共分5种数据类型：<code>String</code>、<code>Hash</code>、<code>List</code>、<code>Set</code>、<code>ZSet</code></p><h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><h3 id="1-1-set"><a href="#1-1-set" class="headerlink" title="1.1 set"></a>1.1 set</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>set</strong>  key value</td><td>设置指定 key 的值</td></tr><tr><td><strong>setnx</strong> key value</td><td>只有在 key 不存在时设置 key 的值。(not exist)</td></tr><tr><td><strong>setex</strong> key seconds valuel</td><td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (秒)。expired</td></tr><tr><td>psetex key milliseconds value]</td><td>和setex命令相似，但它以毫秒为单位设置 key 的生存时间</td></tr><tr><td><strong>mset</strong> key value [key value …]</td><td>同时设置一个或多个 key-value 对。</td></tr><tr><td>msetnx key value [key value …]</td><td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr></tbody></table><h3 id="1-2-get"><a href="#1-2-get" class="headerlink" title="1.2 get"></a>1.2 get</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>get</strong> key</td><td>获取指定 key 的值。</td></tr><tr><td><strong>mget</strong> key1 [key2..]</td><td>获取所有(一个或多个)给定 key 的值。</td></tr><tr><td>getrange key start end</td><td>返回 key 中字符串值的子字符</td></tr><tr><td>strlen key</td><td>返回 key 所储存的字符串值的长度。</td></tr></tbody></table><h3 id="1-3-update"><a href="#1-3-update" class="headerlink" title="1.3 update"></a>1.3 update</h3><table><thead><tr><th style="text-align:left">命令</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">getset key value</td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td style="text-align:left">setrange key offset value</td><td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td style="text-align:left"><strong>incr</strong> key</td><td>将 key 中储存的数字值一。</td></tr><tr><td style="text-align:left"><strong>incrby</strong> key increment</td><td>将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td style="text-align:left">incrbyfloat key increment</td><td>将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td style="text-align:left"><strong>decr</strong> key</td><td>将 key 中储存的数字值减一。</td></tr><tr><td style="text-align:left"><strong>decrby</strong> key decrement</td><td>key 所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td style="text-align:left">append key value</td><td>追加字符串到key末尾</td></tr></tbody></table><h3 id="1-4-实例"><a href="#1-4-实例" class="headerlink" title="1.4 实例"></a>1.4 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置值：set key value--&gt;set myname illusory   <span class="comment">//同一个key多次set会覆盖</span></span><br><span class="line">获取值：get key  ------&gt;get myname</span><br><span class="line">删除值：del key--------&gt;del myname</span><br></pre></td></tr></table></figure><p>其他set方法：</p><p><code>setnx(not exist)</code>: 如果key不存在就设置值，返回1;存在就不设置，返回0；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式：setnx key value</span><br><span class="line">127.0.0.1:6379&gt; set myname illusory</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setnx myname cloud   #myname 已经存在了 返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get myname  # 值也没有发生变化</span><br><span class="line">"illusory"</span><br></pre></td></tr></table></figure><p><code>setex(expired)</code>: 设置数据过期时间，数据只存在一段时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式：setnx key seconds value;</span><br><span class="line">setnx vercode 60 123456； </span><br><span class="line"><span class="meta">#</span>设置key--&gt;vercode有效时间60s，60s内获取值为123456,60s后返回nil（Redis中nil表示空）</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex vercode 5 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get vercode #时间没到 还能查询到</span><br><span class="line">"123456"</span><br><span class="line">127.0.0.1:6379&gt; get vercode  #5s到了 数据过期 查询返回nil</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><code>setrange</code>：替换字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式：setrange key offset value</span><br><span class="line">set email 123456789@gmail.com</span><br><span class="line">setrange email 10 qqqqq # 从第10位开始替换(不包括第10位) 后面跟上用来替换的字符串</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set email 123456789@gmail.com</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get email</span><br><span class="line">"123456789@qqail.com"</span><br><span class="line">127.0.0.1:6379&gt; setrange email 10 qqqqq</span><br><span class="line">(integer) 19</span><br><span class="line">127.0.0.1:6379&gt; get email</span><br><span class="line">"123456789@qqqqq.com"</span><br></pre></td></tr></table></figure><p>mset：一次设置多个值</p><p><code>mset key1 value1 key2 value2 ...keyn valuen</code></p><p>mget：一次获取多个值</p><p><code>mget key1 key2 key3...keyn</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 111 k2 222 k3 333 </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) "111"</span><br><span class="line">2) "222"</span><br><span class="line">3) "333"</span><br></pre></td></tr></table></figure><p><code>getset</code>: 返回旧值并设置新值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 getset key value</span><br><span class="line">getset name cloud #将name设置为cloud并放回name的旧值</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name illusory</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"illusory"</span><br><span class="line">127.0.0.1:6379&gt; getset name cloud</span><br><span class="line">"illusory"</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"cloud"</span><br></pre></td></tr></table></figure><p><code>incr/decr</code>:对一个值进行递增或者递减操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 格式 incr key/decr key</span><br><span class="line">incr age #age递增1</span><br><span class="line">decr age #age递减1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">"22"</span><br><span class="line">127.0.0.1:6379&gt; incr age #递增</span><br><span class="line">(integer) 23</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">"23"</span><br><span class="line">127.0.0.1:6379&gt; decr age #递减</span><br><span class="line">(integer) 22</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">"22"</span><br></pre></td></tr></table></figure><p><code>incrby/decrby</code>:对一个值按照一定<code>步长</code>进行递增或者递减操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 格式 incrby key increment/decrby key increment</span><br><span class="line">incrby age 3 #age递增3</span><br><span class="line">decrby age 3 #age递减3</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">"22"</span><br><span class="line">127.0.0.1:6379&gt; incrby age 3</span><br><span class="line">(integer) 25</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">"25"</span><br><span class="line">127.0.0.1:6379&gt; decrby age 3</span><br><span class="line">(integer) 22</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">"22"</span><br></pre></td></tr></table></figure><p><code>append</code>:字符串追加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 append key value</span><br><span class="line">append name cloud #在name后追加cloud</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"illusory"</span><br><span class="line">127.0.0.1:6379&gt; append name cloud</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"illusorycloud"</span><br></pre></td></tr></table></figure><p><code>strlen</code>：获取字符串长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 strlen key </span><br><span class="line">strlen name #获取name对应的value的长度</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"illusorycloud"</span><br><span class="line">127.0.0.1:6379&gt; strlen name</span><br><span class="line">(integer) 13</span><br></pre></td></tr></table></figure><h2 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2. Hash"></a>2. Hash</h2><p>工作中使用最多的就是Hash类型</p><p>将一个对象存储在Hash类型里要比String类型里占用的空间少一些，并方便存取整个对象。</p><p><code>hset</code>:类似于set，数据都存为Hash类型，类似于存在map中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 格式 hset key filed value</span><br><span class="line">hset me name illusory #me是hash名 name是hash中的key illusory为hash中的value </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>类似于Java中的Map</span><br><span class="line">        Map&lt;Object,Object&gt; me = new HashMap&lt;&gt;();</span><br><span class="line">        me.put("name", "illusory");</span><br></pre></td></tr></table></figure><h3 id="2-1-hset"><a href="#2-1-hset" class="headerlink" title="2.1 hset"></a>2.1 hset</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>hset</strong> key filed value</td><td>将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td><strong>hsetnx</strong> key filed value</td><td>类似setnx,只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td><strong>hmset</strong> key filed1 value1[filed2 value2..]</td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td></td></tr></tbody></table><h3 id="2-2-hget"><a href="#2-2-hget" class="headerlink" title="2.2 hget"></a>2.2 hget</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>hget</strong> key filed</td><td>获取存储在哈希表中指定字段的值。</td></tr><tr><td><strong>hmget</strong> key filed1 [filed2…]</td><td>获取所有给定字段的值</td></tr><tr><td><strong>hgetall</strong> key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td><strong>hkeys</strong> key</td><td>获取所有哈希表中的字段</td></tr><tr><td><strong>hvals</strong> key</td><td>获取哈希表中所有值</td></tr><tr><td>hscankey cursor [MATCH pattern][COUNT count]</td><td>迭代哈希表中的键值对。</td></tr><tr><td>hexists key filed</td><td>查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td>hlen key</td><td>获取哈希表中字段的数量</td></tr><tr><td>hstrlen key filed</td><td>返回哈希表 key 中， 给定field的字符串长度</td></tr></tbody></table><h3 id="2-3-update"><a href="#2-3-update" class="headerlink" title="2.3 update"></a>2.3 update</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>hincrby</strong> key field increment</td><td>为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td>hincrbyfloat key field increment</td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td><strong>hdel</strong> key</td><td>删除哈希表key 中的一个或多个指定域，不存在的域将被忽略。</td></tr></tbody></table><h3 id="2-4-实例"><a href="#2-4-实例" class="headerlink" title="2.4 实例"></a>2.4 实例</h3><p><code>hset</code>:类似于set，数据都存为Hash类型，类似于存在map中</p><p><code>hget</code>:类似于get</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 格式 hget hash filed</span><br><span class="line">hget me name #获取hash名为me的hash中的name对应的value</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset me name illusory</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset me age 22</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget me name</span><br><span class="line">"illusory"</span><br><span class="line">127.0.0.1:6379&gt; hget me age</span><br><span class="line">"22"</span><br></pre></td></tr></table></figure><p>同样也有批量操作的<code>hmset</code>、<code>hmget</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hmset key filed1 value1 filde2 value2 ....filedn valuen</span><br><span class="line"><span class="meta">#</span>格式 hmget key filed1  filde2....filedn</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset me name illusory age 22</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget me name age</span><br><span class="line">1) "illusory"</span><br><span class="line">2) "22"</span><br></pre></td></tr></table></figure><p><code>hsetnx(not exist)</code>: 如果key不存在就设置值，返回1;存在就不设置，返回0；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hsetnx value filed value</span><br></pre></td></tr></table></figure><p><code>hincrby/hdecrby</code>:对一个值按照一定<code>步长</code>进行递增或者递减操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 格式 hincrby key filed increment/hdecrby key filed increment</span><br><span class="line">incrby me age 3 #age递增3</span><br><span class="line">decrby me age 3 #age递减3</span><br></pre></td></tr></table></figure><p><code>hstrlen key filed</code>:回哈希表 <code>key</code> 中， 与给定域 <code>field</code> 相关联的值的字符串长度（string length）。</p><p>如果给定的键或者域不存在， 那么命令返回 <code>0</code> 。</p><p><code>hexists</code>:判断是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hexists value filed</span><br></pre></td></tr></table></figure><p><code>hlen</code>:查看hash的filed数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hlen key</span><br></pre></td></tr></table></figure><p><code>hdel</code>:删除指定hash中的filed</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hdel key filed</span><br></pre></td></tr></table></figure><p><code>hkeys</code>:返回指定hash中所有的filed</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hkeys key</span><br></pre></td></tr></table></figure><p><code>hvals</code>:返回指定hash中所有的value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hvals key</span><br></pre></td></tr></table></figure><p><code>hgetall</code>:返回指定hash中所有的filed和value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>格式 hgetall key</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall me</span><br><span class="line">1) "name"</span><br><span class="line">2) "illusory"</span><br><span class="line">3) "age"</span><br><span class="line">4) "23"</span><br></pre></td></tr></table></figure><h2 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h2><p>可以看做Java中的List，不过更像Queue。</p><h3 id="3-1-lpush-rpush"><a href="#3-1-lpush-rpush" class="headerlink" title="3.1 lpush/rpush"></a>3.1 lpush/rpush</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>lpush</strong> key value1 [value2..]</td><td style="text-align:left">将一个或多个值插入到列表<strong>头部</strong></td></tr><tr><td style="text-align:left">lpushx key value</td><td style="text-align:left">将一个值插入到已存在的列表<strong>头部</strong></td></tr><tr><td style="text-align:left"><strong>rpush</strong> key value1 [value2..]</td><td style="text-align:left">将一个或多个值插入到列表<strong>尾部</strong></td></tr><tr><td style="text-align:left">rpushx key value</td><td style="text-align:left">将一个值插入到已存在的列表<strong>尾部</strong></td></tr><tr><td style="text-align:left"><strong>lset</strong> key index value</td><td style="text-align:left">将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</td></tr><tr><td style="text-align:left">linsert key BEFORE\</td><td style="text-align:left">AFTER pivot value</td><td>将值 <code>value</code> 插入到列表 <code>key</code> 当中，位于值 <code>pivot</code> 之前或之后。</td></tr></tbody></table><h3 id="3-2-lpop-rpop"><a href="#3-2-lpop-rpop" class="headerlink" title="3.2 lpop/rpop"></a>3.2 lpop/rpop</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>lpop</strong> key</td><td>移除并获取列表的第一个元素</td></tr><tr><td>blpop key [key …] timeout</td><td>lpop的阻塞版本，没有元素可供弹出的时候会阻塞直到有元素或超时。</td></tr><tr><td><strong>rpop</strong> key</td><td>移除并获取列表的倒数第一个元素</td></tr><tr><td>brpop key [key …] timeout</td><td>rpop的阻塞版本，没有元素可供弹出的时候会阻塞直到有元素或超时。</td></tr><tr><td>rpoplpush source destination</td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td>brpoplpush source destination timeout</td><td>rpoplpush的阻塞版，source为空时阻塞直到不为空或者超时。</td></tr><tr><td>lrem key count value</td><td>移除列表元素</td></tr><tr><td><strong>lrange</strong> key start stop</td><td>返回列表 <code>key</code> 中指定区间内的元素，区间以偏移量 <code>start</code> 和 <code>stop</code> 指定。</td></tr><tr><td>ltrim key start stop</td><td>对一个列表进行修剪(trim)，只保留指定区间内的元素。</td></tr><tr><td>llen key</td><td>返回列表 key的长度。</td></tr><tr><td>lindex key index</td><td>返回列表 key 中，下标为 index的元素。</td></tr></tbody></table><h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h2><p><code>Set</code>集合是String类型的<code>无序</code>集合，通过hashtable实现的，对集合我们可以取交集，并集，差集。</p><p>Java中List的升级版。</p><h3 id="4-1-sadd-spop"><a href="#4-1-sadd-spop" class="headerlink" title="4.1 sadd/spop"></a>4.1 sadd/spop</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>sadd</strong> key member [member …]</td><td>将一个或多个 <code>member</code> 元素加入到集合 <code>key</code> 当中，已经存在于集合的 <code>member</code> 元素将被忽略</td></tr><tr><td><strong>spop</strong> key</td><td>移除并返回集合中的一个随机元素。</td></tr><tr><td>srem key member [member …]</td><td>移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素，不存在的 <code>member</code> 元素会被忽略。</td></tr><tr><td><strong>smove</strong> source destination member</td><td>将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。</td></tr></tbody></table><h3 id="4-2-get"><a href="#4-2-get" class="headerlink" title="4.2 get"></a>4.2 get</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>sinter</strong> key [key …]</td><td>返回给定所有集合的<strong>交集</strong></td></tr><tr><td>sinterstore destination key [key …]</td><td>返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td><strong>sunion</strong> key [key …]</td><td>返回所有给定集合的<strong>并集</strong></td></tr><tr><td>sunionstore destination key [key …]</td><td>返回所有给定集合的并集存储在 destination 集合中</td></tr><tr><td><strong>sdiff</strong>key [key …]</td><td>返回给定所有集合的<strong>差集</strong></td></tr><tr><td>sdiffstore destination key [key …]</td><td>返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td><strong>smembers</strong> key</td><td>返回集合 <code>key</code> 中的所有成员。</td></tr><tr><td>sismember key member</td><td>判断 <code>member</code> 元素是否集合 <code>key</code> 的成员。</td></tr><tr><td><strong>scard</strong> key</td><td>返回集合 <code>key</code> 的基数(集合中元素的数量)</td></tr><tr><td><strong>srandmember</strong> key [count]</td><td>返回集合中一个或多个随机数</td></tr></tbody></table><h2 id="5-ZSet"><a href="#5-ZSet" class="headerlink" title="5. ZSet"></a>5. ZSet</h2><p><code>ZSet</code>则是<code>有序</code>的。</p><h3 id="5-1-zadd"><a href="#5-1-zadd" class="headerlink" title="5.1 zadd"></a>5.1 zadd</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd key score1 member1 [score2 member2…]</td><td>将一个或多个 <code>member</code> 元素及其 <code>score</code> 值加入到有序集 <code>key</code> 当中。</td></tr><tr><td><strong>zincrby</strong> key increment member</td><td>为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code> 。</td></tr></tbody></table><h3 id="5-2-get"><a href="#5-2-get" class="headerlink" title="5.2 get"></a>5.2 get</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zscore key member</td><td>返回有序集 <code>key</code> 中，成员 <code>member</code> 的 <code>score</code> 值。</td></tr><tr><td>zcard key</td><td>返回有序集 <code>key</code> 的基数。(集合中元素的数量)</td></tr><tr><td>zcount key min max</td><td>返回有序集 <code>key</code> 中， <code>score</code> 值在 <code>min</code> 和 <code>max</code> 之间(默认包括 <code>score</code> 值等于 <code>min</code> 或 <code>max</code> )的成员的数量。</td></tr><tr><td><strong>zrange</strong> key start stop [withscores]</td><td>返回有序集 <code>key</code> 中，指定区间内的成员。其中成员的位置按 <code>score</code> 值递增(<strong>从小到大</strong>)来排序。</td></tr><tr><td>zrevrange key start stop [withscores]</td><td>类似zrange,不过成员位置按 <code>score</code> 值递增(<strong>从大到小</strong>)来排序。</td></tr><tr><td><strong>zrangebyscore</strong> key min max [withscores][LIMIT offset count]</td><td>返回有序集 <code>key</code> 中，所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。有序集成员按 <code>score</code> 值递增(<strong>从小到大</strong>)次序排列。</td></tr><tr><td>zrevrangebyscore key min max [withscores][LIMIT offset count]</td><td>类似zrangebyscore，不过有序集成员按 <code>score</code> 值递增(<strong>从小到大</strong>)次序排列。</td></tr><tr><td><strong>zrank</strong> key member</td><td>返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递增(<strong>从小到大</strong>)顺序排列。</td></tr><tr><td>zrevrank key member</td><td>类似zrank，其中有序集成员按 <code>score</code> 值递增(<strong>从大到小</strong>)顺序排列。</td></tr><tr><td>zrangebylex key min max [LIMIT offset count]</td><td>通过字典区间返回有序集合的成员</td></tr><tr><td>zlexcount key min max</td><td>返回该集合中， 成员介于 <code>min</code> 和 <code>max</code> 范围内的元素数量。</td></tr><tr><td><strong>zuniostore</strong> destination numkeys key [key …]</td><td>计算给定的一个或多个有序集的<strong>并集</strong>，并存储在新的 key 中</td></tr><tr><td><strong>zinterstore</strong> destination numkeys key [key …]</td><td>计算给定的一个或多个有序集的<strong>交集</strong>，并存储在新的 key 中</td></tr></tbody></table><h3 id="5-3-delete"><a href="#5-3-delete" class="headerlink" title="5.3 delete"></a>5.3 delete</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zrem key member [member …]</td><td>移除有序集 <code>key</code> 中的一个或多个成员，不存在的成员将被忽略。</td></tr><tr><td>zremrangebyrank key start stop</td><td>移除有序集 <code>key</code> 中，指定排名(rank)区间内的所有成员。</td></tr><tr><td>zremrangebyscore key min max</td><td>移除有序集 <code>key</code> 中，所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员</td></tr><tr><td>zremrangebylex key min max</td><td>移除该集合中， 成员介于 <code>min</code> 和 <code>max</code> 范围内的所有元素。</td></tr></tbody></table><h2 id="6-Key命令"><a href="#6-Key命令" class="headerlink" title="6. Key命令"></a>6. Key命令</h2><p>Redis中所有key都可以使用的命令。</p><table><thead><tr><th>命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td><strong>del</strong> key</td><td style="text-align:left">该命令用于在 key 存在时删除 key。</td></tr><tr><td>dump key</td><td style="text-align:left">序列化给定 key ，并返回被序列化的值。</td></tr><tr><td><strong>exists</strong> key</td><td style="text-align:left">检查给定 key 是否存在。</td></tr><tr><td><strong>expire</strong> key seconds</td><td style="text-align:left">为给定 key 设置过期时间，以秒计。</td></tr><tr><td>expireat key timestamp</td><td style="text-align:left">类似expirre，都用于为 key 设置过期时间。 不同在于 expireat命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td>pexpire key milliseconds</td><td style="text-align:left">设置 key 的过期时间以毫秒计。</td></tr><tr><td>pexpireat key timestamp</td><td style="text-align:left">设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td><strong>keys</strong> pattern</td><td style="text-align:left">类似模糊查询，查找所有符合给定模式( pattern)的 key。key l 查出以l开头的</td></tr><tr><td>move key db</td><td style="text-align:left">将当前数据库的 key 移动到给定的数据库 db(0~15) 当中。</td></tr></tbody></table><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><code>http://www.runoob.com/redis/redis-hashes.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了Redis五大基础数据类型与key命令，包括了&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Hash&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;ZSet&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://www.lixueduan.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.lixueduan.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门教程(四)---反向代理与负载均衡</title>
    <link href="https://www.lixueduan.com/posts/930200c5.html"/>
    <id>https://www.lixueduan.com/posts/930200c5.html</id>
    <published>2019-03-04T14:00:00.000Z</published>
    <updated>2019-03-05T12:13:56.399Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要对Nginx服务器的常用配置文件，包括虚拟主机配置，location配置级语法等。</p><a id="more"></a><blockquote><p><strong><a href="https://www.lixueduan.com/categories/">Nginx入门教程系列文章目录</a></strong></p><p><a href="https://www.lixueduan.com/posts/545ed69.html">Nginx入门教程(一)—安装与配置</a></p><p><a href="https://www.lixueduan.com/posts/5a0a337e.html">Nginx入门教程(二)—配置文件详解</a></p><p><a href="https://www.lixueduan.com/posts/3ebafd31.html">Nginx入门教程(三)—日志文件切割</a></p><p><a href="https://www.lixueduan.com/posts/930200c5.html">Nginx入门教程(四)—反向代理与负载均衡</a></p><p>……</p><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-反向代理-proxy"><a href="#1-反向代理-proxy" class="headerlink" title="1. 反向代理(proxy)"></a>1. 反向代理(proxy)</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p><strong>如果您的内容服务器具有必须保持安全的敏感信息，如信用卡号数据库，可在防火墙外部设置一个<code>代理服务器</code>作为<code>内容服务器的替身</code></strong>。</p><p>当外部客户机尝试访问内容服务器时，会将其送到代理服务器。实际内容位于内容服务器上，在防火墙内部受到安全保护。代理服务器位于防火墙外部，在客户机看来就像是内容服务器。</p><p> 这样，代理服务器就在安全数据库和可能的恶意攻击之间提供了又一道屏障。与有权访问整个数据库的情况相对比，就算是侥幸攻击成功，作恶者充其量也仅限于访问单个事务中所涉及的信息。未经授权的用户无法访问到真正的内容服务器，因为防火墙通路只允许代理服务器有权进行访问。</p><p><strong>就是客户端先访问Nginx服务器，Nginx收到请求后再去请求内容服务器,这样中间多了一个Nginx服务器中转，会更加安全</strong>。</p><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h4><p>首先需要修改<code>Nginx服务器</code>配置文件<code></code>nginx.conf`。</p><p>配置文件大概是这样的，在<code>server</code>中添加一个<code>location</code>用于中转。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80; //端口号</span><br><span class="line">        server_name localhost; //域名</span><br><span class="line">        <span class="attribute">location</span> \ &#123;</span><br><span class="line">            root html; //网站根目录</span><br><span class="line">            index index.html; //网站首页</span><br><span class="line">        &#125;  </span><br><span class="line">        access_log  logs/host.access.log  main; //访问日志</span><br><span class="line">        error page 500 error.html; //错误页面</span><br><span class="line">        <span class="comment">#这里就是代理 通过正则表达式来匹配</span></span><br><span class="line">        <span class="comment">#后缀以.jsp结尾的请求都会跳转到 http://192.168.5.154:8080;</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.jsp$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>   http://192.168.5.154:8080;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开启内容服务器"><a href="#2-开启内容服务器" class="headerlink" title="2. 开启内容服务器"></a>2. 开启内容服务器</h4><p>然后在<code>192.168.5.154</code>的<code>8080</code>端口开启了一个<code></code>tomcat<code>,当做是真正的内容服务器，在tomcat默认的</code>index.jsp`中添加了一句显示IP地址的。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--测试Nginx反向代理新增--&gt;</span><br><span class="line">remote ip:&lt;%=request.getRemoteAddr()%&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><p>然后开始访问：</p><p>首先直接访问内容服务器(Tomcat)：<code>192.168.5.154:8080</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote ip:<span class="number">192.168</span>.5.199</span><br></pre></td></tr></table></figure><p>然后访问Nginx通过代理来访问内容服务器：<code>192.168.5.154/index.jsp</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote ip:<span class="number">192.168</span>.5.154</span><br></pre></td></tr></table></figure><p>显示远程    IP是192.168.5.154，这个刚好就是Nginx服务器的IP；</p><p>反向代理成功。</p><h3 id="1-4-问题"><a href="#1-4-问题" class="headerlink" title="1.4 问题"></a>1.4 问题</h3><p>前面设置后反向代理已经成功了,但是这样设置后，每次访问内容服务器都显示的是Nginx服务器的IP,内容服务器无法获取用户的真实IP，所以还需要进行一点修改。</p><h4 id="1-修改"><a href="#1-修改" class="headerlink" title="1. 修改"></a>1. 修改</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80; //端口号</span><br><span class="line">        server_name localhost; //域名</span><br><span class="line">        <span class="attribute">location</span> \ &#123;</span><br><span class="line">            root html; //网站根目录</span><br><span class="line">            index index.html; //网站首页</span><br><span class="line">        &#125;  </span><br><span class="line">        access_log  logs/host.access.log  main; //访问日志</span><br><span class="line">        error page 500 error.html; //错误页面</span><br><span class="line">        <span class="comment">#这里就是代理 通过正则表达式来匹配</span></span><br><span class="line">        <span class="comment">#后缀以.jsp结尾的请求都会跳转到 http://192.168.5.154:8080;</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.jsp$</span> &#123;</span><br><span class="line">            <span class="comment">#在请求头中添加上真实的IP </span></span><br><span class="line">            <span class="comment">#具体格式为 proxy_set_header 属性名 数据</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span></span><br><span class="line">            proxy_pass   http://192.168.5.154:8080;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxy_set_header X-real-ip $remote_addr</code> :Nginx服务器是知道客户端真实IP的，所以为了让内容服务器知道真实IP，只需要将真实IP添加到请求头中就可以了。</p><p>其中<code>X-real-ip</code> 是自定义的，内容服务器取数据时也使用这个<code>X-real-ip</code></p><p><code>$remote_addr</code> 则是获取远程客户端IP。</p><h4 id="2-测试："><a href="#2-测试：" class="headerlink" title="2. 测试："></a>2. 测试：</h4><p>修改jsp，添加了一句代码。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         &lt;!--测试Nginx反向代理新增--&gt;</span><br><span class="line">&lt;!--获取请求头中的真实IP--&gt;</span><br><span class="line">         Real remote ip:&lt;%=request.getHeader(<span class="string">"X-real-ip"</span>)%&gt; &lt;br /&gt;</span><br><span class="line">         remote ip/Nginx ip:&lt;%=request.getRemoteAddr()%&gt;</span><br></pre></td></tr></table></figure><p>然后开始访问：</p><p>首先直接访问内容服务器(Tomcat)：<code>192.168.5.154:8080</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Real remote ip:<span class="keyword">null</span> </span><br><span class="line">remote ip/Nginx ip:<span class="number">192.168</span>.5.199</span><br></pre></td></tr></table></figure><p>然后访问Nginx通过代理来访问内容服务器：<code>192.168.5.154/index.jsp</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Real remote ip:<span class="number">192.168</span>.5.199 </span><br><span class="line">remote ip/Nginx ip:<span class="number">192.168</span>.5.154</span><br></pre></td></tr></table></figure><p>成功获取到真实IP，问题解决。</p><h2 id="2-负载均衡-upstream"><a href="#2-负载均衡-upstream" class="headerlink" title="2. 负载均衡(upstream)"></a>2. 负载均衡(upstream)</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><strong>可以在一个组织内使用多个代理服务器来平衡各 Web 服务器间的网络负载</strong>。</p><p>对于客户机发往真正服务器的请求，代理服务器起着中间调停者的作用。客户机每次都使用同一个 URL，但请求所采取的路由每次都可能经过不同的代理服务器。</p><p><strong>同样是客户端先访问Nginx服务器，然后Nginx服务器再根据负载均衡算法将请求分发到不同的内容服务器上</strong>。</p><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><p>同意需要修改<code>Nginx服务器</code>配置文件<code></code>nginx.conf`。</p><p>配置文件大概是这样的，在<code>server</code>中添加一个<code>location</code>用于中转。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="comment">#upstream 负载均衡 与server同级</span></span><br><span class="line">    <span class="comment">#tomcat_server 负载均衡名字 自定义的 </span></span><br><span class="line">    <span class="comment">#要用在下面location反向代理处 </span></span><br><span class="line">    <span class="comment">#poxy_pass   http://tomcat_server;</span></span><br><span class="line">    <span class="attribute">upstream</span> tomcat_server&#123;</span><br><span class="line">        <span class="comment">#weight权重 max_fails 最大失败次数 超过后就认为该节点down掉了 fail_timeout 超时时间</span></span><br><span class="line">        <span class="comment">#192.168.5.154:8080 IP地址或者域名都可以</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.5.154:8080</span> weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.5.155:8080</span> weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80; //端口号</span><br><span class="line">        server_name localhost; //域名</span><br><span class="line">        <span class="attribute">location</span> \ &#123;</span><br><span class="line">            root html; //网站根目录</span><br><span class="line">            index index.html; //网站首页</span><br><span class="line">        &#125;  </span><br><span class="line">        access_log  logs/host.access.log  main; //访问日志</span><br><span class="line">        error page 500 error.html; //错误页面</span><br><span class="line">        <span class="comment">#proxy_pass 反向代理 通过正则表达式来匹配</span></span><br><span class="line">        <span class="comment">#后缀以.jsp结尾的请求都会跳转到 http://192.168.5.154:8080;</span></span><br><span class="line">        <span class="comment">#proxy_set_header 将真实IP添加到请求头中 传递到内容服务器</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.jsp$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span></span><br><span class="line">            <span class="comment">#proxy_pass   http://192.168.5.154:8080;</span></span><br><span class="line">            <span class="comment">#反向代理这里不光可以写IP 还可以写上面配置的负载均衡</span></span><br><span class="line">            proxy_pass   http://tomcat_server;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><p>开启两个tomcat，一个是<code>192.168.5.154</code>,一个是<code></code>192.168.5.155`.</p><p>然后浏览器访问nginx服务器：<code>192.168.5.154/index.jsp</code>；</p><p>会随机跳转到两个tomcat服务器中的一个就说明负载均衡配置成功了。</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><p><code>http://www.runoob.com/linux/nginx-install-setup.html</code></p><p><code>https://www.cnblogs.com/javahr/p/8318728.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要对Nginx服务器的常用配置文件，包括虚拟主机配置，location配置级语法等。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://www.lixueduan.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://www.lixueduan.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门教程(三)---日志文件切割</title>
    <link href="https://www.lixueduan.com/posts/3ebafd31.html"/>
    <id>https://www.lixueduan.com/posts/3ebafd31.html</id>
    <published>2019-03-03T14:00:00.000Z</published>
    <updated>2019-03-05T12:14:04.585Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要对Nginx服务器的日志文件分析，包括<code>日志文件切割</code>与<code>cron定时任务</code>语法详解。</p><a id="more"></a><blockquote><p><strong><a href="https://www.lixueduan.com/categories/">Nginx入门教程系列文章目录</a></strong></p><p><a href="https://www.lixueduan.com/posts/545ed69.html">Nginx入门教程(一)—安装与配置</a></p><p><a href="https://www.lixueduan.com/posts/5a0a337e.html">Nginx入门教程(二)—配置文件详解</a></p><p><a href="https://www.lixueduan.com/posts/3ebafd31.html">Nginx入门教程(三)—日志文件切割</a></p><p><a href="https://www.lixueduan.com/posts/930200c5.html">Nginx入门教程(四)—反向代理与负载均衡</a></p><p>……</p><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-日志文件"><a href="#1-日志文件" class="headerlink" title="1. 日志文件"></a>1. 日志文件</h2><p>再看一下Nginx目录结构</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx</span><br><span class="line">--conf配置文件</span><br><span class="line">--html  网页文件</span><br><span class="line">--logs  日志文件</span><br><span class="line">--sbin  主要二进制文件</span><br></pre></td></tr></table></figure><h3 id="1-1-查看日志"><a href="#1-1-查看日志" class="headerlink" title="1.1 查看日志"></a>1.1 查看日志</h3><p>前面看了<code>conf配置文件</code>，这里看下<code>logs日志文件</code>;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/logs</span><br><span class="line">-- access.log #访问日志</span><br><span class="line"> -- error.log  #错误日志</span><br><span class="line"> -- nginx.pid  #存放Nginx当前进程的pid</span><br></pre></td></tr></table></figure><p><code>nginx.pid</code> 存放Nginx当前进程的pid</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost logs]# cat nginx.pid</span><br><span class="line">98830</span><br><span class="line">[root@localhost logs]# ps aux|grep nginx</span><br><span class="line"><span class="attribute">root</span>      <span class="number">98830</span>  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span>  <span class="number">20552</span>   <span class="number">616</span> ?        Ss   <span class="number">09</span>:<span class="number">57</span>   <span class="number">0</span>:<span class="number">00</span> nginx: master process /usr/local/nginx/sbin/nginx</span><br><span class="line">nobody    <span class="number">98831</span>  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">1</span>  <span class="number">23088</span>  <span class="number">1636</span> ?        S    <span class="number">09</span>:<span class="number">57</span>   <span class="number">0</span>:<span class="number">00</span> nginx: worker process</span><br><span class="line">root     <span class="number">105254</span>  <span class="number">0</span>.<span class="number">0</span>  <span class="number">0</span>.<span class="number">0</span> <span class="number">112708</span>   <span class="number">976</span> pts/<span class="number">1</span>    R+   <span class="number">11</span>:<span class="number">02</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=auto nginx</span><br></pre></td></tr></table></figure><p><code>access.log</code> 访问日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost logs]# tail -f -n 20  access.log</span><br><span class="line"></span><br><span class="line">192.168.5.199 - - [04/Mar/2019:10:02:10 +0800] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36"</span><br><span class="line">192.168.5.199 - - [04/Mar/2019:10:02:10 +0800] "GET /favicon.ico HTTP/1.1" 404 555 "http://192.168.5.154/" "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36"</span><br></pre></td></tr></table></figure><h3 id="1-2-日志分割"><a href="#1-2-日志分割" class="headerlink" title="1.2 日志分割"></a>1.2 日志分割</h3><p>Nginx日志都会存在一个文件里，随着时间推移，这个日志文件会变得非常大，分析的时候很难操作，所以需要对日志文件进行分割，可以根据访问量来进行选择：如按照天分割、或者半天、小时等。</p><p>建议使用shell脚本方式进行切割日志 。</p><h4 id="1-编写脚本"><a href="#1-编写脚本" class="headerlink" title="1. 编写脚本"></a>1. 编写脚本</h4><p>脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"><span class="meta">#</span>根路径</span><br><span class="line">BASE_DIR=/usr/local/nginx</span><br><span class="line"><span class="meta">#</span>最开始的日志文件名</span><br><span class="line">BASE_FILE_NAME_ACCESS=access.log</span><br><span class="line">BASE_FILE_NAME_ERROR=error.log</span><br><span class="line">BASE_FILE_NAME_PID=nginx.pid</span><br><span class="line"><span class="meta">#</span>默认日志存放路径</span><br><span class="line">DEFAULT_PATH=$BASE_DIR/logs</span><br><span class="line"><span class="meta">#</span>日志备份根路径</span><br><span class="line">BASE_BAK_PATH=$BASE_DIR/datalogs</span><br><span class="line"></span><br><span class="line">BAK_PATH_ACCESS=$BASE_BAK_PATH/access</span><br><span class="line">BAK_PATH_ERROR=$BASE_BAK_PATH/error</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>默认日志文件路径+文件名</span><br><span class="line">DEFAULT_FILE_ACCESS=$DEFAULT_PATH/$BASE_FILE_NAME_ACCESS</span><br><span class="line">DEFAULT_FILE_ERROR=$DEFAULT_PATH/$BASE_FILE_NAME_ERROR</span><br><span class="line"><span class="meta">#</span>备份时间</span><br><span class="line">BAK_TIME=`/bin/date -d yesterday +%Y%m%d%H%M`</span><br><span class="line"><span class="meta">#</span>备份文件 路径+文件名</span><br><span class="line">BAK_FILE_ACCESS=$BAK_PATH_ACCESS/$BAK_TIME-$BASE_FILE_NAME_ACCESS</span><br><span class="line">BAK_FILE_ERROR=$BAK_PATH_ERROR/$BAK_TIME-$BASE_FILE_NAME_ERROR</span><br><span class="line">        </span><br><span class="line"><span class="meta">#</span> 打印一下备份文件 </span><br><span class="line">echo access.log备份成功：$BAK_FILE_ACCESS</span><br><span class="line">echo error.log备份成功：$BAK_FILE_ERROR</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>移动文件</span><br><span class="line">mv $DEFAULT_FILE_ACCESS $BAK_FILE_ACCESS</span><br><span class="line">mv $DEFAULT_FILE_ERROR $BAK_FILE_ERROR</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>向nginx主进程发信号重新打开日志</span><br><span class="line">kill -USR1 `cat $DEFAULT_PATH/$BASE_FILE_NAME_PID`</span><br></pre></td></tr></table></figure><p> 其实很简单，主要步骤如下：</p><ul><li>1.移动日志文件：这里已经将日志文件移动到<code></code>datalogs`目录下了，但Nginx还是会继续往这里面写日志</li><li>2.发送<code>USR1</code>命令：告诉Nginx把日志写到<code></code>Nginx.conf`中配置的那个文件中，这里会重新生成日志文件</li></ul><p>具体如下：</p><ul><li><strong>第一步</strong>:就是重命名日志文件，不用担心重命名后nginx找不到日志文件而丢失日志。在你未重新打开原名字的日志文件前(即执行第二步之前)，nginx还是会向你重命名的文件写日志，Linux是靠<code>文件描述符</code>而不是<code>文件名</code>定位文件。</li><li><strong>第二步</strong>:向nginx主进程发送<code>USR1信号</code>。nginx主进程接到信号后会从配置文件中读取日志文件名称，重新打开日志文件(以配置文件中的日志名称命名)，并以工作进程的用户作为日志文件的所有者。重新打开日志文后，nginx主进程会关闭重名的日志文件并通知工作进程使用新打开的日志文件。(就不会继续写到前面备份的那个文件中了)工作进程立刻打开新的日志文件并关闭重名名的日志文件。然后你就可以处理旧的日志文件了。</li></ul><h4 id="2-赋权"><a href="#2-赋权" class="headerlink" title="2. 赋权"></a>2. 赋权</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# chmod 777 log.sh</span><br></pre></td></tr></table></figure><p>将<code>log.sh</code>脚本设置为可执行文件</p><h4 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h4><p>设置一个定时任务用于周期性的执行该脚本</p><p><code>cron</code>是一个linux下的定时执行工具，可以在无需人工干预的情况下运行作业。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service crond start   //启动服务</span><br><span class="line"></span><br><span class="line">service crond stop    //关闭服务</span><br><span class="line"></span><br><span class="line">service crond restart  //重启服务</span><br><span class="line"></span><br><span class="line">service crond reload  //重新载入配置</span><br><span class="line"></span><br><span class="line">service crond status  //查看服务状态</span><br></pre></td></tr></table></figure><p><strong>设置定时任务</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost datalogs]# crontab -e</span><br><span class="line"></span><br><span class="line">*/1 * * * * sh /usr/local/nginx/sbin/log.sh</span><br></pre></td></tr></table></figure><p><code>*/1 * * * *</code>： 为定时时间 这里为了测试 是设置的每分钟执行一次；</p><p><code>0 2 * * *</code> :每天凌晨两点执行</p><p><code>sh</code> ：为任务类型 这里是一个sh脚本</p><p><code>/usr/local/nginx/sbin/log.sh</code> ：为脚本路径</p><h4 id="4-Nginx信号量"><a href="#4-Nginx信号量" class="headerlink" title="4. Nginx信号量"></a>4. Nginx信号量</h4><p>Nginx支持以下几种信号选项：</p><ul><li><strong>TERM，INT</strong> :  快速关闭</li><li><strong>QUIT</strong> ：从容关闭（优雅的关闭进程,即等请求结束后再关闭)</li><li><strong>HUP</strong> ：平滑重启，重新加载配置文件 （平滑重启，修改配置文件之后不用重启服务器。直接kill -PUT 进程号即可）</li><li><strong>USR1</strong> ：重新读取日志文件，在切割日志时用途较大（停止写入老日志文件，打开新日志文件，之所以这样是因为老日志文件就算修改的文件名，由于inode的原因，nginx还会一直往老的日志文件写入数据） </li><li><strong>USR2</strong> ：平滑升级可执行程序  ，nginx升级时候用                           　　　　 </li><li><strong>WINCH</strong> ：从容关闭工作进程 </li></ul><h2 id="2-cron表达式"><a href="#2-cron表达式" class="headerlink" title="2.cron表达式"></a>2.cron表达式</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><p>　cron表达式代表一个时间的集合，使用6个空格分隔的字段表示：</p><table><thead><tr><th>字段名</th><th>是否必须</th><th>允许的值</th><th>允许的特定字符</th></tr></thead><tbody><tr><td>秒(Seconds)</td><td>是</td><td>0-59</td><td>* / , -</td></tr><tr><td>分(Minute)</td><td>是</td><td>0-59</td><td>* / , -</td></tr><tr><td>时(Hours)</td><td>是</td><td>0-23</td><td>* / , -</td></tr><tr><td>日(Day of month)</td><td>是</td><td>1-31</td><td>* / , - ?</td></tr><tr><td>月(Month)</td><td>是</td><td>1-12 或 JAN-DEC</td><td>* / , -</td></tr><tr><td>星期(Day of week)</td><td>否</td><td>0-6 或 SUM-SAT</td><td>* / , - ?</td></tr></tbody></table><p>注：月(Month)和星期(Day of week)字段的值不区分大小写，如：SUN、Sun 和 sun 是一样的。 </p><p><strong>星期字段没提供相当于<code>*</code></strong></p><p><strong>一般只需要写5位就行了。即 <code>分 时 日 月 周</code></strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ┌───────────── min (0 - 59)</span><br><span class="line"># │ ┌────────────── hour (0 - 23)</span><br><span class="line"># │ │ ┌─────────────── day of month (1 - 31)</span><br><span class="line"># │ │ │ ┌──────────────── month (1 - 12)</span><br><span class="line"># │ │ │ │ ┌───────────────── day of week (0 - 6) (0 to 6 are Sunday to</span><br><span class="line"># │ │ │ │ │                  Saturday, or use names; 7 is also Sunday)</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># * * * * *  command to execute</span><br></pre></td></tr></table></figure><h3 id="2-2-特定字符"><a href="#2-2-特定字符" class="headerlink" title="2.2 特定字符"></a>2.2 特定字符</h3><ul><li><strong>星号(*)</strong>:表示 cron 表达式能匹配该字段的所有值。如在第2个字段使用星号(hour)，表示每小时</li><li><strong>斜线(/)</strong>:表示增长间隔，如第1个字段(minutes) 值是 <code>3/1</code>，表示每小时的第3分钟开始执行一次，之后每隔1分钟执行一次（1,2,3,4….59都执行一次）</li><li><strong>逗号(,)</strong>:用于枚举值，如第6个字段值是 MON,WED,FRI，表示 星期一、三、五 执行。</li><li><strong>连字号(-)</strong>:表示一个范围，如第3个字段的值为 9-17 表示 9am 到 5pm 之间每个小时（包括9和17）</li><li><strong>问号(?)</strong>:只用于 日(Day of month) 和 星期(Day of week)，表示不指定值，可以用于代替 *</li></ul><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><p><code>https://www.cnblogs.com/crazylqy/p/6891929.html</code></p><p><code>http://www.runoob.com/linux/nginx-install-setup.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要对Nginx服务器的日志文件分析，包括&lt;code&gt;日志文件切割&lt;/code&gt;与&lt;code&gt;cron定时任务&lt;/code&gt;语法详解。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://www.lixueduan.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://www.lixueduan.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门教程(二)---配置文件详解</title>
    <link href="https://www.lixueduan.com/posts/5a0a337e.html"/>
    <id>https://www.lixueduan.com/posts/5a0a337e.html</id>
    <published>2019-03-02T14:00:00.000Z</published>
    <updated>2019-03-05T12:15:17.878Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要对Nginx服务器的常用配置文件，包括虚拟主机配置，location配置级语法等。</p><a id="more"></a><blockquote><p><strong><a href="https://www.lixueduan.com/categories/">Nginx入门教程系列文章目录</a></strong></p><p><a href="https://www.lixueduan.com/posts/545ed69.html">Nginx入门教程(一)—安装与配置</a></p><p><a href="https://www.lixueduan.com/posts/5a0a337e.html">Nginx入门教程(二)—配置文件详解</a></p><p><a href="https://www.lixueduan.com/posts/3ebafd31.html">Nginx入门教程(三)—日志文件切割</a></p><p><a href="https://www.lixueduan.com/posts/930200c5.html">Nginx入门教程(四)—反向代理与负载均衡</a></p><p>……</p><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-虚拟主机配置"><a href="#1-虚拟主机配置" class="headerlink" title="1. 虚拟主机配置"></a>1. 虚拟主机配置</h2><p>在前面启动Nignx后，Nginx目录下会多出几个文件夹</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx</span><br><span class="line">--conf配置文件</span><br><span class="line">--html  网页文件</span><br><span class="line">--logs  日志文件</span><br><span class="line">--sbin  主要二进制文件</span><br><span class="line"></span><br><span class="line">--client_body_temp</span><br><span class="line">--fastcgi_temp</span><br><span class="line">--proxy_temp</span><br><span class="line">--scgi_temp</span><br><span class="line">--uwsgi_temp</span><br></pre></td></tr></table></figure><p>不过这些<code>temp</code>文件夹都不是重点。</p><h3 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1 配置文件"></a>1.1 配置文件</h3><p>这里讲解一下<code>conf</code>里的配置文件，有很多配置文件，重点看<code>nginx.conf</code>.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/conf</span><br><span class="line">-- fastcgi.conf</span><br><span class="line">-- fastcgi.conf.default</span><br><span class="line"> -- fastcgi_params</span><br><span class="line">-- fastcgi_params.default</span><br><span class="line">-- koi-utf</span><br><span class="line"> -- koi-win</span><br><span class="line"> -- mime.types</span><br><span class="line"> -- mime.types.default</span><br><span class="line"> -- nginx.conf  # 重点关心这个</span><br><span class="line"> -- nginx.conf.default</span><br><span class="line">-- scgi_params</span><br><span class="line">-- scgi_params.default</span><br><span class="line"> -- uwsgi_params</span><br><span class="line">-- uwsgi_params.default</span><br><span class="line"> --win-utf</span><br></pre></td></tr></table></figure><h3 id="1-2-nginx-conf"><a href="#1-2-nginx-conf" class="headerlink" title="1.2 nginx.conf"></a>1.2 nginx.conf</h3><p>看一下默认的<code>nginx.conf</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]# vim nginx.conf</span><br><span class="line">//默认配置如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以指定用户 不过无所谓</span></span><br><span class="line"><span class="comment">#user  nobody;   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx工作进程,一般设置为和cpu核数一样</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志存放目录 </span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进程pid存放位置</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># 单个CPU最大连接数</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http 这里重点</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment">#文件扩展名与类型映射表</span></span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#设置日志模式</span></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#开启高效传输模式  </span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 激活tcp_nopush参数可以允许把httpresponse header和文件的开始放在一个文件里发布</span></span><br><span class="line">    <span class="comment"># 积极的作用是减少网络报文段的数量</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#连接超时时间，单位是秒</span></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#开启gzip压缩功能</span></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#基于域名的虚拟主机</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="comment">#域名</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="comment">#字符集</span></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">#nginx访问日志 这里的main就是上面配置的那个log_format  main </span></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#location 标签</span></span><br><span class="line">        <span class="comment">#这里的/表示匹配根目录下的/目录</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment">#站点根目录，即网站程序存放目录</span></span><br><span class="line">   <span class="comment">#就是上面的四个文件夹中的html文件夹</span></span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="comment">#首页排序 默认找index.html 没有在找index.htm</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment"># 错误页面</span></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#错误页面 错误码为500 502 503 504时 重定向到50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="comment">#location 标签</span></span><br><span class="line">        <span class="comment">#这里的表示匹配根目录下的/50x.html</span></span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">  <span class="comment"># concurs with nginx's one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-基本配置"><a href="#1-3-基本配置" class="headerlink" title="1.3 基本配置"></a>1.3 基本配置</h3><p>上面的配置文件好像挺长的，其实最重要的就那么几个。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80; //端口号</span><br><span class="line">        server_name localhost; //域名</span><br><span class="line">        <span class="attribute">location</span> \ &#123;</span><br><span class="line">            root html; //网站根目录</span><br><span class="line">            index index.html; //网站首页</span><br><span class="line">        &#125;  </span><br><span class="line">        access_log  logs/host.access.log  main; //访问日志</span><br><span class="line">        error page 500 error.html; //错误页面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-location"><a href="#2-location" class="headerlink" title="2. location"></a>2. location</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><code>nginx.conf</code>大概内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen <span class="number">80</span>; <span class="comment">//端口号</span></span><br><span class="line">        server_name localhost; <span class="comment">//域名</span></span><br><span class="line">        location \ &#123;</span><br><span class="line">            root html; <span class="comment">//网站根目录</span></span><br><span class="line">            index index.html; <span class="comment">//网站首页</span></span><br><span class="line">        &#125;  </span><br><span class="line">        access_log  logs/host.access.log  main; <span class="comment">//访问日志</span></span><br><span class="line">        error page <span class="number">500</span> error.html; <span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>server</code>代表虚拟主机，一个虚拟主机可以配置多个<code>location</code></p><p><code>location</code>表示uri方法定位</p><p>基本语法如下：</p><ul><li>1.location=pattern{} 静准匹配</li><li>2.location pattern{} 一般匹配</li><li>3.location~pattern{} 正则匹配</li></ul><p><strong>Nginx可以对数据进行压缩，对一些图片、css、js、html等文件进行缓存，从而实现动静分离等待优化功能</strong>。</p><p><strong>动态的就去访问tomcat服务器，静态的就直接访问Nginx服务器</strong>。</p><p><strong>基本语法</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> [=|~|~*|^~|@] /uri/ &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>〖=〗 表示精确匹配，如果找到，立即停止搜索并立即处理此请求。<br>〖~ 〗 表示区分大小写匹配<br>〖~*〗 表示不区分大小写匹配<br>〖^~ 〗 表示只匹配字符串,不查询正则表达式。</p><p>〖@〗 指定一个命名的location，一般只用于内部重定向请求。</p><h3 id="2-2-正则表达式"><a href="#2-2-正则表达式" class="headerlink" title="2.2 正则表达式"></a>2.2 正则表达式</h3><p>1.语法格式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> [=|~|~*|^~|@]   /uri/ &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.依据不同的前缀<code>=</code>，<code>^~</code>,<code>~</code>，<code>~*</code> ”和<code>不带任何前缀</code>(因为[ ] 表示可选，可以不要的)表达不同的含义。<br> 简单的说尽管location 的/uri/ 配置一样，但前缀不一样，表达的是不同的指令含义。<br><strong>注意：查询字符串不在URI范围内。例如：/films.htm?fid=123 的URI 是/films.htm</strong>。</p><p>2.对这些不同前缀，分下类，就2 大类：</p><ul><li><strong>正则location</strong> : <code>~</code>和<code>~*</code>前缀表示正则location ，<code>~</code>区分大小写，<code>~*</code>不区分大小写。</li><li><strong>普通location</strong> : <code>=</code>，<code>^~</code>和<code>@</code>和  <code>无任何前缀</code>, 都属于普通location 。</li></ul><p><strong>详细说明</strong>：</p><ul><li><p><strong>~</strong>  : 区分大小写匹配</p></li><li><p><strong>~*</strong> : 不区分大小写匹配</p></li><li><p><strong>!~</strong> :  区分大小写不匹配</p></li><li><p><strong>!~*</strong> : 不区分大小写不匹配</p></li><li><p><strong>^</strong> : 以什么开头的匹配</p></li><li><p><strong>$</strong> : 以什么结尾的匹配</p></li><li><strong>*</strong> : 代表任意字符</li></ul><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><p><code>http://www.runoob.com/linux/nginx-install-setup.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要对Nginx服务器的常用配置文件，包括虚拟主机配置，location配置级语法等。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://www.lixueduan.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://www.lixueduan.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门教程(一)---安装与配置</title>
    <link href="https://www.lixueduan.com/posts/545ed69.html"/>
    <id>https://www.lixueduan.com/posts/545ed69.html</id>
    <published>2019-03-01T14:00:00.000Z</published>
    <updated>2019-03-05T12:15:29.821Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要对Nginx服务器进行了介绍，同时对Nginx与Apache之间做出了对比，最后记录了如何在Linux下通过解压方式安装Nginx，也对Nginx基本使用做出了说明。</p><a id="more"></a><blockquote><p><strong><a href="https://www.lixueduan.com/categories/">Nginx入门教程系列文章目录</a></strong></p><p><a href="https://www.lixueduan.com/posts/545ed69.html">Nginx入门教程(一)—安装与配置</a></p><p><a href="https://www.lixueduan.com/posts/5a0a337e.html">Nginx入门教程(二)—配置文件详解</a></p><p><a href="https://www.lixueduan.com/posts/3ebafd31.html">Nginx入门教程(三)—日志文件切割</a></p><p><a href="https://www.lixueduan.com/posts/930200c5.html">Nginx入门教程(四)—反向代理与负载均衡</a></p><p>……</p><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-Nginx简介"><a href="#1-Nginx简介" class="headerlink" title="1. Nginx简介"></a>1. Nginx简介</h2><p>Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是<strong>占有内存少，并发能力强</strong>，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。 </p><h3 id="1-1-Nginx模块架构"><a href="#1-1-Nginx模块架构" class="headerlink" title="1.1 Nginx模块架构"></a>1.1 Nginx模块架构</h3><p>Nginx 由内核和模块组成。Nginx 的模块从结构上分为<code>核心模块</code>、<code>基础模块</code>和<code>第三方模块</code>。</p><ul><li><strong>核心模块</strong>：HTTP 模块、 EVENT 模块和 MAIL 模块</li><li><strong>基础模块</strong>： HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy 模块和 HTTP Rewrite模块</li><li><strong>第三方模块</strong>：HTTP Upstream Request Hash 模块、 Notice 模块和 HTTP Access Key模块 </li></ul><h3 id="1-2-Nignx与Appache"><a href="#1-2-Nignx与Appache" class="headerlink" title="1.2 Nignx与Appache"></a>1.2 Nignx与Appache</h3><p><code>Nginx</code>的高并发得益于其采用了<code>epoll</code>模型，与传统的服务器程序架构不同<code>epoll</code> 是<code>linux内核2.6</code>以后才出现的。</p><p><strong><code>Nginx</code>采用<code>epoll</code>模型，异步非阻塞，而<code>Apache</code>采用的是<code>select 模型</code> </strong>。</p><ul><li><strong>Select模型</strong>：select 选择句柄的时候是遍历所有句柄，也就是说句柄有事件响应时，select 需要遍历所有句柄才能获取到哪些句柄有事件通知，因此效率是非常低。</li><li><strong>epoll 模型</strong>：epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高。</li></ul><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p>注：这里用的是<code>CentOS 7</code></p><h3 id="2-1-安装包下载"><a href="#2-1-安装包下载" class="headerlink" title="2.1 安装包下载"></a>2.1 安装包下载</h3><p>官网：<code>http://nginx.org/en/download.html</code> 这里下载的时<code>nginx-1.15.9.tar.gz</code></p><p>上传到服务器上，这里放在了<code>usr/software</code>目录下</p><h3 id="2-2-环境准备"><a href="#2-2-环境准备" class="headerlink" title="2.2 环境准备"></a>2.2 环境准备</h3><p><strong>安装编译源码所需要的工具和库</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install gcc gcc-c++ ncurses-devel perl</span><br></pre></td></tr></table></figure><p><strong>安装HTTP rewrite module模块</strong>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install pcre pcre-devel</span><br></pre></td></tr></table></figure><p><strong>安装HTTP zlib模块</strong>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install zlib gzip zlib-devel</span><br></pre></td></tr></table></figure><h3 id="2-3-编译安装"><a href="#2-3-编译安装" class="headerlink" title="2.3 编译安装"></a>2.3 编译安装</h3><p><strong>解压</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost software]# tar -zxvf nginx-1.15.9.tar.gz -C /usr/local</span><br><span class="line">//解压到/usr/local目录下</span><br></pre></td></tr></table></figure><p><strong>配置</strong>:</p><p>进行configure配置，检查是否报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.15.9]# ./configure --prefix=/usr/local/nginx</span><br><span class="line"></span><br><span class="line">//出现下面的配置摘要就算配置ok</span><br><span class="line">Configuration summary</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + OpenSSL library is not used</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: &quot;/usr/local/nginx&quot;</span><br><span class="line">  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;</span><br><span class="line">  .....</span><br><span class="line">  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;</span><br><span class="line">  nginx http scgi temporary files: &quot;scgi_temp&quot;</span><br></pre></td></tr></table></figure><p><strong>编译安装</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.15.9]# make&amp;&amp;make install</span><br><span class="line"></span><br><span class="line">//出现下面的提示就算编译安装ok</span><br><span class="line">make[1]: Leaving directory `/usr/local/nginx-1.15.9&apos;</span><br></pre></td></tr></table></figure><p>编译安装后多了一个<code></code>Nginx<code>文件夹,在</code>/usr/local/nginx` 内部又分为四个目录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx</span><br><span class="line">--conf配置文件</span><br><span class="line">--html  网页文件</span><br><span class="line">--logs  日志文件</span><br><span class="line">--sbin  主要二进制文件</span><br></pre></td></tr></table></figure><p><strong>查看Nginx版本:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# /usr/local/nginx/sbin/nginx -v</span><br><span class="line">nginx version: nginx/1.15.9</span><br><span class="line">//这里是Nginx 1.15.9</span><br></pre></td></tr></table></figure><p>到这里<code></code>Nginx`安装就结束了。</p><h2 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h2><h3 id="3-1-启动"><a href="#3-1-启动" class="headerlink" title="3.1 启动"></a>3.1 启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx</span><br><span class="line"></span><br><span class="line">//这里如果没有报错就说明启动成功了</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# ps aux|grep nginx</span><br><span class="line">root      98830  0.0  0.0  20552   616 ?        Ss   09:57   0:00 nginx: master process /usr/local/nginx/sbin/nginx</span><br><span class="line">nobody    98831  0.0  0.1  23088  1392 ?        S    09:57   0:00 nginx: worker process</span><br><span class="line">root      98839  0.0  0.0 112708   976 pts/1    R+   09:57   0:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure><p>可以看到Nginx有两个进程，一个<code>master进程</code>一个<code>worker进程</code>.</p><p>同时浏览器已经可以访问了:直接访问IP地址即可<code>http://192.168.5.154/</code></p><p>显示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Welcome to nginx!</span><br><span class="line">If you see <span class="keyword">this</span> page, the nginx web server is successfully installed and working. Further configuration is required.</span><br><span class="line"></span><br><span class="line">For online documentation and support please refer to nginx.org.</span><br><span class="line">Commercial support is available at nginx.com.</span><br><span class="line"></span><br><span class="line">Thank you <span class="keyword">for</span> using nginx.</span><br></pre></td></tr></table></figure><p>说明<code>Nginx</code>确实已经启动了。</p><h3 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx -s reload   # 重新载入配置文件</span><br><span class="line"></span><br><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx -s reopen   # 重启 Nginx</span><br><span class="line"></span><br><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx -s stop     # 停止 Nginx</span><br></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>http://www.runoob.com/linux/nginx-install-setup.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要对Nginx服务器进行了介绍，同时对Nginx与Apache之间做出了对比，最后记录了如何在Linux下通过解压方式安装Nginx，也对Nginx基本使用做出了说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://www.lixueduan.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://www.lixueduan.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock源码分析</title>
    <link href="https://www.lixueduan.com/posts/ef6a0c58.html"/>
    <id>https://www.lixueduan.com/posts/ef6a0c58.html</id>
    <published>2019-02-24T08:00:00.000Z</published>
    <updated>2019-02-24T08:20:14.810Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对<code>ReentrantLock</code>的源码进行了简单的分析，具体包括<code>ReentrantLock</code>的初始化(公平锁和非公平锁)，加锁过程和解锁过程等。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-AbstractQueuedSynchronizer"><a href="#1-AbstractQueuedSynchronizer" class="headerlink" title="1. AbstractQueuedSynchronizer"></a>1. AbstractQueuedSynchronizer</h2><p><code>ReentrantLock</code>的实现依赖于<code>AbstractQueuedSynchronizer</code>所以需要了解一下<code>AQS</code>。</p><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>类如其名，<code>抽象的队列式的同步器</code>，AQS定义了一套多线程访问共享资源的同步器框架，是<code>java.util.concurrent</code>的核心，<code>CountDownLatch</code>、<code>FutureTask</code>、<code>Semaphore</code>、<code>ReentrantLock</code>等都有一个内部类是这个抽象类的子类。</p><p>AQS定义两种资源共享方式：</p><ul><li>Exclusive: 独占，只有一个线程能执行,如ReentrantLock</li><li>Share: 共享，多个线程可同时执行，如Semaphore/CountDownLatch</li></ul><h3 id="1-2-AQS的4个属性"><a href="#1-2-AQS的4个属性" class="headerlink" title="1.2 AQS的4个属性"></a>1.2 AQS的4个属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，大概可以看做是当前持有锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">//当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁 </span></span><br><span class="line"><span class="comment">//是可重入锁 每次获取都活加1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程 锁重入时用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><h3 id="1-3-阻塞队列Node节点的属性"><a href="#1-3-阻塞队列Node节点的属性" class="headerlink" title="1.3 阻塞队列Node节点的属性"></a>1.3 阻塞队列Node节点的属性</h3><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/source_code/aqs-wait-queue.png" alt="CLH队列"></p><p>Node 的数据结构其实也挺简单的，就是 <code>thread</code> + <code>waitStatus</code> + <code>pre</code> + <code>next</code> 四个属性而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// 表示此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="comment">//被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，</span></span><br><span class="line">    <span class="comment">//将会通知该后继结点的线程执行。</span></span><br><span class="line">    <span class="comment">//就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">//该标识的结点处于等待队列中，结点的线程等待在Condition上,等待其他线程唤醒</span></span><br><span class="line">    <span class="comment">//当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将</span></span><br><span class="line">    <span class="comment">//从等待队列转移到同步队列中，等待获取同步锁。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// =====================================================</span></span><br><span class="line"><span class="comment">// 节点的等待状态</span></span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">// 也许就是说半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的</span></span><br><span class="line">    <span class="comment">//AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程对象</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ReentrantLock的使用"><a href="#2-ReentrantLock的使用" class="headerlink" title="2. ReentrantLock的使用"></a>2. ReentrantLock的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server层</span></span><br><span class="line"><span class="comment"> * 模拟ReentrantLock使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> illusoryCloud</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是非公平锁 传入参数true则创建的是公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加锁 同一时刻只能有一个线程更新User</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁放在finally代码块中 保证出现异常等情况也能释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ReentrantLock源码分析"><a href="#3-ReentrantLock源码分析" class="headerlink" title="3. ReentrantLock源码分析"></a>3. ReentrantLock源码分析</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><p><code>ReentrantLock reentrantLock = new ReentrantLock(true);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *默认是非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-加锁过程"><a href="#2-加锁过程" class="headerlink" title="2. 加锁过程"></a>2. 加锁过程</h3><p><code>reentrantLock.lock();</code></p><p>公平锁实现如下(JDK1.8)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sync object for fair locks</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"><span class="comment">//争锁</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//1</span></span><br><span class="line">          acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;  </span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">       * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">              <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>1. acquire(1);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryAcquire(1) 首先尝试获取一下锁</span></span><br><span class="line">    <span class="comment">//若成功则不需要进入等待队列了</span></span><br><span class="line">    <span class="comment">//1.1</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//1.2</span></span><br><span class="line">        <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//1.3</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.1 tryAcquire(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> * 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment"> * 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//查看锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//state == 0 此时此刻没有线程持有锁 可以直接获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//由于是公平锁 则在获取锁之前先看一下队列中还有没有其他等待的线程</span></span><br><span class="line">        <span class="comment">//讲究先来后到 所以是公平锁  这也是和非公平锁的差别</span></span><br><span class="line">        <span class="comment">//非公平锁在这里会直接尝试获取锁</span></span><br><span class="line">        <span class="comment">//1.1.1</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">           <span class="comment">// 如果没有线程在等待，那就用CAS尝试获取一下锁</span></span><br><span class="line">           <span class="comment">// 不成功的话，只能说明几乎同一时刻有个线程抢先获取到了锁</span></span><br><span class="line">           <span class="comment">//因为刚才hasQueuedPredecessors判断是前面没有线程在等待的</span></span><br><span class="line">            <span class="comment">//1.1.2</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//获取到锁后把当前线程设置为锁的拥有者</span></span><br><span class="line">            <span class="comment">//1.1.3</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">//获取锁成功直接返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里说明当前锁已经被占了</span></span><br><span class="line">    <span class="comment">//然后判断如果当前线程就是持有锁的线程</span></span><br><span class="line">    <span class="comment">//那么这次就是锁的重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//把state加1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//1.1.4</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面两个条件都不满足就返回false</span></span><br><span class="line">    <span class="comment">//获取锁失败了 回到上一个方法继续看</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.1.1 hasQueuedPredecessors()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 通过判断"当前线程"是不是在CLH队列的队首</span></span><br><span class="line"><span class="comment">  * 来返回AQS中是不是有比“当前线程”等待更久的线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>1.1.2 compareAndSetState(0, acquires))</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过CAS设置锁的状态</span></span><br><span class="line"><span class="comment"> */</span>     </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>1.1.3 setExclusiveOwnerThread(current)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置锁的拥有者</span></span><br><span class="line"><span class="comment"> */</span>     </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>1.1.4 setState(nextc)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置锁的状态</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到前面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryAcquire(1) 首先尝试获取一下锁</span></span><br><span class="line">    <span class="comment">//若成功则不需要进入等待队列了</span></span><br><span class="line">    <span class="comment">//1.1</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//1.2</span></span><br><span class="line">        <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">        <span class="comment">//addWaiter(Node.EXCLUSIVE) 1.2.1</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//1.3</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.1tryAcquire</code>返回false则继续执行后面的</p><p><code>1.2acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><p><code>1.2.1 addWaiter(Node.EXCLUSIVE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法的作用是把线程包装成node，同时进入到队列中</span></span><br><span class="line"><span class="comment"> * 参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tail!=null --&gt; 队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 设置自己的前驱 为当前的队尾节点</span></span><br><span class="line">            node.prev = pred; </span><br><span class="line">            <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node了</span></span><br><span class="line">            <span class="comment">//1.2.1.1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">                <span class="comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span></span><br><span class="line">                <span class="comment">// 上面已经有 node.prev = pred</span></span><br><span class="line">                <span class="comment">// 加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仔细看看上面的代码，如果会到这里，</span></span><br><span class="line">        <span class="comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">      <span class="comment">//1.2.1.2</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>1.2.1.1 compareAndSetTail(pred, node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CAS设置队列的Tail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>1.2.1.2enq(node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入这个方法只有两种可能：1.等待队列为空 2.有线程竞争入队</span></span><br><span class="line"><span class="comment"> * 采用自旋的方式入队</span></span><br><span class="line"><span class="comment"> * CAS设置tail过程中，竞争一次竞争不到，多次竞争，总会排到的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 如果队列是空的就去初始化</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// CAS初始化head节点</span></span><br><span class="line">                <span class="comment">//1.2.1.2.1</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span></span><br><span class="line">                <span class="comment">// 这个时候有了head，但是tail还是null，设置一下，</span></span><br><span class="line">                <span class="comment">// 设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span></span><br><span class="line">                <span class="comment">// 通过CAS将当前线程排到队尾，有线程竞争的话排不上重复排</span></span><br><span class="line">                <span class="comment">// 直到成功了才return </span></span><br><span class="line">                <span class="comment">// 这里return后前面的addWaiter()方法也返回 </span></span><br><span class="line">                <span class="comment">// 接下来进入acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>1.2 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line"><span class="comment"> * 如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话</span></span><br><span class="line"><span class="comment"> * 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">//这里无线循环 直到下面的条件满足</span></span><br><span class="line">            <span class="comment">//获取当前节点的前一个节点 设置为p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//p=head说明当前节点是队列的第一个 </span></span><br><span class="line">            <span class="comment">// 所以当前节点可以去试抢一下锁</span></span><br><span class="line">            <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">            <span class="comment">// 也就是说，当前的head可能不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">            <span class="comment">// tryAcquire已经分析过了,就是简单用CAS试操作一下state</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这里，说明上面的if分支没有成功</span></span><br><span class="line">            <span class="comment">//要么当前node本来就不是队头</span></span><br><span class="line">            <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人</span></span><br><span class="line">            <span class="comment">//1.2.2</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">//1.2.3</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.2.2 shouldParkAfterFailedAcquire(p, node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入这里说明抢到锁，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line"><span class="comment"> * 第一个参数是前驱节点，第二个参数代表当前线程的节点 这里一共有三个规则</span></span><br><span class="line"><span class="comment"> * 1.如果前继的节点状态为SIGNAL，表明当前节点需要unpark，则返回true 将导致线程阻塞</span></span><br><span class="line"><span class="comment"> * 2.如果前继节点状态为CANCELLED(ws&gt;0)，说明前置节点已经被放弃，则找到一个非取消的前驱节点        *   返回false，acquireQueued方法的无限循环将递归调用该方法，直至规则1返回true</span></span><br><span class="line"><span class="comment"> * 3.如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL</span></span><br><span class="line"><span class="comment"> *  返回false后进入acquireQueued的无限循环，与规则2同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。</span></span><br><span class="line">    <span class="comment">// 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">    <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">    <span class="comment">// 就是为当前节点找一个正常的前驱节点 毕竟当前节点需要等着前驱节点来唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 这里就在循环直到找到一个waitStatus 不大于 0的前驱节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">        <span class="comment">// 前驱节点的waitStatus不等于-1也不大于0，那也就是只可能是0，-2，-3</span></span><br><span class="line">        <span class="comment">// 这里说明一下：每个新的node入队时，waitStatu都是0</span></span><br><span class="line">        <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.2.3  parkAndCheckInterrupt()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span></span><br><span class="line"><span class="comment">  *这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-解锁过程"><a href="#3-解锁过程" class="headerlink" title="3. 解锁过程"></a>3. 解锁过程</h3><p><code>reentrantLock.unlock()</code> 解锁的代码比较相比加锁的要简单不少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1. sync.release(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//1.1 </span></span><br><span class="line">    <span class="comment">//这里尝试释放锁如果成功则进入if里面</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// h赋值为当前的head节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//如果head节点不是null</span></span><br><span class="line">        <span class="comment">//并且head节点的waitStatus不等于0 即head节点不是刚初始化的</span></span><br><span class="line">        <span class="comment">//因为刚初始化是waitStatus是等于0的</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//1.2 </span></span><br><span class="line">            <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.1 tryRelease(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可重入锁 所以state可以大于1 每次释放时state减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//如果当前线程不是拥有锁的线程直接抛出异常 这肯定嘛 都没获取到锁你释放什么</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// state==0了 说明可以完全释放锁了</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//把锁的拥有者设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁的状态设置为0 即没有被获取</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">//到这里 锁已经释放了 </span></span><br><span class="line">    <span class="comment">//回到上边的release(1)方法</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>1.2  unparkSuccessor(h)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> * 唤醒后继节点 如果有的话</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node 参数node是head头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">  <span class="comment">//如果直接后继节点是null或者 waitStatus &gt; 0即取消了等待</span></span><br><span class="line">  <span class="comment">//那么就直接从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从后往前找，不必担心中间有节点取消(waitStatus==1)的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果直接后继节点不是空的就直接唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>https://javadoop.com/post/AbstractQueuedSynchronizer#toc0</code></p><p><code>https://blog.csdn.net/chen77716/article/details/6641477</code></p><p><code>https://www.cnblogs.com/waterystone/p/4920797.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对&lt;code&gt;ReentrantLock&lt;/code&gt;的源码进行了简单的分析，具体包括&lt;code&gt;ReentrantLock&lt;/code&gt;的初始化(公平锁和非公平锁)，加锁过程和解锁过程等。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://www.lixueduan.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="https://www.lixueduan.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>idea下打包SpringBoot项目并部署到Linux服务器</title>
    <link href="https://www.lixueduan.com/posts/144a69f9.html"/>
    <id>https://www.lixueduan.com/posts/144a69f9.html</id>
    <published>2019-02-22T14:00:00.000Z</published>
    <updated>2019-02-22T14:51:15.076Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了如何在idea下打包SpringBoot项目并部署到云服务器，包括jar包和war包两种方式。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>首先简单创建一个<code>hello word</code></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> illusoryCloud</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello illusoryCloud"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringBoot启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> illusoryCloud</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-打包"><a href="#2-打包" class="headerlink" title="2. 打包"></a>2. 打包</h2><h3 id="2-1-jar包和war包区别"><a href="#2-1-jar包和war包区别" class="headerlink" title="2.1 jar包和war包区别"></a>2.1 jar包和war包区别</h3><ul><li>SpringBoot默认支持很多模板引擎，但是JSP只能够在War中使用</li><li>无论是Jar还是War都能够使用嵌套容器，<code>java -jar</code>来独立运行</li><li>但只有war才能部署到外部容器中</li></ul><h3 id="2-2-jar包"><a href="#2-2-jar包" class="headerlink" title="2.2 jar包"></a>2.2 jar包</h3><p><strong>SpringBoot官方推荐打成jar包，服务器上有<code>JDK 1.8</code>以上环境就可以直接运行</strong></p><h4 id="1-修改pom-xml文件"><a href="#1-修改pom-xml文件" class="headerlink" title="1.修改pom.xml文件"></a>1.修改pom.xml文件</h4><p>选择打包方式为jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.illusory<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="comment">&lt;!--打出来的包的名字 hello-0.0.1-SNAPSHOT.jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="comment">&lt;!--打包方式jar/war--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-打包-1"><a href="#2-打包-1" class="headerlink" title="2. 打包"></a>2. 打包</h4><p>然后用maven打包。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/springboot/project-package.png" alt="SpringBoot打包"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- maven-jar-plugin:<span class="number">3.1</span>.1:jar (<span class="keyword">default</span>-jar) @ hello ---</span><br><span class="line">[INFO] Building jar: D:\lillusory\MyProjects\hello\target\hello-<span class="number">0.0</span>.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:<span class="number">2.1</span>.3.RELEASE:repackage (repackage) @ hello ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  <span class="number">23.922</span> s</span><br><span class="line">[INFO] Finished at: <span class="number">2019</span>-<span class="number">02</span>-<span class="number">22</span>T20:<span class="number">35</span>:<span class="number">40</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>日志中可以看到打出来的包在<code>D:\lillusory\MyProjects\hello\target\hello-0.0.1-SNAPSHOT.jar</code></p><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h4><p>SpringBoot内置了一个Tomcat，可以直接<code>java -jar jarName</code>运行。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/springboot/jar-run.png" alt=""></p><p>浏览器访问<code>http://localhost:8080/hello</code>出现<code>hello illusoryCloud</code>说明运行起来了。</p><p>这里的端口号是<code>application.yml</code>全局配置文件中配置的端口号。</p><h3 id="2-3-war包"><a href="#2-3-war包" class="headerlink" title="2.3 war包"></a>2.3 war包</h3><p>同时也可以打成war包然后用服务器上的Tomcat启动。</p><h4 id="1-修改pom-xml"><a href="#1-修改pom-xml" class="headerlink" title="1.修改pom.xml"></a>1.修改pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.illusory<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="comment">&lt;!--打出来的包的名字 hello-0.0.1-SNAPSHOT.jar--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>    <span class="comment">&lt;!--打包方式jar/war--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--外置tomcat启动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>maven中的<code>&lt;scope&gt;provided&lt;/scope&gt;</code>表示这个jar包在编译测试等地方是需要的，但是打包不会一起打包进去，这也避免了此类构件当部署到目标容器后产生包依赖冲突</strong>。由于SpringBoot内置了Tomcat所以这里需要重新配置一下，防止冲突。</p><h4 id="2-改造启动类"><a href="#2-改造启动类" class="headerlink" title="2.改造启动类"></a>2.改造启动类</h4><p><strong>SpringBoot 内置的Tomcat能认识自己的启动项,而外部tomcat是不认识的</strong></p><p>所以需要修改启动类。即继承<code>SpringBootServletInitializer</code>类实现<code>configure</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringBoot启动类</span></span><br><span class="line"><span class="comment"> * 打成war包时需要改造 继承SpringBootServletInitializer实现configure方法</span></span><br><span class="line"><span class="comment"> * 打jar包则不需要</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> illusoryCloud</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//这里的HelloApplication是SpringBoot的启动类</span></span><br><span class="line">        <span class="keyword">return</span> builder.sources(HelloApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-打包"><a href="#3-打包" class="headerlink" title="3. 打包"></a>3. 打包</h4><p>和上面打包的方式一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Packaging webapp</span><br><span class="line">[INFO] Assembling webapp [hello] in [D:\lillusory\MyProjects\hello\target\hello-<span class="number">0.0</span>.1-SNAPSHOT]</span><br><span class="line">[INFO] Processing war project</span><br><span class="line">[INFO] Webapp assembled in [<span class="number">472</span> msecs]</span><br><span class="line">[INFO] Building war: D:\lillusory\MyProjects\hello\target\hello-<span class="number">0.0</span>.1-SNAPSHOT.war</span><br><span class="line">[INFO] --- spring-boot-maven-plugin:<span class="number">2.1</span>.3.RELEASE:repackage (repackage) @ hello ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  <span class="number">01</span>:<span class="number">00</span> min</span><br><span class="line">[INFO] Finished at: <span class="number">2019</span>-<span class="number">02</span>-<span class="number">22</span>T21:<span class="number">10</span>:<span class="number">10</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到打出来的war包在<code>D:\lillusory\MyProjects\hello\target\hello-0.0.1-SNAPSHOT.war</code></p><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h4><p>先在电脑上测试一下(Windows环境下)</p><p>将war包复制到<code>Tomcat</code>的<code>webapps</code>文件夹下</p><p>然后找到<code>bin</code>目录下的<code>startup.bat</code>启动Tomcat，项目就会自动启动了。</p><p>浏览器访问<code>http://localhost:8080/hello-0.0.1-SNAPSHOT/hello</code> 出现<code>hello illusoryCloud</code>说明ok的。</p><p>这里<code>hello-0.0.1-SNAPSHOT</code>就是war包的名称，Tomcat启动时会自动解压war包然后启动项目。</p><p>这里的端口号和<code>application.yml</code>全局配置文件中配置的端口号没有关系，是Tomcat中配置的。</p><p>在<code>Tomcat\conf\server.xml</code>这个文件中，默认也是8080。</p><p><strong>问题</strong></p><p>我这里启动的时候出现了一个问题</p><p><code>Caused by: java.lang.NoClassDefFoundError: javax/el/ELManager</code></p><p>最后找到原因是<strong>tomcat提供的<code>el-api.jar</code> 和项目里面的el-api.jar冲突</strong>;</p><p>这时候你需要去找到自己电脑上用的el-api的版本,copy到tomcat的lib目录下,覆盖原来的jar包.</p><p>我的在<code>IntelliJ IDEA 2018.3\lib\rt\jasper2.1\el-api.jar</code>这个目录下</p><p>我看网上说是和Tomcat版本有关系，我这里是<code>7.0.52</code></p><p><strong>Tomcat日志</strong></p><p>若是还有其他问题的话可以查看Tomcat日志。在<code>tomcat\logs\catalina.2019-02-22.log</code>这个文件中。</p><h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h2><h3 id="3-1-jar包"><a href="#3-1-jar包" class="headerlink" title="3.1 jar包"></a>3.1 jar包</h3><p>首先将文件上传到服务器上，服务器上有安装JDK8及以上的版本就可以直接运行。</p><p><a href="https://www.lixueduan.com/posts/54978294.html">Linux下JDK的安装及配置点这里</a></p><h4 id="1-前台运行"><a href="#1-前台运行" class="headerlink" title="1. 前台运行"></a>1. 前台运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -jar hello-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>但是这样运行的话是在前台运行，当前窗口关闭后就停止了,或者是运行时没法切出去执行其他任务.</p><h4 id="2-后台运行"><a href="#2-后台运行" class="headerlink" title="2. 后台运行"></a>2. 后台运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt;temp.txt &amp;</span><br><span class="line"></span><br><span class="line">//nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行</span><br><span class="line">//这种方法会把日志文件输入到你指定的文件中(temp.txt)</span><br><span class="line">//在哪个目录下运行的该日志文件就会在哪个目录下，没有指定具体文件则会自动创建(nohup.out)</span><br><span class="line">//&amp; 表示后台运行</span><br></pre></td></tr></table></figure><h4 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h4><p>执行以上命令后出现下面的提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup: ignoring input and redirecting stderr to stdout</span><br><span class="line">忽略输出 将错误输出重定向到标准输出</span><br></pre></td></tr></table></figure><p><strong>原因</strong></p><p><code>Linux</code>中<code>0</code>、<code>1</code>和<code>2</code>分别表示<code>标准输</code>入、<code>标准输出</code>和<code>标准错误信息输出</code>，可以用来指定需要重定向的标准输入或输出。在一般使用时，默认的是标准输出，即1。</p><p>例如：<code>2&gt;temp.txt</code>  就是将错误信息写入temp.txt 标准输出还是显示在屏幕上。</p><p>另外，也可以实现0，1，2之间的重定向。<code>2&gt;&amp;1</code>：将错误信息重定向到标准输出。</p><p>Linux下还有一个特殊的文件<code>/dev/null</code>，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。</p><p>如果想要<code>正常输出和错误信息都不显示</code>，则要把标准输出和标准错误都重定向到<code>/dev/null</code>， 例如：</p><p> <code>1&gt;/dev/null 2&gt;/dev/null</code></p><p><strong>解决办法</strong></p><p>所以最后的命令就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt;temp.txt 2&gt;&amp;1&amp;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost software]# nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt;temp.txt 2&gt;&amp;1&amp;</span><br><span class="line">[1] 22804</span><br><span class="line">// 成功启动 pid为22804</span><br></pre></td></tr></table></figure><h4 id="4-测试-1"><a href="#4-测试-1" class="headerlink" title="4. 测试"></a>4. 测试</h4><p>首先查看服务器的IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost software]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:8a:48:7d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.111/24 brd 192.168.1.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe8a:487d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:8e:d5:31 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:8e:d5:31 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>然后浏览器访问<code>http://192.168.1.111:8080/hello</code>出现<code>hello illusoryCloud</code>说明成功了。</p><p><strong>记得关闭防火墙或者开放8080端口</strong></p><h4 id="5-相关Linux命令"><a href="#5-相关Linux命令" class="headerlink" title="5. 相关Linux命令"></a>5. 相关Linux命令</h4><ul><li>jobs命令和 fg命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jobs</span><br><span class="line">//那么就会列出所有后台执行的作业，并且每个作业前面都有个编号。</span><br><span class="line">[root@localhost software]# jobs</span><br><span class="line">[1]+  Running    nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt; temp.txt 2&gt;&amp;1 &amp;</span><br><span class="line">//如果想将某个作业调回前台控制，只需要 fg + 编号即可。</span><br><span class="line"><span class="meta">$</span> fg 1</span><br></pre></td></tr></table></figure><ul><li>查看某端口占用的线程的pid</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nlp |grep :8080</span><br></pre></td></tr></table></figure><ul><li>kill</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill pid</span><br></pre></td></tr></table></figure><h3 id="3-2-war包"><a href="#3-2-war包" class="headerlink" title="3.2 war包"></a>3.2 war包</h3><p>war包运行和在windows上运行其实一样的，也是<strong>先将war包copy到Tomcat的webapps目录下，然后启动Tomcat，如果上面测试出现jar包冲突的话这里也需要替换</strong>。</p><p><a href="https://www.lixueduan.com/posts/54978294.html">Linux下Tomcat安装及配置点这里</a></p><h4 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h4><p>进入<code>Tomcat\bin</code>目录执行<code>./startup.sh</code>即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./startup.sh </span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /usr/local/jdk8</span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure><p>浏览器访问<code>http://192.168.1.111:8080/hello-0.0.1-SNAPSHOT/hello</code>出现<code>hello illusoryCloud</code>说明是没问题的。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>https://blog.csdn.net/qq_22638399/article/details/81506448</code></p><p><code>https://blog.csdn.net/c1481118216/article/details/53010963</code></p><p><code>https://blog.csdn.net/qq_14853889/article/details/80026885</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了如何在idea下打包SpringBoot项目并部署到云服务器，包括jar包和war包两种方式。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="https://www.lixueduan.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.lixueduan.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Git入门教程</title>
    <link href="https://www.lixueduan.com/posts/498941.html"/>
    <id>https://www.lixueduan.com/posts/498941.html</id>
    <published>2019-02-16T04:00:00.000Z</published>
    <updated>2019-02-16T12:50:08.327Z</updated>
    
    <content type="html"><![CDATA[<p>​    本文主要记录了Git常用的一些命令，和Git基本使用教学，包括了版本库的创建、代码提交、推送、拉取、版本回退、撤销等操作。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-Git简介"><a href="#1-1-Git简介" class="headerlink" title="1.1 Git简介"></a>1.1 Git简介</h3><p>Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1]  Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><h3 id="1-2-Git工作区概念"><a href="#1-2-Git工作区概念" class="headerlink" title="1.2 Git工作区概念"></a>1.2 Git工作区概念</h3><p>Git本地有四个工作区域：<code>工作目录（Working Directory</code>）、<code>暂存区(Stage/Index</code>)、<code>版本库(Repository或Commit History)</code>、<code>远程仓库(Remote Directory)</code>。文件在这四个区域之间的转换关系如下：</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/git/git-work-tree.png" alt=""></p><ul><li><strong>Working Directory</strong>： 工作区，就是你平时存放项目代码的地方，大概就是一个文件夹。</li><li><strong>Index / Stage</strong>： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li><strong>Repository</strong>： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li><strong>Remote</strong>： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><h3 id="1-3-工作流程"><a href="#1-3-工作流程" class="headerlink" title="1.3 工作流程"></a>1.3 工作流程</h3><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><h3 id="1-4-文件的四种状态"><a href="#1-4-文件的四种状态" class="headerlink" title="1.4 文件的四种状态"></a>1.4 文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><p>GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用</p><p>SHA-1算法计算文件的校验和。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/git/git-file-status.png" alt="img"></p><p><strong>Untracked:</strong>   未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p><p> <strong>Unmodify:</strong>   文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified.</p><p>​                   如果使用git rm移出版本库, 则成为Untracked文件</p><p>  <strong>Modified:</strong> 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过,</p><p>​                返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</p><p>​    <strong>Staged:</strong> 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存,</p><p>​               文件状态为Modified</p><p> 下面的图很好的解释了这四种状态的转变：</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/git/git-status-change.png" alt="img"></p><blockquote><p>新建文件后 —&gt;Untracked</p><p>使用add命令将新建的文件加入到暂存区—&gt;Staged</p><p>使用commit命令将暂存区的文件提交到本地仓库—&gt;Unmodified</p><p>如果对Unmodified状态的文件进行修改—&gt; modified</p><p>如果对Unmodified状态的文件进行remove操作—&gt;Untracked</p></blockquote><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><h3 id="2-1-git配置"><a href="#2-1-git配置" class="headerlink" title="2.1 git配置"></a>2.1 git配置</h3><p>使用之前首先要设置账号的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  //git中你的用户名 在查看提交历史等地方用到 一般为真实姓名 xxx</span><br><span class="line">git config --global user.email //你的邮箱 一般为公司邮箱xxx@xxx.com</span><br></pre></td></tr></table></figure><p>查看Git配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="2-2-创建git仓库"><a href="#2-2-创建git仓库" class="headerlink" title="2.2 创建git仓库"></a>2.2 创建git仓库</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>用 <code>git init</code> 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。执行后会在当前文件夹中多出一个<code>.git</code>文件夹，Git相关信息都在里面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git init</span><br><span class="line">Initialized empty Git repository in C:/Users/13452/Desktop/gitte/.git/</span><br></pre></td></tr></table></figure><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>当然，也可以在远程服务器上拉取代码，拷贝一个 Git 仓库到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone [url]</span><br><span class="line">例如</span><br><span class="line">git clone git@github.com:illusorycloud/design-pattern.git</span><br></pre></td></tr></table></figure><h3 id="2-3-代码提交"><a href="#2-3-代码提交" class="headerlink" title="2.3 代码提交"></a>2.3 代码提交</h3><p>假如已经通过<code>git clone</code>从远程服务器上拉取了一下git仓库到本地了，然后在本地新增了一个<code>test.txt</code>文件</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>可以通过<code>git status</code> 查看当前文件的状态</p><p>由于是新增的文件，还未加入git追踪，所以当前<code>test.txt</code>为<code>Untracked</code>状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        test.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>执行git diff命令来查看文件与之前的区别。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff  //查看本地工作区和index区域的文件的区别</span><br><span class="line">git diff --cached // 查看Index区域与Repository区域的区别</span><br><span class="line">git diff HEAD   //查看所有文件与本地仓库的区别</span><br><span class="line">git diff --stat  //只显示摘要而不是全部显示</span><br></pre></td></tr></table></figure><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>在本地将文件修改完成后<code>(Working Directory</code>)使用<code>git add</code>命令可将该文件添加到缓存 (<code>Index</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名  //添加单个文件</span><br><span class="line">git add .    //添加所有文件</span><br><span class="line"></span><br><span class="line">git add test.txt   //将test.txt文件添加到Index</span><br></pre></td></tr></table></figure><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>在使用 <code>git add</code>命令将想要快照的内容写入缓存区， 而执行<code>git commit</code>将缓存区内容添加到本地仓库中。(<code>Repository</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit   //提交Index中的文件 执行后会进入写注释的界面</span><br><span class="line">git commit -m"注释"   //提交时直接写注释</span><br><span class="line"></span><br><span class="line">git commit -m"新增test.txt文件"</span><br></pre></td></tr></table></figure><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>在执行<code>git commit</code>将缓存区内容添加到本地仓库中后，可以使用<code>git push</code>将本地的修改推送到服务器上的远程仓库中，这样其他人就可以同步了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push [主机名] [分支名]</span><br><span class="line">git push origin master  //推送到Orinoco主机的master分支 其中默认的主机名是origin</span><br></pre></td></tr></table></figure><h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>撤销命令，git中比较重要的命令之一了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [恢复等级] [commitId]</span><br></pre></td></tr></table></figure><h5 id="soft-mixed-hard"><a href="#soft-mixed-hard" class="headerlink" title="soft/mixed/hard"></a>soft/mixed/hard</h5><p><code>git reset</code>有三个参数，可以看做是三个恢复等级。</p><p><code>git reset –soft</code> 仅仅将commit回退到了指定的提交 ，只修改<code>Repository</code>区域<br><code>git reset –mixed</code>用指定的commit覆盖<code>Repository</code>区域和<code>Index区</code>，之前所有暂存的内容都变为未暂存的状态 (<code>默认为该参数</code>)</p><p><code>git reset –hard</code>使用指定的commit的内容覆盖<code>Repository</code>区域、<code>Index区</code>和<code>工作区</code>。(<strong>危险！！！ 此操作会丢弃工作区所做的修改！需谨慎！！！</strong>)</p><h5 id="commidID"><a href="#commidID" class="headerlink" title="commidID"></a>commidID</h5><p>表示将要恢复到哪个版本。有如下几种表示法</p><p><strong>HEAD</strong>:表示当前最新的一次提交,<code>(HEAD^)</code>表示倒数第二次提交,<code>(HEAD^^)</code>表示倒数第三次提交，倒数第100次提交则是<code>HEAD^^...^^^</code> 100个<code>^</code>,当然不会这么傻，还有另外一种写法<code>HEAD~100</code> 就是倒数第100次了。</p><p>当然还可以使用具体的<code>commitID</code>: </p><p>使用<code>git log</code>可以查看到提交历史，其中就包含了<code>commitID</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log </span><br><span class="line">////这个是最新的一次提交的commitId</span><br><span class="line">commit 06f1cd144f57c38d6fdbed07616af8ed5d69a9ea(HEAD -&gt; hexo, origin/hexo, origin/HEAD)</span><br><span class="line">Author: lillusory &lt;xueduanli@163.com&gt;</span><br><span class="line">Date:   Sat Feb 16 17:51:18 2019 +0800</span><br><span class="line"></span><br><span class="line">    添加Git工作区概念详解</span><br><span class="line"></span><br><span class="line">commit 8f8908ff3edbba0d24d7eee7682e09d002faee6f   //这个就是commitId</span><br><span class="line">Author: lillusory &lt;xueduanli@163.com&gt;</span><br><span class="line">Date:   Fri Feb 15 19:10:06 2019 +0800</span><br><span class="line"></span><br><span class="line">    fix建造者模式两种写法</span><br><span class="line"></span><br><span class="line">commit 71a44acd12d427f694f554df1d2f26ad59df5978 //这个就是commitId</span><br><span class="line">Author: lillusory &lt;xueduanli@163.com&gt;</span><br><span class="line">Date:   Fri Feb 15 00:31:33 2019 +0800</span><br><span class="line"></span><br><span class="line">    fix 单例模式+Git 常用命令</span><br><span class="line"></span><br><span class="line">commit 099675715979832baa107f9da080bfd38d3d63e0 //这个就是commitId</span><br><span class="line">Author: lillusory &lt;xueduanli@163.com&gt;</span><br><span class="line">Date:   Thu Feb 14 23:26:10 2019 +0800</span><br></pre></td></tr></table></figure><p>所以<code>git reset</code>有多种写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD   //Repository和Index恢复到最后一次提交的状态 不影响工作区</span><br><span class="line">git reset HEAD test.txt //只恢复test.txt 文件</span><br><span class="line">git reset --soft HEAD  //Repository恢复到最后一次提交的状态</span><br><span class="line">git reset --hard HEAD  //Repository、Index和工作区都恢复到最后一次提交的状态 丢弃工作区所有内容</span><br><span class="line">git reset 099675715979832baa107f9da080bfd38d3d63e0  //恢复到commitID版本 一般不用写完整的commitid 写前几位git就可以分辨出来了</span><br></pre></td></tr></table></figure><h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><p>前面的<code>git reset</code>可以恢复到各个版本，但是若恢复到前面的版本了，那么在使用<code>git log</code>查看是就找不到后面的提交了，想要恢复到后面的版本时就可以使用<code>git reflog</code>查看，该命令可以看到所有的版本改动信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log</span><br><span class="line">commit 86a08a6fbacffcf93f7b4dd94be4a21ca31682c4 (HEAD -&gt; master)</span><br><span class="line">Author: lillusory &lt;xueduanli@163.com&gt;</span><br><span class="line">Date:   Sat Feb 16 18:29:48 2019 +0800</span><br><span class="line"></span><br><span class="line">    新增test.txt</span><br><span class="line">    </span><br><span class="line"><span class="meta">$</span> git reflog</span><br><span class="line">86a08a6 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">b9802c7 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 添加内容1111</span><br><span class="line">86a08a6 HEAD@&#123;3&#125;: commit (initial): 新增test.txt</span><br></pre></td></tr></table></figure><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>在其他人提交代码后，可以通过<code>git pull</code>命令拉取服务器代码到本地。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull [主机名] [分支名]</span><br><span class="line">git pull origin master  //推送到Orinoco主机的master分支 其中默认的主机名是origin</span><br></pre></td></tr></table></figure><h3 id="2-4-分支操作"><a href="#2-4-分支操作" class="headerlink" title="2.4 分支操作"></a>2.4 分支操作</h3><p>创建项目后默认在master分支 即主分支 <strong>应保证master分支代码永远是正确的，稳定的，可运行的</strong></p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>实际开发时一般会根据功能创建多个分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch branchName //创建分支branchName</span><br><span class="line">git checkout branchName //切换到分支branchName</span><br><span class="line">git checkout -b branchName  //创建并切换到分支branchName</span><br></pre></td></tr></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>在新建的分支开发完后需要进行合并，将新的功能代码合并搭到master分支.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.切换到master分支</span><br><span class="line">git checkout master</span><br><span class="line">2.把新分支代码合并</span><br><span class="line">git merge branchName</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>合并完成后即可删除开发时创建的分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branchName //删除分支branchName</span><br></pre></td></tr></table></figure><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 新建仓库</span><br><span class="line">git init</span><br><span class="line">git clone [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 代码提交</span><br><span class="line">git add &lt;filename&gt;</span><br><span class="line">git commit -m"注释"</span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 版本恢复</span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 代码拉取</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 分支操作</span><br><span class="line">git branch &lt;branchName&gt;</span><br><span class="line">git checkout &lt;branchName&gt;</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 信息查看</span><br><span class="line">git status</span><br><span class="line">git log</span><br><span class="line">git reflog</span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>最后附上一张网上找到的<code>Git常用命令速查表</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/git/git-comand-fast-select.png" alt=""></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><code>http://www.runoob.com/git/git-basic-operations.html</code></p><p><code>https://www.cnblogs.com/qdhxhz/p/9757390.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本文主要记录了Git常用的一些命令，和Git基本使用教学，包括了版本库的创建、代码提交、推送、拉取、版本回退、撤销等操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.lixueduan.com/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.lixueduan.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程入门教程及实例详解</title>
    <link href="https://www.lixueduan.com/posts/38c0d2ef.html"/>
    <id>https://www.lixueduan.com/posts/38c0d2ef.html</id>
    <published>2019-02-13T14:00:00.000Z</published>
    <updated>2019-02-14T13:55:42.344Z</updated>
    
    <content type="html"><![CDATA[<p>存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。</p><p>本文主要介绍了MySQL的存储过程，通过语法教学及实例演示详细的叙述了MySQL存储过程的基本使用。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-存储过程简介"><a href="#1-存储过程简介" class="headerlink" title="1. 存储过程简介"></a>1. 存储过程简介</h2><p><strong>存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成</strong>。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式。</p><p>SQL语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p><p>简单的说，就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法；</p><blockquote><p>存储过程跟触发器有点类似，都是一组SQL集，但是存储过程是主动调用的，且功能比触发器更加强大，触发器是某件事触发后自动调用；</p></blockquote><h2 id="2-存储过程的优缺点"><a href="#2-存储过程的优缺点" class="headerlink" title="2. 存储过程的优缺点"></a>2. 存储过程的优缺点</h2><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><ul><li>1.<strong>增强SQL语言的功能和灵活性</strong>：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li><li>2.<strong>标准组件式编程</strong>：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</li><li>3.<strong>较快的执行速度</strong>：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</li><li>4.<strong>减少网络流量</strong>：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</li><li>5.<strong>作为一种安全机制来充分利用</strong>： 通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</li></ul><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><ul><li>1.可移植性差</li><li>2.对于很简单的sql语句， 存储过程没有优势</li><li>3.如果存储过程中不一定会减少网络传输（包含的sql数量并不多， 并且执行很快，就没必要了）</li><li>4.如果只有一个用户使用数据库， 那么存储过程对于安全也没什么影响</li><li>5.团队开发时需要先统一标准， 否则后期维护是个麻烦</li><li>6.在大并发量访问的情况下， 不宜写过多涉及运算的存储过程</li><li>7.业务逻辑复杂时， 特别是涉及到对很大的表进行操作的时候， 不如在前端先简化业务逻辑</li></ul><h2 id="3-存储过程语法"><a href="#3-存储过程语法" class="headerlink" title="3. 存储过程语法"></a>3. 存储过程语法</h2><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  过程名([[<span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT] 参数名 数据类型[,[<span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程</span></span><br><span class="line"><span class="comment">-- 将语句的结束符号从分号;临时改为两个//(可以是自定义) 让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码</span></span><br><span class="line">DELIMITER // </span><br><span class="line"><span class="comment">-- 创建存储过程 名称为 add_sum</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> add_sum(<span class="keyword">IN</span> a <span class="built_in">INT</span>,<span class="keyword">IN</span> b <span class="built_in">INT</span>,<span class="keyword">OUT</span> c <span class="built_in">INT</span>)</span><br><span class="line"><span class="comment">-- 过程体开始</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- SET 赋值</span></span><br><span class="line"> <span class="keyword">SET</span> c=a+b;</span><br><span class="line"><span class="comment">-- 过程体结束</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//  <span class="comment">-- 存储过程结束</span></span><br><span class="line">DELIMITER ; <span class="comment">-- 将分隔符还原为分号 ；</span></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">SET</span> @a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> @b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">CALL</span> add_sum(@a,@b,@c);</span><br><span class="line"><span class="keyword">SELECT</span> @c <span class="keyword">AS</span> <span class="keyword">SUM</span>; <span class="comment">-- 输出为3</span></span><br></pre></td></tr></table></figure><p>MySQL默认以”;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错。</p><p>所以要事先用<code>DELIMITER //</code>声明当前的分隔符，可以自定义。让编译器把两个<code>//</code>之间的内容当做存储过程的代码，不会执行这些代码；结束后使用<code>DELIMITER ;</code>把分隔符还原。</p><p><strong>MYSQL 存储过程中的关键语法</strong></p><p>声明语句结束符，可以自定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">或</span><br><span class="line">DELIMITER //</span><br></pre></td></tr></table></figure><p>声明存储过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE demo_in_parameter(IN p_in int)</span><br></pre></td></tr></table></figure><p>存储过程开始和结束符号:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN .... END</span><br></pre></td></tr></table></figure><p>变量赋值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @p_in=1</span><br></pre></td></tr></table></figure><p>变量定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE l_int int unsigned default 4000000;</span><br></pre></td></tr></table></figure><p>创建mysql存储过程、存储函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create procedure 存储过程名(参数)</span><br></pre></td></tr></table></figure><p>存储过程体:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function 存储函数名(参数)</span><br></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> sp_name[(传参)];</span><br></pre></td></tr></table></figure><h3 id="3-2-存储过程体"><a href="#3-2-存储过程体" class="headerlink" title="3.2 存储过程体"></a>3.2 存储过程体</h3><p>过程体的开始与结束使用<code>BEGIN</code>与<code>END</code>进行标识。</p><p>①如果过程没有参数，也必须在过程名后面写上小括号</p><p>　　　　例：<code>CREATE PROCEDURE sp_name ([proc_parameter[,...]]) ……</code></p><p>②确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理</p><ul><li>存储过程体包含了在过程调用时必须执行的语句，例如：dml、ddl语句，if-then-else和while-do语句、声明变量的declare语句等</li><li>过程体格式：以begin开始，以end结束(可嵌套)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">　　BEGIN</span><br><span class="line">　　　　BEGIN</span><br><span class="line">　　　　　　statements; </span><br><span class="line">　　　　END</span><br><span class="line">　　END</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 每个嵌套块及其中的每条语句，必须以分号结束，表示过程体结束的begin-end块(又叫做复合语句compound statement)，则不需要分号。</p><p><strong>为语句块贴标签:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] BEGIN</span><br><span class="line">　　[statement_list]</span><br><span class="line">END [end_label]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label1: <span class="keyword">BEGIN</span></span><br><span class="line">　　label2: <span class="keyword">BEGIN</span></span><br><span class="line">　　　　label3: <span class="keyword">BEGIN</span></span><br><span class="line">　　　　　　statements; </span><br><span class="line">　　　　<span class="keyword">END</span> label3 ;</span><br><span class="line">　　<span class="keyword">END</span> label2;</span><br><span class="line"><span class="keyword">END</span> label1</span><br></pre></td></tr></table></figure><p>标签有两个作用：</p><ul><li>1、增强代码的可读性</li><li>2、在某些语句(例如:leave和iterate语句)，需要用到标签</li></ul><h3 id="3-3-参数"><a href="#3-3-参数" class="headerlink" title="3.3 参数"></a>3.3 参数</h3><p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:</p><ul><li><strong>IN</strong>：参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值</li><li><strong>OUT</strong>: 该值可在存储过程内部被改变，并可返回</li><li><strong>INOUT</strong>: 调用时指定，并且可被改变和返回</li></ul><h4 id="1-IN参数例子"><a href="#1-IN参数例子" class="headerlink" title="1.IN参数例子"></a>1.IN参数例子</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> in_param(<span class="keyword">IN</span> p_in <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> p_in;</span><br><span class="line">    <span class="keyword">SET</span> p_in=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> p_in;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    //</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">SET</span> @p_in=<span class="number">1</span>; <span class="comment">-- 这里@p_in为1</span></span><br><span class="line"><span class="keyword">CALL</span> in_param(@p_in); <span class="comment">-- 这里 修改@p_in值为2</span></span><br><span class="line"><span class="keyword">SELECT</span> @p_in; <span class="comment">-- 查询@p_in值依旧为1</span></span><br></pre></td></tr></table></figure><p><strong>p_in 在存储过程中被修改，但并不影响 @p_id 的值，因为前者为局部变量、后者为全局变量。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此语句的意思就是根据where条件uid=1查询user表，得到的行数存入变量u_count中（给变量赋值）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> u_count <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uid=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="2-OUT参数例子"><a href="#2-OUT参数例子" class="headerlink" title="2.OUT参数例子"></a>2.OUT参数例子</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#存储过程</span></span><br><span class="line">DELIMITER // <span class="comment">-- 将语句的结束符号从分号;临时改为两个//(可以是自定义) 让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> out_param(<span class="keyword">OUT</span> p_out  <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> p_out ;</span><br><span class="line"> <span class="keyword">SET</span> p_out =<span class="number">999</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//  <span class="comment">-- 存储过程结束</span></span><br><span class="line">DELIMITER ; <span class="comment">-- 将分隔符还原为分号 ；</span></span><br><span class="line"><span class="keyword">SET</span> @p_out=<span class="number">111</span>;</span><br><span class="line"><span class="keyword">CALL</span> out_param(@p_out); <span class="comment">-- 因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为null</span></span><br><span class="line"><span class="keyword">SELECT</span> @p_out; <span class="comment">-- 调用了out_param存储过程，输出参数，改变了p_out变量的值</span></span><br></pre></td></tr></table></figure><h4 id="3-INOUT输入参数"><a href="#3-INOUT输入参数" class="headerlink" title="3.INOUT输入参数"></a>3.INOUT输入参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程</span></span><br><span class="line">DELIMITER // <span class="comment">-- 将语句的结束符号从分号;临时改为两个//(可以是自定义) 让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> inout_param(INOUT p_inout  <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">SELECT</span> p_inout ;</span><br><span class="line"> <span class="keyword">SET</span> p_inout =<span class="number">999</span>;</span><br><span class="line"> <span class="keyword">SELECT</span> p_inout ;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//  <span class="comment">-- 存储过程结束</span></span><br><span class="line">DELIMITER ; <span class="comment">-- 将分隔符还原为分号 ；</span></span><br><span class="line"><span class="keyword">SET</span> @p_inout=<span class="number">111</span>;</span><br><span class="line"><span class="keyword">CALL</span> inout_param(@p_inout);  <span class="comment">-- 能接受输入的值 查询结果为111</span></span><br><span class="line"><span class="keyword">SELECT</span> @p_inout; <span class="comment">-- 存储过程修改了值 所以结果为999</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、如果过程没有参数，也必须在过程名后面写上小括号例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE sp_name ([proc_parameter[,...]]) ……</span><br></pre></td></tr></table></figure><p>2、确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理</p><p><strong>建议：</strong></p><ul><li>输入值使用in参数。</li><li>返回值使用out参数。</li><li>inout参数就尽量的少用。</li></ul><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><h4 id="1变量定义"><a href="#1变量定义" class="headerlink" title="1变量定义"></a>1变量定义</h4><p>局部变量声明一定要放在存储过程体的开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLAREvariable_name [,variable_name...] datatype [DEFAULT value];</span><br></pre></td></tr></table></figure><p>其中，datatype 为 MySQL 的数据类型，如: int, float, date,varchar(length)</p><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> l_int <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">default</span> <span class="number">4000000</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_numeric <span class="built_in">number</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">9.95</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_date <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="string">'1999-12-31'</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_datetime datetime <span class="keyword">DEFAULT</span> <span class="string">'1999-12-31 23:59:59'</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_varchar <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">'This will not be padded'</span>;`</span><br></pre></td></tr></table></figure><h4 id="2-变量赋值"><a href="#2-变量赋值" class="headerlink" title="2 变量赋值"></a>2 变量赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET 变量名 = 表达式值 [,variable_name = expression ...]</span><br></pre></td></tr></table></figure><h4 id="3-用户变量"><a href="#3-用户变量" class="headerlink" title="3 用户变量"></a>3 用户变量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @ValueName=<span class="keyword">value</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @uid=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>1、用户变量名一般以@开头</li><li>2、滥用用户变量会导致程序难以理解及管理</li></ul><h3 id="3-5-存储过程控制语句"><a href="#3-5-存储过程控制语句" class="headerlink" title="3.5 存储过程控制语句"></a>3.5 存储过程控制语句</h3><h4 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h4><p>内部的变量在其作用域范围内享有更高的优先权，当执行到 end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储过程外再也不能找到这个申明的变量，但是你可以通过 out 参数或者将其值指派给会话变量来保存其值。</p><h4 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2.条件语句"></a>2.条件语句</h4><h5 id="1-if-then-else-语句"><a href="#1-if-then-else-语句" class="headerlink" title="1.if-then-else 语句"></a>1.if-then-else 语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> myif;  <span class="comment">-- 删除存储过程myif 如果存在</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myif(<span class="keyword">IN</span> a <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> msg <span class="built_in">VARCHAR</span>(<span class="number">30</span>);</span><br><span class="line">IF a = 0 THEN</span><br><span class="line"><span class="keyword">SET</span> msg=<span class="string">'a is 0'</span>;</span><br><span class="line">ELSEIF a = 1 THEN </span><br><span class="line"><span class="keyword">SET</span> msg=<span class="string">'a is 1'</span>;</span><br><span class="line">ELSE </span><br><span class="line"><span class="keyword">SET</span> msg=<span class="string">'a is others,not 0 or 1'</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">SELECT</span> msg;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> myif(<span class="number">2</span>); <span class="comment">-- 调用</span></span><br></pre></td></tr></table></figure><h5 id="2-case语句："><a href="#2-case语句：" class="headerlink" title="2.case语句："></a>2.case语句：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycase;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> mycase(<span class="keyword">IN</span> a <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> msg <span class="built_in">VARCHAR</span>(<span class="number">30</span>); <span class="comment">-- 定义变量</span></span><br><span class="line">CASE a</span><br><span class="line">WHEN 0 THEN</span><br><span class="line"><span class="keyword">SET</span> msg=<span class="string">'a is 0'</span>;</span><br><span class="line">WHEN 1 THEN</span><br><span class="line"><span class="keyword">SET</span> msg=<span class="string">'a is 1'</span>;</span><br><span class="line">ELSE  <span class="comment">-- 相当于switch中的default</span></span><br><span class="line"><span class="keyword">SET</span> msg=<span class="string">'a is others,not 0 or 1'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> msg;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line">//</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> mycase(<span class="number">1</span>); <span class="comment">-- 调用</span></span><br></pre></td></tr></table></figure><h5 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3.循环语句"></a>3.循环语句</h5><h6 id="1-while-····-end-while"><a href="#1-while-····-end-while" class="headerlink" title="1.while ···· end while"></a>1.while ···· end while</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mywhile;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> mywhile(<span class="keyword">IN</span> a <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> msg <span class="built_in">VARCHAR</span>(<span class="number">30</span>);</span><br><span class="line">WHILE a&gt;1 DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user2 <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,a);  <span class="comment">-- 循环往表中插入数据</span></span><br><span class="line"><span class="keyword">SET</span> a=a<span class="number">-1</span>;    <span class="comment">-- 每次执行结束a减1</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> mywhile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> mywhile(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 条件 <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--循环体</span></span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure><h6 id="2-repeat····-end-repea"><a href="#2-repeat····-end-repea" class="headerlink" title="2.repeat···· end repea"></a>2.repeat···· end repea</h6><p>它在执行操作后检查结果，而 while 则是执行前进行检查。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> myrepeat;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myrepeat(<span class="keyword">IN</span> a <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">REPEAT</span></span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> user2 <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,a);</span><br><span class="line"> <span class="keyword">SET</span> a=a<span class="number">-1</span>;</span><br><span class="line"> UNTIL a&lt;1</span><br><span class="line"> <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"> <span class="keyword">END</span></span><br><span class="line"> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CALL</span> myrepeat(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">    <span class="comment">-- 循环体</span></span><br><span class="line">until 循环条件  </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br></pre></td></tr></table></figure><h6 id="3-loop-·····endloop"><a href="#3-loop-·····endloop" class="headerlink" title="3.loop ·····endloop"></a>3.loop ·····endloop</h6><p>– loop 与 leave,iterate 实现循环<br>– loop 标志位无条件循环，leave 类似于break 语句，跳出循环，跳出 begin end，iterate 类似于continue ，结束本次循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> myloop;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myloop(<span class="keyword">IN</span> a <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">loop_label: <span class="keyword">LOOP</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user2 <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,a);</span><br><span class="line"><span class="keyword">SET</span> a=a<span class="number">-1</span>;</span><br><span class="line">IF a&lt;1 THEN</span><br><span class="line">LEAVE loop_label;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> myloop(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h6 id="4-LABLES-标号"><a href="#4-LABLES-标号" class="headerlink" title="4.LABLES 标号"></a>4.LABLES 标号</h6><p>标号可以用在 begin repeat while 或者 loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。</p><p>ITERATE 通过引用复合语句的标号,来从新开始复合语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> myiterate;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myiterate(<span class="keyword">IN</span> a <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">loop_label: <span class="keyword">LOOP</span></span><br><span class="line"><span class="keyword">IF</span> a&lt;<span class="number">3</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">SET</span> a=a+<span class="number">1</span>;</span><br><span class="line">ITERATE loop_label; <span class="comment">-- 退出这次循环 继续下一次循环 类似于continue</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user2 <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,a);</span><br><span class="line"><span class="keyword">SET</span> a=a+<span class="number">1</span>;</span><br><span class="line">IF a&gt;=5 THEN</span><br><span class="line">LEAVE loop_label;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> myiterate(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="4-存储过程操作语法"><a href="#4-存储过程操作语法" class="headerlink" title="4. 存储过程操作语法"></a>4. 存储过程操作语法</h2><h4 id="4-1-存储过程查询"><a href="#4-1-存储过程查询" class="headerlink" title="4.1 存储过程查询"></a>4.1 存储过程查询</h4><p>查看某个数据库下面的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库中的存储过程</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mysql.proc <span class="keyword">WHERE</span> db=<span class="string">'数据库名'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL存储过程和函数的信息存储在information_schema数据库下的Routines表中。通过查询该表的记录查询信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.routines <span class="keyword">WHERE</span> routine_schema=<span class="string">'数据库名'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个语句是MySQL的扩展，它返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。PROCEDURE和FUNCTION分别表示查看存储过程和函数</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> <span class="keyword">STATUS</span> <span class="keyword">WHERE</span> db=<span class="string">'数据库名'</span>;</span><br></pre></td></tr></table></figure><p>查看详细的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 数据库.存储过程名; <span class="comment">-- 它返回一个可用来重新创建已命名子程序的确切字符串</span></span><br></pre></td></tr></table></figure><h4 id="4-2-修改删除"><a href="#4-2-修改删除" class="headerlink" title="4.2 修改删除"></a>4.2 修改删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; proc_or_func [characterustic...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> 存储过程名字  </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> inout_param  </span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] proc_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span>  inout_param;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> inout_param;</span><br></pre></td></tr></table></figure><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p><code>http://www.runoob.com/w3cnote/mysql-stored-procedure.html</code></p><p><code>https://www.2cto.com/database/201805/746743.html</code></p><p><code>https://www.cnblogs.com/mark-chan/p/5384139.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。&lt;/p&gt;
&lt;p&gt;本文主要介绍了MySQL的存储过程，通过语法教学及实例演示详细的叙述了MySQL存储过程的基本使用。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://www.lixueduan.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.lixueduan.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>几种常见排序算法的Java实现</title>
    <link href="https://www.lixueduan.com/posts/82240bb6.html"/>
    <id>https://www.lixueduan.com/posts/82240bb6.html</id>
    <published>2019-02-12T14:00:00.000Z</published>
    <updated>2019-02-12T15:25:05.178Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了几种常见的排序算法的Java实现，如<code>冒泡排序</code>、<code>快速排序</code>、<code>直接插入排序</code>、<code>希尔排序</code>、<code>选择排序</code>等等。<br>在学数据结构与算法时的部分记录，感觉很难╮(╯▽╰)╭，还需继续努力。<br><a id="more"></a></p><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h1><p>将序列中所有元素两两比较，将最大的放在最后面。</p><p>将剩余序列中所有元素两两比较，将最大的放在最后面。</p><p>重复第二步，直到只剩下一个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序：两两比较，大者交换位置,则每一轮循环结束后最大的数就会移动到最后.</span></span><br><span class="line"><span class="comment"> * 时间复杂度为O(n²) 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//外层循环length-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123; </span><br><span class="line">        <span class="comment">//外层每循环一次最后都会排好一个数</span></span><br><span class="line">        <span class="comment">//所以内层循环length-1-i次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h1><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列.</p><p><strong>具体步骤</strong></p><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。</p><ul><li>①. 从数列中挑出一个元素，称为”基准”（pivot）。</li><li>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 快速排序</span></span><br><span class="line"><span class="comment">   * 时间复杂度为O(nlogn) 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">          <span class="keyword">int</span> baseNum = arr[start];<span class="comment">//选基准值</span></span><br><span class="line">          <span class="keyword">int</span> midNum;<span class="comment">//记录中间值</span></span><br><span class="line">          <span class="keyword">int</span> left = start;<span class="comment">//左指针</span></span><br><span class="line">          <span class="keyword">int</span> right = end;<span class="comment">//右指针</span></span><br><span class="line">          <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">              <span class="keyword">while</span> ((arr[left] &lt; baseNum) &amp;&amp; left &lt; end) &#123;</span><br><span class="line">                  left++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> ((arr[right] &gt; baseNum) &amp;&amp; right &gt; start) &#123;</span><br><span class="line">                  right--;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                  midNum = arr[left];</span><br><span class="line">                  arr[left] = arr[right];</span><br><span class="line">                  arr[right] = midNum;</span><br><span class="line">                  left++;</span><br><span class="line">                  right--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (start &lt; right) &#123;</span><br><span class="line">              quickSort(arr, start, right);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (end &gt; left) &#123;</span><br><span class="line">              quickSort(arr, left, end);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h1><p>直接插入排序（Straight Insertion Sorting）的基本思想：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。 </p><p>首先设定插入次数，即循环次数，for(int i=1;i&lt;length;i++)，1个数的那次不用插入。</p><p>设定插入数和得到已经排好序列的最后一个数的位数。insertNum和j=i-1。</p><p>从最后一个数开始向前循环，如果插入数小于当前数，就将当前数向后移动一位。</p><p>将当前数放置到空着的位置，即j+1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n²) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">straightInsertion</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current;<span class="comment">//要插入的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;  <span class="comment">//从1开始 第一次一个数不需要排序</span></span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//序列元素个数</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; current) &#123;<span class="comment">//从后往前循环，将大于当前插入数的向后移动</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];<span class="comment">//元素向后移动</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = current;<span class="comment">//找到位置，插入当前元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h1><p>是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n²) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//不断缩小gap，直到1为止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j + gap) &lt; arr.length; j++) &#123; </span><br><span class="line">            <span class="comment">//使用当前gap进行组内插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; (k + gap) &lt; arr.length; k += gap) &#123; </span><br><span class="line">                <span class="keyword">if</span> (arr[k] &gt; arr[k + gap]) &#123; </span><br><span class="line">                    <span class="comment">//交换操作</span></span><br><span class="line">                    <span class="keyword">int</span> temp = arr[k];</span><br><span class="line">                    arr[k] = arr[k + gap];</span><br><span class="line">                    arr[k + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5. 选择排序"></a>5. 选择排序</h1><p>遍历整个序列，将最小的数放在最前面。</p><p>遍历剩下的序列，将最小的数放在最前面。</p><p>重复第二步，直到只剩下一个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n²) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">//循环次数</span></span><br><span class="line">        <span class="keyword">int</span> min = arr[i];<span class="comment">//等会用来放最小值</span></span><br><span class="line">        <span class="keyword">int</span> index = i;<span class="comment">//用来放最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">//找到最小值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内层循环结束后进行交换</span></span><br><span class="line">        arr[index] = arr[i];<span class="comment">//当前值放到最小值所在位置</span></span><br><span class="line">        arr[i] = min;<span class="comment">//当前位置放最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h1><p>对简单选择排序的优化。</p><p>将序列构建成大顶堆。</p><p>将根节点与最后一个节点交换，然后断开最后一个节点。</p><p>重复第一、二步，直到所有节点断开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> len=a.length;</span><br><span class="line">           <span class="comment">//循环建堆  </span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">               <span class="comment">//建堆  </span></span><br><span class="line">               buildMaxHeap(a,len-<span class="number">1</span>-i);</span><br><span class="line">               <span class="comment">//交换堆顶和最后一个元素  </span></span><br><span class="line">               swap(a,<span class="number">0</span>,len-<span class="number">1</span>-i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//交换方法</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">           data[i]=data[j];</span><br><span class="line">           data[j]=tmp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//对data数组从0到lastIndex建大顶堆  </span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//从lastIndex处节点（最后一个节点）的父节点开始  </span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="comment">//k保存正在判断的节点  </span></span><br><span class="line">               <span class="keyword">int</span> k=i;</span><br><span class="line">               <span class="comment">//如果当前k节点的子节点存在  </span></span><br><span class="line">               <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">                   <span class="comment">//k节点的左子节点的索引  </span></span><br><span class="line">                   <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                   <span class="comment">//如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在  </span></span><br><span class="line">                   <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">                       <span class="comment">//若果右子节点的值较大  </span></span><br><span class="line">                       <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">                           <span class="comment">//biggerIndex总是记录较大子节点的索引  </span></span><br><span class="line">                           biggerIndex++;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//如果k节点的值小于其较大的子节点的值  </span></span><br><span class="line">                   <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">                       <span class="comment">//交换他们  </span></span><br><span class="line">                       swap(data,k,biggerIndex);</span><br><span class="line">                       <span class="comment">//将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值  </span></span><br><span class="line">                       k=biggerIndex;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h1><p>速度仅次于快速排序，内存少的时候使用，可以进行并行计算的时候使用。</p><p>选择相邻两个数组成一个有序序列。</p><p>选择相邻的两个有序序列组成一个有序序列。</p><p>重复第二步，直到全部组成一个有序序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">int</span> t = <span class="number">1</span>;<span class="comment">// 每组元素个数  </span></span><br><span class="line">           <span class="keyword">int</span> size = right - left + <span class="number">1</span>;  </span><br><span class="line">           <span class="keyword">while</span> (t &lt; size) &#123;  </span><br><span class="line">               <span class="keyword">int</span> s = t;<span class="comment">// 本次循环每组元素个数  </span></span><br><span class="line">               t = <span class="number">2</span> * s;  </span><br><span class="line">               <span class="keyword">int</span> i = left;  </span><br><span class="line">               <span class="keyword">while</span> (i + (t - <span class="number">1</span>) &lt; size) &#123;  </span><br><span class="line">                   merge(a, i, i + (s - <span class="number">1</span>), i + (t - <span class="number">1</span>));  </span><br><span class="line">                   i += t;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">if</span> (i + (s - <span class="number">1</span>) &lt; right)  </span><br><span class="line">                   merge(a, i, i + (s - <span class="number">1</span>), right);  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];  </span><br><span class="line">           <span class="keyword">int</span> s = p;  </span><br><span class="line">           <span class="keyword">int</span> t = q + <span class="number">1</span>;  </span><br><span class="line">           <span class="keyword">int</span> k = p;  </span><br><span class="line">           <span class="keyword">while</span> (s &lt;= q &amp;&amp; t &lt;= r) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (data[s] &lt;= data[t]) &#123;  </span><br><span class="line">                   B[k] = data[s];  </span><br><span class="line">                   s++;  </span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                   B[k] = data[t];  </span><br><span class="line">                   t++;  </span><br><span class="line">               &#125;  </span><br><span class="line">               k++;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">if</span> (s == q + <span class="number">1</span>)  </span><br><span class="line">               B[k++] = data[t++];  </span><br><span class="line">           <span class="keyword">else</span>  </span><br><span class="line">               B[k++] = data[s++];  </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= r; i++)  </span><br><span class="line">               data[i] = B[i];  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h1><p>用于大量数，很长的数进行排序时。</p><p>将所有的数的个位数取出，按照个位数进行排序，构成一个序列。</p><p>将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//首先确定排序的趟数;    </span></span><br><span class="line">               <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">                       max = a[i];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//判断位数;    </span></span><br><span class="line">               <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   max /= <span class="number">10</span>;</span><br><span class="line">                   time++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//建立10个队列;    </span></span><br><span class="line">               List&lt;ArrayList&lt;Integer&gt;&gt; queue = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                   ArrayList&lt;Integer&gt; queue1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                   queue.add(queue1);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//进行time次分配和收集;    </span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">                   <span class="comment">//分配数组元素;    </span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                       <span class="comment">//得到数字的第time+1位数;  </span></span><br><span class="line">                       <span class="keyword">int</span> x = a[j] % (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i + <span class="number">1</span>) / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i);</span><br><span class="line">                       ArrayList&lt;Integer&gt; queue2 = queue.get(x);</span><br><span class="line">                       queue2.add(a[j]);</span><br><span class="line">                       queue.set(x, queue2);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//元素计数器;    </span></span><br><span class="line">                   <span class="comment">//收集队列元素;    </span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                       <span class="keyword">while</span> (queue.get(k).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           ArrayList&lt;Integer&gt; queue3 = queue.get(k);</span><br><span class="line">                           a[count] = queue3.get(<span class="number">0</span>);</span><br><span class="line">                           queue3.remove(<span class="number">0</span>);</span><br><span class="line">                           count++;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><table><thead><tr><th>排序法</th><th>平均时间</th><th>最小时间</th><th>最大时间</th><th>稳定度</th><th>额外空间</th><th>备注</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n2)</td><td>O(n)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>选择排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>不稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>插入排序</td><td>O(n2)</td><td>O(n)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td><td>大部分已排序时较好</td></tr><tr><td>基数排序</td><td>O(logRB)</td><td>O(n)</td><td>O(logRB)</td><td>稳定</td><td>O(n)</td><td>B是真数(0-9)，R是基数(个十百)</td></tr><tr><td>Shell排序</td><td>O(nlogn)</td><td>-</td><td>O(ns) 1&lt;s&lt;2</td><td>不稳定</td><td>O(1)</td><td>s是所选分组</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n2)</td><td>O(n2)</td><td>不稳定</td><td>O(logn)</td><td>n大时较好</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(n)</td><td>要求稳定性时较好</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td><td>n大时较好</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><code>https://www.cnblogs.com/shixiangwan/p/6724292.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了几种常见的排序算法的Java实现，如&lt;code&gt;冒泡排序&lt;/code&gt;、&lt;code&gt;快速排序&lt;/code&gt;、&lt;code&gt;直接插入排序&lt;/code&gt;、&lt;code&gt;希尔排序&lt;/code&gt;、&lt;code&gt;选择排序&lt;/code&gt;等等。&lt;br&gt;在学数据结构与算法时的部分记录，感觉很难╮(╯▽╰)╭，还需继续努力。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.lixueduan.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.lixueduan.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java运行时数据区</title>
    <link href="https://www.lixueduan.com/posts/9806100a.html"/>
    <id>https://www.lixueduan.com/posts/9806100a.html</id>
    <published>2019-02-02T14:00:00.000Z</published>
    <updated>2019-02-07T06:41:30.278Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲的是Java运行时数据区，包括线程私有的<code>程序计数器</code>，<code>虚拟机栈</code>，<code>本地方法栈</code>和线程共享的<code>堆</code>，<code>方法区</code>等。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/jvm/runtime-data-areas.png" alt="Java运行时数据区"></p><p><strong>线程私有的</strong>：<code>程序计数器</code> 、<code>虚拟机栈</code>、<code>本地方法栈</code></p><p><strong>线程共享的</strong>： <code>堆</code>、<code>方法区</code></p><h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h3><p><strong>Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> </p><p>Java虚拟机栈是由一个个<code>栈帧</code>组成，而每个栈帧中都拥有：<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>。</p><p>每个方法在执行时都会创建一个栈帧,每一个方法从调用到执行完成的过程就是一个栈帧在虚拟机中的入栈到出栈的过程。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>存放了编译时期可知的各种基本类型（Boolean，byte，char,short,int.float.long,double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令的地址）。<code>局部变量表的创建是在方法被执行的时候,随着栈帧的创建而创建</code>.而且,<code>局部变量表的大小在编译时期就可以确定下来了</code>,在创建的时候只需要分配实现规定好的大小即可.此外,在<code>方法运行过程中局部变量表的大小是不会发生改变的</code>。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>后进先出LIFO，最大深度由编译期确定。栈帧刚建立时，操作数栈为空，执行方法操作时，操作数栈用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。<br>操作数栈可以存放一个jvm中定义的任意数据类型的值。在任意时刻，操作数栈都一个固定的栈深度，基本类型除了long、double占用两个深度，其它占用一个深度.</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</p><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong>Java虚拟机规范中说的是：所有的对象实例以及数组都要在堆上分配内存。但是随着<code>JIT(just in time)编译器</code>的发展与<code>逃逸分析</code>技术的成熟，<code>栈上分配</code>，<code>标量替换</code>优化技术将会导致一些微妙的变化，所有对象都分配在堆上也变得不是那么绝对了。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<code>GC堆（Garbage Collected Heap）</code><strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：<code>新生代</code>和<code>老年代</code>：再细致一点有：<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等。</strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。**</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<code>类信息</code>、<code>常量</code>、<code>静态变量</code>、<code>即时编译器编译后的代码</code>等数据。</strong></p><p><strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p><p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p><h3 id="1-6-常量池"><a href="#1-6-常量池" class="headerlink" title="1.6 常量池"></a>1.6 常量池</h3><h4 id="全局字符串池"><a href="#全局字符串池" class="headerlink" title="全局字符串池"></a>全局字符串池</h4><p>全局字符串池里的内容是在类加载完成，经过验证，<strong>准备阶段之后</strong>在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p><h4 id="静态常量池"><a href="#静态常量池" class="headerlink" title="静态常量池"></a>静态常量池</h4><p>也叫<code>class文件常量池（class constant pool）</code>,Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是<code>常量池</code>,用于存放编译期生成的各种<code>字面量</code>和<code>符号引用</code>，这部分内容将在<code>类加载后</code>进入方法区的<code>运行时常量池</code>。</p><p> <code>字面量</code>就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。</p><p> <code>符号引用</code>是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><code>运行时常量池</code>是<code>方法区</code>的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是<code>常量池</code>,用于存放编译期生成的各种<code>字面量</code>和<code>符号引用</code>，这部分内容将在<code>类加载后</code>进入方法区的<code>运行时常量池</code>。</p><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><p><strong>JDK1.8后放在一个独立空间里面，叫做“元空间”</strong> </p><p>jvm在执行某个类的时候，必须经过<code>加载</code>、<code>连接</code>、<code>初始化</code>，而连接又包括<code>验证</code>、<code>准备</code>、<code>解析</code>三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，<code>运行时常量池也是每个类都有一个</code>。在上面我也说了，<code>class常量池中存的是字面量和符号引用</code>，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过<code>解析（resolve）</code>之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。</li><li>2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li><li>3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li></ul><h3 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，但是也频繁被用到，也可能导致OOM,虚拟机内存+直接内存超过物理内存时。</p><p>在JDK1.4出现的NIO类中引入了一个基于Channel和Buffer的IO方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，能在一些场合中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《深入理解Java虚拟机》</p><p><code>https://blog.csdn.net/qq_26222859/article/details/73135660</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲的是Java运行时数据区，包括线程私有的&lt;code&gt;程序计数器&lt;/code&gt;，&lt;code&gt;虚拟机栈&lt;/code&gt;，&lt;code&gt;本地方法栈&lt;/code&gt;和线程共享的&lt;code&gt;堆&lt;/code&gt;，&lt;code&gt;方法区&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.lixueduan.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.lixueduan.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装RabbitMQ</title>
    <link href="https://www.lixueduan.com/posts/b84a2c6c.html"/>
    <id>https://www.lixueduan.com/posts/b84a2c6c.html</id>
    <published>2019-01-21T14:00:00.000Z</published>
    <updated>2019-02-06T01:12:00.986Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要讲了如何通过解压方式在Linux下安装RabbitMQ和Erlang，超级详细的安装过程，和安装过程中遇到的一些问题。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><p>软件统一放在<code>/usr/software</code>下 解压后放在单独的文件夹下<code>/usr/locac/opt/rabbitmq</code>,<code>/usr/local/opt/erlang</code></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="0-环境准备"><a href="#0-环境准备" class="headerlink" title="0. 环境准备"></a>0. 环境准备</h2><h3 id="1-版本问题"><a href="#1-版本问题" class="headerlink" title="1.版本问题"></a>1.版本问题</h3><p>Erlang和RabbitMQ版本必须对应才行，不然可能会出错。</p><p><strong>官网信息如下 RabbitMQ Erlang Version Requirements</strong></p><p>Erlang/OTP versions <strong>older than 20.3 are not supported</strong> by RabbitMQ versions released in 2019.</p><p>RabbitMQ <strong>versions prior to 3.7.7 do not support Erlang/OTP 21</strong> or newer.</p><p>RabbitMQ version3.7.7–3.7.10 需要的Erlang版本最低为20.3.X,最高为21.X</p><table><thead><tr><th>RabbitMQ version</th><th>Minimum required Erlang/OTP</th><th>Maximum supported Erlang/OTP</th></tr></thead><tbody><tr><td><strong>3.7.7—3.7.10</strong></td><td><strong>20.3.X</strong></td><td><strong>21.X</strong></td></tr><tr><td><strong>3.7.0–3.7.6</strong></td><td><strong>19.3</strong></td><td><strong>20.3.X</strong></td></tr></tbody></table><p>具体信息在这里<code>http://www.rabbitmq.com/which-erlang.html</code></p><p>这里选择的版本是 <code>Erlang:21.2</code>,<code>RabbitMQ3.7.10</code>,<code>Linux:CentOS 7</code></p><h3 id="2-依赖下载"><a href="#2-依赖下载" class="headerlink" title="2. 依赖下载"></a>2. 依赖下载</h3><p>安装<code>rabbitmq</code>需要下载以下依赖，这里可以提前下载上。</p><p><code># yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel</code></p><p><code># yum install xmlto -y</code></p><h2 id="1-Erlang安装"><a href="#1-Erlang安装" class="headerlink" title="1. Erlang安装"></a>1. Erlang安装</h2><h3 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h3><p>安装RabbitMQ之前需要先安装Erlang.</p><p>下载地址：<code>http://www.erlang.org/downloads</code></p><p>文件<code>otp_src_21.2.tar.gz</code></p><h3 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2 解压"></a>1.2 解压</h3><p>将压缩包上传到虚拟机中，我是放在/usr/software目录下的</p><p><code># tar xvf otp_src_21.2.tar.gz</code>  解压文件</p><p>复制一份到/usr/local/opt/erlang-software</p><p><code># cp otp_src_21.2  /usr/local/opt/erlang-software -r</code></p><p>创建erlang安装目录： /usr/local/opt/erlang  </p><h3 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3 编译"></a>1.3 编译</h3><p>进入到/usr/local/opt/erlang-software目录下</p><p><code># cd /usr/local/opt/erlang-software</code></p><p>配置安装路径编译代码：<code># ./configure --prefix=/usr/local/opt/erlang</code></p><p><code># make &amp;&amp; make install</code> 执行编译</p><h3 id="1-4-环境变量配置"><a href="#1-4-环境变量配置" class="headerlink" title="1.4 环境变量配置"></a>1.4 环境变量配置</h3><p>配置Erlang环境变量,<code># vi /etc/profile</code> 添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/opt/erlang/bin</span><br></pre></td></tr></table></figure><p> <code># source /etc/profile</code>使得文件生效</p><h3 id="1-5-验证"><a href="#1-5-验证" class="headerlink" title="1.5 验证"></a>1.5 验证</h3><p>验证erlang是否安装成功：<code># erl</code> 进入如下界面就说明 配置好了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# erl</span><br><span class="line">Erlang/OTP 21 [erts-10.2] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]</span><br><span class="line"></span><br><span class="line">Eshell V10.2  (abort with ^G)</span><br><span class="line">1&gt; </span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="2-RabbitMQ安装"><a href="#2-RabbitMQ安装" class="headerlink" title="2. RabbitMQ安装"></a>2. RabbitMQ安装</h2><h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><p>官网：<code>http://www.rabbitmq.com/releases/rabbitmq-server</code></p><p>这里下载3.7.10 :<code>http://www.rabbitmq.com/install-generic-unix.html</code></p><p>文件：<code>rabbitmq-server-generic-unix-3.7.10.tar.xz</code></p><h3 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h3><p>文件是xz格式的，解压后得到tar格式文件。</p><p><code># xz -d rabbitmq-server-generic-unix-3.7.10.tar.xz</code></p><p><code># tar -xvf rabbitmq-server-generic-unix-3.7.10.tar</code></p><p>复制到/usr/local/opt/rabbitmq目录下<code># cp -r rabbitmq_server-3.7.10/ /usr/local/opt/rabbitmq</code></p><h3 id="2-3-环境变量配置"><a href="#2-3-环境变量配置" class="headerlink" title="2.3 环境变量配置"></a>2.3 环境变量配置</h3><p>配置rabbitmq环境变量,<code># vi /etc/profile</code> 添加以下内容</p><p><code>export PATH=$PATH:/usr/local/opt/rabbitmq/sbin</code></p><p>环境变量生效：<code>source /etc/profile</code></p><h3 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h3><p>进入/usr/local/opt/rabbitmq/sbin目录</p><p>启动服务：<code># ./rabbitmq-server -detached</code></p><p>查看服务状态：<code># ./rabbitmqctl status</code></p><p>关闭服务：<code># ./rabbitmqctl stop</code></p><h3 id="2-5-配置网页插件"><a href="#2-5-配置网页插件" class="headerlink" title="2.5 配置网页插件"></a>2.5 配置网页插件</h3><p>首先创建目录，否则可能报错：<code># mkdir /etc/rabbitmq</code></p><p>启用插件：<code># ./rabbitmq-plugins enable rabbitmq_management</code></p><p>启动mq：<code># ./rabbitmq-server -detached</code></p><p>配置linux 端口： 15672 网页管理，  5672 AMQP端口</p><p>然后访问<code>http://192.168.5.154:15672/</code></p><p>这里是需要登录了。</p><p>rabbitmq默认会创建guest账号，只能用于localhost登录页面管理员，需要自己创建账号。</p><h3 id="2-6-添加账户"><a href="#2-6-添加账户" class="headerlink" title="2.6 添加账户"></a>2.6 添加账户</h3><p>查看mq用户：<code># rabbitmqctl list_users</code></p><p>查看用户权限：<code># rabbitmqctl list_user_permissions guest</code></p><p>新增用户： <code># rabbitmqctl add_user root root</code>  用户名root,密码root</p><p>赋予管理员权限：</p><p><code>rabbitmqctl set_user_tags root administrator</code></p><p><code>rabbitmqctl set_permissions -p &quot;/&quot; root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p><h2 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h2><p>1.启动报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# ./rabbitmq-server start</span><br><span class="line"></span><br><span class="line">BOOT FAILED</span><br><span class="line">===========</span><br><span class="line">=INFO REPORT==== <span class="number">21</span>-Jan-<span class="number">2019</span>::<span class="number">20</span>:<span class="number">49</span>:<span class="number">29.302765</span> ===</span><br><span class="line">Error description:</span><br><span class="line">   noproc</span><br><span class="line">   </span><br><span class="line"><span class="function">Log <span class="title">files</span> <span class="params">(may contain more information)</span>:</span></span><br><span class="line"><span class="function">   /usr/local/opt/rabbitmq/<span class="keyword">var</span>/log/rabbitmq/rabbit@localhost.log</span></span><br><span class="line"><span class="function">   /usr/local/opt/rabbitmq/<span class="keyword">var</span>/log/rabbitmq/rabbit@localhost-sasl.log</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Stack trace:</span></span><br><span class="line"><span class="function">   [</span>&#123;gen,do_for_proc,<span class="number">2</span>,[&#123;file,<span class="string">"gen.erl"</span>&#125;,&#123;line,<span class="number">228</span>&#125;]&#125;,</span><br><span class="line">    &#123;gen_event,rpc,<span class="number">2</span>,[&#123;file,<span class="string">"gen_event.erl"</span>&#125;,&#123;line,<span class="number">239</span>&#125;]&#125;,</span><br><span class="line">    &#123;rabbit,ensure_working_log_handlers,<span class="number">0</span>,</span><br><span class="line">            [&#123;file,<span class="string">"src/rabbit.erl"</span>&#125;,&#123;line,<span class="number">856</span>&#125;]&#125;,</span><br><span class="line">    &#123;rabbit,<span class="string">'-boot/0-fun-0-'</span>,<span class="number">0</span>,[&#123;file,<span class="string">"src/rabbit.erl"</span>&#125;,&#123;line,<span class="number">288</span>&#125;]&#125;,</span><br><span class="line">    &#123;rabbit,start_it,<span class="number">1</span>,[&#123;file,<span class="string">"src/rabbit.erl"</span>&#125;,&#123;line,<span class="number">424</span>&#125;]&#125;,</span><br><span class="line">    &#123;init,start_em,<span class="number">1</span>,[]&#125;,</span><br><span class="line">    &#123;init,do_boot,<span class="number">3</span>,[]&#125;]</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"init terminating in do_boot"</span>,noproc&#125;</span><br><span class="line"><span class="function">init terminating in <span class="title">do_boot</span> <span class="params">(noproc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Crash dump is being written to: erl_crash.dump...done</span></span><br></pre></td></tr></table></figure><p>这个问题网上查了一下，有的说是权限问题，也有说是erlang和rabbitmq版本对应不上，暂时没解决。</p><p>以解决，确实是版本问题，erlang版本和rabbitmq的版本对应不上，最前面单独写了这个关于版本的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要讲了如何通过解压方式在Linux下安装RabbitMQ和Erlang，超级详细的安装过程，和安装过程中遇到的一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.lixueduan.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.lixueduan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法与小技巧</title>
    <link href="https://www.lixueduan.com/posts/9b0e40a3.html"/>
    <id>https://www.lixueduan.com/posts/9b0e40a3.html</id>
    <published>2019-01-18T14:00:00.000Z</published>
    <updated>2019-02-06T01:11:18.948Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了关于markdown的一些常用语法和技巧，让大家更好的写文章。自从17年前开始在 GitHub 玩耍，接触到 Markdown 之后，就感觉很有意思。不过也仅仅是了解一下基本语法，所以找了一下Markdown的语法用法来学习学习。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><p>如下：</p><p><em>注：如下技巧大多是利用 Markdown 兼容部分 HTML 标签的特性来完成，不一定在所有网站和软件里都完全支持，主要以 GitHub 支持为准。</em></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># This is an &lt;h1&gt; tag</span><br><span class="line">## This is an &lt;h2&gt; tag</span><br><span class="line">###### This is an &lt;h6&gt; tag</span><br></pre></td></tr></table></figure><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*This text will be italic*</span><br><span class="line">_This will also be italic_</span><br><span class="line"></span><br><span class="line">**This text will be bold**</span><br><span class="line">__This will also be bold__</span><br><span class="line"></span><br><span class="line">_You **can** combine them_</span><br></pre></td></tr></table></figure><p><em>This text will be italic</em><br><em>This will also be italic</em></p><p><strong>This text will be bold</strong><br><strong>This will also be bold</strong></p><p><em>You <strong>can</strong> combine them</em></p><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><h3 id="无序"><a href="#无序" class="headerlink" title="无序"></a>无序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* Item 1</span><br><span class="line">* Item 2</span><br><span class="line">  * Item 2a</span><br><span class="line">  * Item 2b</span><br></pre></td></tr></table></figure><ul><li>Item 1</li><li>Item 2<ul><li>Item 2a</li><li>Item 2b</li></ul></li></ul><h3 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Item 1</span><br><span class="line">1. Item 2</span><br><span class="line">1. Item 3</span><br><span class="line">   1. Item 3a</span><br><span class="line">   1. Item 3b</span><br></pre></td></tr></table></figure><ol><li>Item 1</li><li>Item 2</li><li>Item 3<ol><li>Item 3a</li><li>Item 3b</li></ol></li></ol><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![GitHub Logo](/images/logo.png)</span><br><span class="line">Format: ![Alt Text](url)</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://github.com - automatic!</span><br><span class="line">[GitHub](http://github.com)</span><br></pre></td></tr></table></figure><p><a href="http://github.com" target="_blank" rel="noopener">http://github.com</a> - automatic!<br><a href="http://github.com" target="_blank" rel="noopener">GitHub</a></p><h2 id="引用文字"><a href="#引用文字" class="headerlink" title="引用文字"></a>引用文字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">As Kanye West said:</span><br><span class="line"></span><br><span class="line">&gt; We&apos;re living the future so</span><br><span class="line">&gt; the present is our past.</span><br></pre></td></tr></table></figure><p>As Kanye West said:</p><blockquote><p>We’re living the future so<br>the present is our past.</p></blockquote><h2 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I think you should use an</span><br><span class="line">`&lt;addr&gt;` element here instead.</span><br></pre></td></tr></table></figure><p>I think you should use an<br><code>&lt;addr&gt;</code> element here instead.</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>用两个波浪线（如<code>~~this~~</code>）包裹的任何单词都会显示为划掉。</p><p><del>这是被删除的内容</del></p><h2 id="在表格单元格里换行"><a href="#在表格单元格里换行" class="headerlink" title="在表格单元格里换行"></a>在表格单元格里换行</h2><p>借助于 HTML 里的 <code>&lt;br /&gt;</code> 实现。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| Header1 | Header2                          |</span><br><span class="line">|---------|----------------------------------|</span><br><span class="line">| item 1  | 1. one&lt;br /&gt;2. two&lt;br /&gt;3. three |</span><br></pre></td></tr></table></figure><p>示例效果：</p><table><thead><tr><th>Header1</th><th>Header2</th></tr></thead><tbody><tr><td>item 1</td><td>1. one<br>2. two<br>3. three</td></tr></tbody></table><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p> 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; </p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。 </p><hr><hr><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">​```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 表格</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">左对齐标题</th><th style="text-align:right">右对齐标题</th><th style="text-align:center">居中对齐标题</th></tr></thead><tbody><tr><td style="text-align:left">短文本</td><td style="text-align:right">中等文本</td><td style="text-align:center">稍微长一点的文本</td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:right">短文本</td><td style="text-align:center">中等文本</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; //语法：</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1）|、-、:之间的多余空格会被忽略，不影响布局。</span><br><span class="line">&gt; 2）默认标题栏居中对齐，内容居左对齐。</span><br><span class="line">&gt; 3）-:表示内容和标题栏居右对齐，:-表示内容和标题栏居左对齐，:-:表示内容和标题栏居中对齐。</span><br><span class="line">&gt; 4）内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少有一个。</span><br><span class="line"></span><br><span class="line">表格在渲染之后很整洁好看，但是在文件源码里却可能是这样的：</span><br></pre></td></tr></table></figure><table><thead><tr><th>Header1</th><th>Header2</th></tr></thead><tbody><tr><td>a</td><td>a</td></tr><tr><td>ab</td><td>ab</td></tr><tr><td>abc</td><td>abc</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不知道你能不能忍，反正我是不能忍。</span><br><span class="line"></span><br><span class="line">好在广大网友们的智慧是无穷的，在各种编辑器里为 Markdown 提供了表格格式化功能，比如我使用 Vim 编辑器，就有 [vim-table-mode](https://github.com/dhruvasagar/vim-table-mode) 插件，它能帮我自动将表格格式化成这样：</span><br></pre></td></tr></table></figure><table><thead><tr><th>Header1</th><th>Header2</th></tr></thead><tbody><tr><td>a</td><td>a</td></tr><tr><td>ab</td><td>ab</td></tr><tr><td>abc</td><td>abc</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是不是看着舒服多了？</span><br><span class="line"></span><br><span class="line">如果你不使用 Vim，也没有关系，比如 Atom 编辑器的 [markdown-table-formatter](https://atom.io/packages/markdown-table-formatter) 插件，Sublime Text 3 的 [MarkdownTableFormatter](https://github.com/bitwiser73/MarkdownTableFormatter) 等等，都提供了类似的解决方案。</span><br><span class="line"></span><br><span class="line">## 使用 Emoji</span><br><span class="line"></span><br><span class="line">这个是 GitHub 对标准 Markdown 标记之外的扩展了，用得好能让文字生动一些。</span><br><span class="line"></span><br><span class="line">示例代码：</span><br></pre></td></tr></table></figure><p>我和我的小伙伴们都笑了。:smile:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例效果：</span><br><span class="line"></span><br><span class="line">我和我的小伙伴们都笑了。:smile:</span><br><span class="line"></span><br><span class="line">[Github支持的表情在这里哟](https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md)</span><br><span class="line"></span><br><span class="line">## 行首缩进</span><br><span class="line"></span><br><span class="line">直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，`&amp;ensp;` 代表半角空格，`&amp;emsp;` 代表全角空格。</span><br><span class="line"></span><br><span class="line">示例代码：</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;春天来了，又到了万物复苏的季节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例效果：</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;春天来了，又到了万物复苏的季节。</span><br><span class="line"></span><br><span class="line">## 展示数学公式</span><br><span class="line"></span><br><span class="line">如果是在 GitHub Pages，可以参考 &lt;http://wanguolin.github.io/mathmatics_rending/&gt; 使用 MathJax 来优雅地展示数学公式（非图片）。</span><br><span class="line"></span><br><span class="line">如果是在 GitHub 项目的 README 等地方，目前我能找到的方案只能是贴图了，以下是一种比较方便的贴图方案：</span><br><span class="line"></span><br><span class="line">1. 在 &lt;https://www.codecogs.com/latex/eqneditor.php&gt; 网页上部的输入框里输入 LaTeX 公式，比如 `$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$`；</span><br><span class="line"></span><br><span class="line">2. 在网页下部拷贝 URL Encoded 的内容，比如以上公式生成的是 `https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24`；</span><br><span class="line"></span><br><span class="line">   ![](D:\lillusory\MyProject\lillusory.github.io\images\posts\Markdown\Markdown_latex_img)</span><br><span class="line"></span><br><span class="line">3. 在文档需要的地方使用以上 URL 贴图，比如</span><br></pre></td></tr></table></figure></p><p>   <img src="https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24" alt=""><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   示例效果：</span><br><span class="line"></span><br><span class="line">   ![](https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24)</span><br><span class="line"></span><br><span class="line">## 任务列表</span><br><span class="line"></span><br><span class="line">在 GitHub 和 GitLab 等网站，除了可以使用有序列表和无序列表外，还可以使用任务列表，很适合要列出一些清单的场景。</span><br><span class="line"></span><br><span class="line">示例代码：</span><br></pre></td></tr></table></figure></p><p><strong>购物清单</strong></p><ul><li style="list-style: none"><input type="checkbox"> 一次性水杯</li><li style="list-style: none"><input type="checkbox" checked> 西瓜</li><li style="list-style: none"><input type="checkbox"> 豆浆</li><li style="list-style: none"><input type="checkbox" checked> 可口可乐</li><li style="list-style: none"><input type="checkbox"> 小茗同学<br><code>`</code></li></ul><p>示例效果：</p><p><strong>购物清单</strong></p><ul><li style="list-style: none"><input type="checkbox"> 一次性水杯</li><li style="list-style: none"><input type="checkbox" checked> 西瓜</li><li style="list-style: none"><input type="checkbox"> 豆浆</li><li style="list-style: none"><input type="checkbox" checked> 可口可乐</li><li style="list-style: none"><input type="checkbox"> 小茗同学</li></ul><h2 id="自动维护目录"><a href="#自动维护目录" class="headerlink" title="自动维护目录"></a>自动维护目录</h2><p>有时候维护一份比较长的文档，希望能够自动根据文档中的标题生成目录（Table of Contents），并且当标题有变化时自动更新目录，能减轻工作量，也不易出错。比如 Atom 编辑器的 <a href="https://atom.io/packages/markdown-toc" target="_blank" rel="noopener">markdown-toc</a> 插件，Sublime Text 的 <a href="https://packagecontrol.io/packages/MarkdownTOC" target="_blank" rel="noopener">MarkdownTOC</a> 插件等。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>希望自己，也希望大家在了解这些之后能有所收获，更好地排版，专注写作。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://raw.githubusercontent.com/matiassingers/awesome-readme/master/readme.md" target="_blank" rel="noopener">https://raw.githubusercontent.com/matiassingers/awesome-readme/master/readme.md</a></li><li><a href="https://www.zybuluo.com/songpfei/note/247346" target="_blank" rel="noopener">https://www.zybuluo.com/songpfei/note/247346</a></li><li><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">支持的表情</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了关于markdown的一些常用语法和技巧，让大家更好的写文章。自从17年前开始在 GitHub 玩耍，接触到 Markdown 之后，就感觉很有意思。不过也仅仅是了解一下基本语法，所以找了一下Markdown的语法用法来学习学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://www.lixueduan.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="https://www.lixueduan.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装MySQL教程</title>
    <link href="https://www.lixueduan.com/posts/1be8c408.html"/>
    <id>https://www.lixueduan.com/posts/1be8c408.html</id>
    <published>2019-01-16T14:00:00.000Z</published>
    <updated>2019-02-06T01:12:10.263Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要讲了如何通过解压方式在Linux下安装MySQL，以及如何设置让我们可以远程连接到服务器上的mysql.</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><p>软件统一放在<code>/usr/software</code>下 解压后放在单独的文件夹下<code>/usr/local/java</code>/<code>/usr/local/mysql</code></p><p>其中：<code>#</code>为Linux命令，<code>mysql</code>则是mysql下的命令</p><p>软件统一放在<code>/usr/software</code>下 解压后放在单独的文件夹下<code>/usr/local/java</code>/<code>/usr/local/mysql</code></p><p>安装包下载<code>mysql-5.7.24-linux-glibc2.12-x86_64.tar</code></p><p>网址<code>https://dev.mysql.com/downloads/mysql/5.7.html#downloads</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/software-install/mysql5.7-down.png" alt="mysql"></p><h2 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y cmake make gcc gcc-c++ libaio ncurses ncurses-devel</span><br></pre></td></tr></table></figure><h2 id="2-解压文件"><a href="#2-解压文件" class="headerlink" title="2. 解压文件"></a>2. 解压文件</h2><p>压缩包上传到虚拟机<code>/usr/software目录下</code>,进入这个目录</p><p>解压文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>将解压后的文件移动到<code>/usr/local/mysql</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mv mysql-5.7.24-linux-glibc2.12-x86_64 /usr/local/mysql</span><br></pre></td></tr></table></figure><h2 id="3-添加用户和赋权"><a href="#3-添加用户和赋权" class="headerlink" title="3. 添加用户和赋权"></a>3. 添加用户和赋权</h2><p>1.添加用户和用户组</p><p>给mysql赋权的用户必须对当前目录具有读写权限，但是一般不用root账户，所以创建一个用户mysql。</p><p>执行命令：创建用户组mysql<code>groupadd mysql`</code></p><p>创建用户也叫mysql </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 命令中第一个mysql是用户，第二个mysql是用户组。</span><br><span class="line"># useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure><p>2.给用户赋权限</p><p> 一定保证当前是在<code>/usr/local/mysql</code> 目录下</p><p>给用户组赋权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//mysql是用户组名</span><br><span class="line"># chgrp -R mysql.</span><br></pre></td></tr></table></figure><p>给用户赋权限  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个mysql是用户名</span><br><span class="line">#  chown -R mysql.</span><br></pre></td></tr></table></figure><h2 id="4-数据库初始化"><a href="#4-数据库初始化" class="headerlink" title="4. 数据库初始化"></a>4. 数据库初始化</h2><p>安装数据库 : </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里会生成临时密码，后边有用</span><br><span class="line"># bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</span><br></pre></td></tr></table></figure><p>执行以下命令创建RSA private key ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bin/mysql_ssl_rsa_setup --datadir=/usr/local/mysql/data</span><br></pre></td></tr></table></figure><h2 id="5-配置my-cnf"><a href="#5-配置my-cnf" class="headerlink" title="5. 配置my.cnf"></a>5. 配置my.cnf</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p> 内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=<span class="string">'SET NAMES utf8'</span></span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">#不区分大小写 (sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 这个简单来说就是sql语句是否严格)</span><br><span class="line">lower_case_table_names = <span class="number">1</span></span><br><span class="line">log-error=/<span class="keyword">var</span>/log/mysqld.log</span><br><span class="line">pid-file=/usr/local/mysql/data/mysqld.pid</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cp /usr/local/mysql/support-files/mysql.server  /etc/init.d/mysqld</span><br><span class="line"># vim /etc/init.d/mysqld</span><br></pre></td></tr></table></figure><p>添加以下内容，在46行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/usr/local/mysql/data</span><br></pre></td></tr></table></figure><h2 id="6-修改密码"><a href="#6-修改密码" class="headerlink" title="6. 修改密码"></a>6. 修改密码</h2><p>启动mysql   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service mysqld start</span><br></pre></td></tr></table></figure><p> 加入开机起动    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig --add mysqld</span><br></pre></td></tr></table></figure><p>登录修改密码 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mysql -uroot -p 上面初始化时的密码</span><br></pre></td></tr></table></figure><p>如果出现错误 需要添加软连接 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ln -s /usr/local/mysql/bin/mysql /usr/bin</span><br></pre></td></tr></table></figure><p>如果出现<code>Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)</code>应该是密码错了，直接强行修改密码好了。先停掉mysql. </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service mysql stop</span><br></pre></td></tr></table></figure><p>然后修改配置文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p>在[mysqld]后面任意一行添加<code>skip-grant-tables</code>用来跳过密码验证的过程</p><p>接下来我们需要重启MySQL </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/mysqld restart</span><br></pre></td></tr></table></figure><p>重启之后输入命令<code>mysql</code>即可进入mysql了，然后开始修改密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line"># 这里修改密码的命令在5.7以上和5.7以下是不同的 需要注意</span><br><span class="line">mysql&gt; update user set authentication_string=passworD(&quot;你的密码&quot;) where user=&apos;root&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure><p>完成后可以把配置文件中的跳过密码验证去掉。</p><p>然后就可以正常使用啦。</p><h2 id="7-外部访问"><a href="#7-外部访问" class="headerlink" title="7. 外部访问"></a>7. 外部访问</h2><p>首先进入mysql，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mysql -u root -p</span><br></pre></td></tr></table></figure><p>接着创建远程连接 MySQL 的用户 mysql命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户、密码及权限范围 第一个 roo t为用户名 @后为适用的主机，‘%’表示所有电脑都可以访问连接，第二个 root 为密码</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;192.168.1.3&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;  </span><br><span class="line">-- 立即生效</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>查看数据库用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 使用 mysql 库</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">-- 查看用户</span><br><span class="line">mysql&gt; SELECT DISTINCT CONCAT(&apos;User: [&apos;, user, &apos;&apos;&apos;@&apos;&apos;&apos;, host, &apos;];&apos;) AS USER_HOST FROM user;  </span><br><span class="line">-- 查看端口</span><br><span class="line">mysql&gt; show global variables like &apos;port&apos;;</span><br><span class="line">--mysql 默认端口为3306</span><br></pre></td></tr></table></figure><p>解决防火墙问题</p><p>防火墙默认只开放了22端口，要访问数据库要么关掉防火墙要么修改配置文件，开放3306端口</p><p>修改防火墙配置： 命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure><p>然后重启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service iptables restart</span><br></pre></td></tr></table></figure><p>最后查看服务器IP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ip a</span><br></pre></td></tr></table></figure><p>到这里应该就可以通过IP和端口号远程连接服务器上的MySQL了。</p><h2 id="8-问题"><a href="#8-问题" class="headerlink" title="8. 问题"></a>8. 问题</h2><p>mysql中执行命令出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.</span><br></pre></td></tr></table></figure><p>解决： 修改用户密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;你的密码&apos;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><code>https://blog.csdn.net/z13615480737/article/details/80019881</code></p><p><code>https://www.cnblogs.com/goodcheap/p/7103049.html</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要讲了如何通过解压方式在Linux下安装MySQL，以及如何设置让我们可以远程连接到服务器上的mysql.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.lixueduan.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.lixueduan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装jdk和Tomcat</title>
    <link href="https://www.lixueduan.com/posts/54978294.html"/>
    <id>https://www.lixueduan.com/posts/54978294.html</id>
    <published>2019-01-15T14:00:00.000Z</published>
    <updated>2019-02-06T01:11:52.157Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要讲了如何通过解压方式在Linux下安装JDK和Tomcat等软件。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><p>软件统一放在<code>/usr/software</code>下 解压后放在单独的文件夹下<code>/usr/local/java</code>/<code>/usr/local/mysql</code></p><h2 id="1-JDK"><a href="#1-JDK" class="headerlink" title="1.JDK"></a>1.JDK</h2><p>安装包下载<code>jdk-8u191-linux-x64.tar.gz</code> 注意32位和64位的别下载错了。</p><p>命令<code>uname -a</code> 查看Linux系统位数。</p><p>网址：<code>https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</code></p><p>1.首先将压缩包传到虚拟机。放在<code>/usr/software</code>下</p><p>2.然后解压文件<code>tar zxvf jdk-8u191-linux-x64.tar.gz</code> 按tab会自动补全。</p><p>3.将解压得到的文件移动到<code>/usr/local/java</code>,命令`mv jdk1.8.0_191/ /usr/local/jdk8</p><p>4.配置环境变量 </p><p> 命令<code>vim /etc/profile</code> </p><p>添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　export JAVA_HOME=/usr/local/jdk8/</span><br><span class="line">　export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">　export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>5.解析该文件 命令<code>source /etc/profile</code></p><p>6.测试 命令 <code>java -version</code> 输出版本信息就说明配好了。</p><h2 id="2-Tomcat"><a href="#2-Tomcat" class="headerlink" title="2.Tomcat"></a>2.Tomcat</h2><p>安装包下载<code>apache-tomcat-8.5.37.tar.gz</code></p><p>网址<code>https://tomcat.apache.org/download-80.cgi</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/software-install/tomcat8-down.png" alt=""></p><p>1.压缩包上传到虚拟机<code>/usr/software目录下</code></p><p>2.解压文件 <code>tar zxvf apache-tomcat-8.5.37.tar.gz</code></p><p>3.将解压后的文件移动到<code>/usr/local/tomcat</code>,命令<code>mv apache-tomcat-8.5.37 /usr/local/tomcat</code></p><p>4.配置环境变量 </p><p> 命令<code>vim /etc/profile</code> </p><p>添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export TOMCAT_HOME=/usr/local/tomcat</span><br><span class="line">export CATANILA_HOME=/usr/local/tomcat</span><br></pre></td></tr></table></figure><p>5.解析该文件 命令<code>source /etc/profile</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要讲了如何通过解压方式在Linux下安装JDK和Tomcat等软件。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.lixueduan.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.lixueduan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的网络配置</title>
    <link href="https://www.lixueduan.com/posts/b0d13a6d.html"/>
    <id>https://www.lixueduan.com/posts/b0d13a6d.html</id>
    <published>2019-01-14T14:00:00.000Z</published>
    <updated>2019-02-06T01:11:32.454Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要讲了linux如何配置网络，让虚拟机能够连上外网，如何让虚拟机和主机联通，同时介绍了ssh客户端工具连接虚拟机。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-Xshell"><a href="#1-Xshell" class="headerlink" title="1. Xshell"></a>1. Xshell</h2><p>在安装好虚拟机后就可以正常使用了。但是在正常工作中不可能真的在服务器上操作，一般都是通过ssh客户端工具连接服务器进行操作。</p><p>这里用到的客户端工具是<code>Xshell</code>,通过该工具连上服务器后就可以在自己的电脑上操作了。而且还可以开多个窗口，比较方便。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/xshell-use.png" alt="xshell"></p><p>这里新建连接时需要输入要连接的服务器的IP和端口号，账户和密码，端口号默认是22，一般不用改。</p><h2 id="2-网络配置"><a href="#2-网络配置" class="headerlink" title="2. 网络配置"></a>2. 网络配置</h2><h3 id="2-1-桥接模式和NAT模式"><a href="#2-1-桥接模式和NAT模式" class="headerlink" title="2.1 桥接模式和NAT模式"></a>2.1 桥接模式和NAT模式</h3><p>按照上面的方法就可以连上虚拟机了，但是现在虚拟机的IP是自动获取的，<strong>每次重启后都IP都会变</strong>，这肯定不行呀，所以我们需要为虚拟机设置<strong>静态IP</strong>.</p><p>由于我们这里使用的是NAT模式。这个模式下虚拟机可以上网，但是无法和主机联通。</p><p><strong>桥接模式和NAT模式的区别：</strong></p><p>桥接模式下虚拟机可以看做一台真正的独立的电脑，所以桥接模式下需要为虚拟机分配独立的IP，在家里到时无所谓，在公司的话由于IP和电脑绑定的，所以需要网络管理人员给你的虚拟机分配一个IP才行。</p><p>NAT模式下，虚拟机会动态获取IP,虽然有自己的IP但是最终上网还是通过主机上网的。所以NAT模式下不用分配独立的IP,但是<strong>NAT模式下主机和虚拟机无法联通。</strong></p><p><strong>为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。</strong></p><p><strong>为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。</strong></p><p><strong>为了主机和虚拟机联通，我们必须让主机和虚拟机在同一个网段下。</strong></p><h3 id="2-2-设置静态IP"><a href="#2-2-设置静态IP" class="headerlink" title="2.2 设置静态IP"></a>2.2 设置静态IP</h3><p>在设置静态IP前我们需要知道主机的IP.</p><p>windows下命令行输入 <code>ipconfig</code> 即可获取到本机IP.</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/ip-query.png" alt="ipconfig"></p><p>然后通过VMware软件对网络进行配置。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/ip-set-way.png" alt="vmware"></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/network-set/vm-ip-set.png" alt="static ip"></p><p>接着在虚拟机中配置具体网络信息。</p><h3 id="2-3-网络配置"><a href="#2-3-网络配置" class="headerlink" title="2.3 网络配置"></a>2.3 网络配置</h3><h4 id="2-3-1-网卡配置"><a href="#2-3-1-网卡配置" class="headerlink" title="2.3.1 网卡配置"></a>2.3.1 网卡配置</h4><p>网络配置文件在<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>目录下，一般是叫<code>ifcfg-ens33</code></p><p>编辑配置文件 命令：<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>配置如下 ：</p><p>其中ip地址必须和主机在同一网段下，网关就是上边的那个网关。DNS可填可不填。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO="static"  # 手动分配ip</span><br><span class="line">ONBOOT="yes"  # 该网卡是否随网络服务启动</span><br><span class="line">IPADDR="192.168.1.111"  # 该网卡ip地址就是你要配置的固定IP</span><br><span class="line">GATEWAY="192.168.1.2"   # 网关</span><br><span class="line">NETMASK="255.255.255.0"   # 子网掩码 固定值</span><br><span class="line">DNS1="8.8.8.8"    # DNS，8.8.8.8为Google提供的免费DNS服务器的IP地址</span><br><span class="line">DNS2="192.168.1.2"</span><br></pre></td></tr></table></figure><h4 id="2-3-2-网络配置"><a href="#2-3-2-网络配置" class="headerlink" title="2.3.2 网络配置"></a>2.3.2 网络配置</h4><p>命令：<code>vi /etc/sysconfig/network</code> 添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes # 网络是否工作，此处一定不能为no</span><br><span class="line">NETWORKING_IPV6=no</span><br><span class="line">HOSTNAME=localhost.localdomain</span><br><span class="line">GATEWAY=192.168.1.2</span><br></pre></td></tr></table></figure><h4 id="2-3-3-配置公共DNS服务"><a href="#2-3-3-配置公共DNS服务" class="headerlink" title="2.3.3 配置公共DNS服务"></a>2.3.3 配置公共DNS服务</h4><p><code>vi /etc/resolv.conf</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search localdomain</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 192.168.1.2</span><br></pre></td></tr></table></figure><h4 id="2-3-4-关闭防火墙"><a href="#2-3-4-关闭防火墙" class="headerlink" title="2.3.4 关闭防火墙"></a>2.3.4 关闭防火墙</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld # 临时关闭防火墙</span><br><span class="line">systemctl disable firewalld # 禁止开机启动</span><br></pre></td></tr></table></figure><h4 id="2-3-5-重启网络服务"><a href="#2-3-5-重启网络服务" class="headerlink" title="2.3.5 重启网络服务"></a>2.3.5 重启网络服务</h4><p><code>service network restart</code></p><p>到此为止网络配置就完成了，现在虚拟机的IP重启后不会变了，也可以连上外网了，还可以和主机联通了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要讲了linux如何配置网络，让虚拟机能够连上外网，如何让虚拟机和主机联通，同时介绍了ssh客户端工具连接虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.lixueduan.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.lixueduan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>超详细的VMware虚拟机安装CentOS7教程</title>
    <link href="https://www.lixueduan.com/posts/4d7cca6f.html"/>
    <id>https://www.lixueduan.com/posts/4d7cca6f.html</id>
    <published>2019-01-14T14:00:00.000Z</published>
    <updated>2019-02-06T01:11:41.842Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个十分详细的CentOS7的安装教程，对自己的安装过程做了一个记录。主要记录了如何通过VMware虚拟机安装Linux，从软件下载到虚拟机安装等等。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="1-1-VMware下载"><a href="#1-1-VMware下载" class="headerlink" title="1.1 VMware下载"></a>1.1 VMware下载</h3><p>百度网盘下载（内含注册机）</p><p>链接: <code>https://pan.baidu.com/s/1wz4hdNQBikTvyUMNokSVYg</code>提取码: yed7</p><p>怎么安装就不用写了吧。</p><h3 id="1-2-CentOS下载"><a href="#1-2-CentOS下载" class="headerlink" title="1.2 CentOS下载"></a>1.2 CentOS下载</h3><p><code>http://mirrors.163.com/centos/7.6.1810/isos/x86_64/</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/software-install/centos7-down.png" alt=""></p><h2 id="2-CentOS-7安装"><a href="#2-CentOS-7安装" class="headerlink" title="2. CentOS 7安装"></a>2. CentOS 7安装</h2><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/1-create-vm.png" alt=""></p><p>创建虚拟机，这里我们选择自定义安装类型。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/2-custom-install.png" alt=""></p><p>然后选择版本，需要注意兼容问题，一般是向下兼容，14上的虚拟机复制到15上可以用，15的复制到14上可能会用不了。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/3-version-select.png" alt=""></p><p>这里选择稍后再安装。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/4-after-install.png" alt=""></p><p>接着选择系统，这里是CentOS 7 64位。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/5-system-select.png" alt=""></p><p>这个是保存的文件名字。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/6-filename.png" alt=""></p><p>这里一般默认的就行了,电脑配置好的可以调高点。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/7-cpu-select.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/8-memory-select.png" alt=""></p><p>网络这里,如果仅仅是让虚拟机能上网，两种模式都可以的，用桥接的话只要你在局域网内有合法的地址，比如你的ADSL猫是带路由功能的，如果是在单位，那就要网络管理人员给你合法IP才行。NAT模式下，虚拟机从属于主机，也就是访问外部网络必须通过主机来访问，因此虚拟机的IP只有主机才能识别。而桥接模式下，虚拟机和主机是平行关系，共享一张网卡（使用网卡的多个接口），可以直接访问外部网络。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/9-network-select.png" alt=""></p><p>这些都默认的就行了。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/10-IO-select.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/11-disk-select.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/12-newdisk-select.png" alt=""></p><p>这个是虚拟机文件的名字。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/14-filename.png" alt=""></p><p>这里选择自定义硬件。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/15-custom.png" alt=""></p><p>选择镜像文件。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/17-file-select.png" alt=""></p><p>到这里就结束了，点击开启虚拟机后会自动开始安装。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/18-start.png" alt=""></p><p>选择安装CentOS 7</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/19-setup.png" alt=""></p><p>语言选择</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/20-language.png" alt=""></p><p>调一下时间和地区。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/21-time.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/22-time2.png" alt=""></p><p>选择要安装的软件，新手还是安装一个GUI比较好。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/23-software1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/24-software2.png" alt=""></p><p>查看一下网络连接</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/25-network-set1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/26-network-set2.png" alt=""></p><p>开始安装。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/27-begin-install.png" alt=""></p><p>安装过程中可以设置一下账号密码，一个root账户，一个普通账户。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/28-password-set1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/29-password-set2.png" alt=""></p><p>然后耐心等待安装完成就好了。</p><p>安装完成后重启就可以登录系统了。</p><h2 id="3-快照"><a href="#3-快照" class="headerlink" title="3. 快照"></a>3. 快照</h2><p>快照相当于windows中的还原点。在安装好后可以拍摄一张快照，方便恢复或者克隆虚拟机。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/linux/centos7-install/30-backup1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个十分详细的CentOS7的安装教程，对自己的安装过程做了一个记录。主要记录了如何通过VMware虚拟机安装Linux，从软件下载到虚拟机安装等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.lixueduan.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.lixueduan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo搭建个人博客优化之（五）--压缩篇</title>
    <link href="https://www.lixueduan.com/posts/70deabab.html"/>
    <id>https://www.lixueduan.com/posts/70deabab.html</id>
    <published>2019-01-10T14:00:00.000Z</published>
    <updated>2019-02-06T01:14:13.774Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要记录了如何通过<code>gulp</code>工具压缩压缩博客静态文件以加快网站加载速度。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><p>在本系列文章的第二章中也有类似静态资源压缩的教程，是用的<code>hexo-neat</code>插件，最近用着用着出现了一点点问题，无奈之下换用了<code>gulp</code>。这个工具也可以很方便的压缩静态资源。</p><h2 id="1-插件安装"><a href="#1-插件安装" class="headerlink" title="1. 插件安装"></a>1. 插件安装</h2><p>首先需要安装<code>gulp</code>工具</p><p>命令：<code>npm install gulp</code></p><p>接着安装功能模块，包括</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp-htmlclean // 清理html</span><br><span class="line">gulp-htmlmin // 压缩html</span><br><span class="line">gulp-minify-css // 压缩css</span><br><span class="line">gulp-uglify // 混淆js</span><br></pre></td></tr></table></figure><p>命令：<code>npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</code></p><h2 id="2-创建任务"><a href="#2-创建任务" class="headerlink" title="2. 创建任务"></a>2. 创建任务</h2><p>在站点根目录下，新建<code>gulpfile.js</code>文件，文件内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Plugins模块获取</span></span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">//压缩css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">.pipe(htmlclean())</span><br><span class="line">.pipe(htmlmin(&#123;</span><br><span class="line">removeComments: <span class="literal">true</span>,</span><br><span class="line">minifyJS: <span class="literal">true</span>,</span><br><span class="line">minifyCSS: <span class="literal">true</span>,</span><br><span class="line">minifyURLs: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩js 不压缩min.js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以前的写法 </span></span><br><span class="line"><span class="comment">//gulp.task('default', [</span></span><br><span class="line">  <span class="comment">//  'minify-html', 'minify-css', 'minify-js'</span></span><br><span class="line"><span class="comment">//]);</span></span><br><span class="line"><span class="comment">//4.0以后的写法</span></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something after a, b, and c are finished.</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><p>使用时按照以下顺序就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">//先清理文件</span></span><br><span class="line">hexo g  <span class="comment">//编译生成静态文件</span></span><br><span class="line">gulp  <span class="comment">//gulp插件执行压缩任务</span></span><br><span class="line">hexo s <span class="comment">//开启服务</span></span><br></pre></td></tr></table></figure><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4. 问题"></a>4. 问题</h2><p>刚开始弄这个的时候也是各种百度，Google，大部分的文章也是这么写的但是，第二部的js 代码却都有问题，也不能说有问题吧，大部分都是4.0以前的写法，导致现在gulp更新到4.0之后全都无法使用了。可能在看到这篇文章之前也试了各种办法。然后每次都出现这样的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">assert</span>.js:<span class="number">85</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">assert</span>.AssertionError(&#123;</span><br><span class="line">  ^</span><br><span class="line">AssertionError: Task function must be specified</span><br><span class="line">    at Gulp.set [as _setTask] (/home/hope/web/node_modules/undertaker/lib/set-task.js:<span class="number">10</span>:<span class="number">3</span>)</span><br><span class="line">    at Gulp.task (/home/hope/web/node_modules/undertaker/lib/task.js:<span class="number">13</span>:<span class="number">8</span>)</span><br><span class="line">.................</span><br></pre></td></tr></table></figure><p>在看了下gulp相关资料后才发现了问题，接着把js代码稍微改了改终于能用了。不过运行的时候好像也有点问题，不过不影响使用，对这些工具还是不太了解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">21</span>:<span class="number">35</span>:<span class="number">20</span>] The following tasks did not complete: <span class="keyword">default</span>, &lt;anonymous&gt;</span><br><span class="line">[<span class="number">21</span>:<span class="number">35</span>:<span class="number">20</span>] Did you forget to signal async completion?</span><br><span class="line"><span class="comment">//代码里也没这个任务呀</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要记录了如何通过&lt;code&gt;gulp&lt;/code&gt;工具压缩压缩博客静态文件以加快网站加载速度。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Synchronize和Volatile底层实现原理</title>
    <link href="https://www.lixueduan.com/posts/cf1a701a.html"/>
    <id>https://www.lixueduan.com/posts/cf1a701a.html</id>
    <published>2019-01-08T14:00:00.000Z</published>
    <updated>2019-02-06T01:17:53.174Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看<code>并发编程的艺术</code>这本书，希望加深对并发这块的理解。毕竟并发相关还是十分重要的。本文主要是关于<code>第二章Java并发机制的底层实现原理</code>的相关笔记。主要包括<code>volatile</code>,<code>synchronized</code>,<code>原子操作</code>等实现原理的分析。</p><a id="more"></a><blockquote><p>更多文章欢迎访问我的个人博客–&gt;<a href="https://www.lixueduan.com/">幻境云图</a></p></blockquote><h2 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1. 上下文切换"></a>1. 上下文切换</h2><p><strong>多线程</strong></p><p>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。</p><p><strong>什么是上下文切换</strong></p><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。</p><p>所以任务从保存到再加载的过程就是一次上下文切换。</p><p><strong>上下文切换也会影响多线程的执行速度</strong></p><p>因为线程有创建和上下文切换的开销，所以有时候并发不一定比串行快。</p><p><strong>减少上下文切换的办法</strong></p><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p><ul><li>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一<br>些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li><li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这<br>样会造成大量线程都处于等待状态。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><h2 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2. volatile关键字"></a>2. volatile关键字</h2><p><strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</strong></p><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，其中就包括了<code>Lock前缀</code>.Lock前缀的指令在多核处理器下会引发了两件事情。</p><p><strong>1）将当前处理器缓存行的数据写回到系统内存。</strong></p><p>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。</p><p>如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区<br>域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁<br>定”，<code>缓存一致性</code>机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</p><p><strong>2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</strong></p><p>处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</p><h2 id="3-synchronized原理与应用"><a href="#3-synchronized原理与应用" class="headerlink" title="3. synchronized原理与应用"></a>3. synchronized原理与应用</h2><p><strong>Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</strong></p><p>Java中的每一个对象都可以作为锁。具体表现<br>为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。<br>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</li></ul><h3 id="3-1-底层实现"><a href="#3-1-底层实现" class="headerlink" title="3.1 底层实现"></a>3.1 底层实现</h3><p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。</p><p><code>代码块同步</code>是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的.</p><p>而<code>方法同步</code>是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</p><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h2 id="3-2-Java对象头"><a href="#3-2-Java对象头" class="headerlink" title="3.2 Java对象头"></a>3.2 Java对象头</h2><p>synchronized用的锁是存在Java对象头里的。</p><p>java的对象头由以下三部分组成：</p><blockquote><p>1，Mark Word</p><p>2，指向类的指针</p><p>3，数组长度（只有数组对象才有）</p></blockquote><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java-mark-work%E5%8F%98%E5%8C%96%E7%8A%B6%E6%80%81.png" alt=""></p><h3 id="3-3-锁的升级与对比"><a href="#3-3-锁的升级与对比" class="headerlink" title="3.3 锁的升级与对比"></a>3.3 锁的升级与对比</h3><p>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状<br>态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p><p><strong>偏向锁</strong></p><p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p>偏向锁解除</p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程.</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E5%81%8F%E5%90%91%E9%94%81.png" alt=""></p><p><strong>轻量级锁</strong></p><p>（1）轻量级锁加锁<br>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>（2）轻量级锁解锁<br>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt=""></p><p><strong>优缺点比较</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/art_of_concurrent_coding/java%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83.png" alt=""></p><h2 id="4-原子操作的实现原理"><a href="#4-原子操作的实现原理" class="headerlink" title="4. 原子操作的实现原理"></a>4. 原子操作的实现原理</h2><p>原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p><h3 id="4-1-处理器如何实现原子操作"><a href="#4-1-处理器如何实现原子操作" class="headerlink" title="4.1 处理器如何实现原子操作"></a>4.1 处理器如何实现原子操作</h3><p>处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><p><strong>第一个机制是通过总线锁保证原子性。</strong></p><p>所谓总线锁就是使用处理器提供的一个<code>LOCK＃信号</code>，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p><p><strong>第二个机制是通过缓存锁定来保证原子性。</strong></p><p>总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<code>缓存一致性</code>机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效.</p><h3 id="4-2-Java如何实现原子操作"><a href="#4-2-Java如何实现原子操作" class="headerlink" title="4.2 Java如何实现原子操作"></a>4.2 Java如何实现原子操作</h3><p><strong>使用循环CAS实现原子操作</strong></p><p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p><p><strong>CAS实现原子操作的三大问题</strong></p><p>1.ABA问题</p><p>但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。</p><p>2.循环时间长开销大</p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>3.只能保证一个共享变量的原子操作</p><p>操作多个共享变量时无法使用CAS操作，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。</p><p><strong>使用锁机制实现原子操作</strong></p><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文内容来自Java并发编程的艺术</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看&lt;code&gt;并发编程的艺术&lt;/code&gt;这本书，希望加深对并发这块的理解。毕竟并发相关还是十分重要的。本文主要是关于&lt;code&gt;第二章Java并发机制的底层实现原理&lt;/code&gt;的相关笔记。主要包括&lt;code&gt;volatile&lt;/code&gt;,&lt;code&gt;synchronized&lt;/code&gt;,&lt;code&gt;原子操作&lt;/code&gt;等实现原理的分析。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.lixueduan.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.lixueduan.com/tags/Java/"/>
    
  </entry>
  
</feed>
