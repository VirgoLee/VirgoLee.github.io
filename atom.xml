<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻境云图</title>
  
  <subtitle>不忘初心,方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lixueduan.com/"/>
  <updated>2019-01-03T11:31:17.447Z</updated>
  <id>https://www.lixueduan.com/</id>
  
  <author>
    <name>illusoryCloud</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo个人博客之转移（四）</title>
    <link href="https://www.lixueduan.com/posts/33469.html"/>
    <id>https://www.lixueduan.com/posts/33469.html</id>
    <published>2018-12-27T14:00:00.000Z</published>
    <updated>2019-01-03T11:31:17.447Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --><p>本章主要记录了如何通过使用<code>Github</code>的<code>分支功能</code>解决更换电脑后博客更新不方便的问题，让你的博客能在各个电脑上灵活切换。在也不用担心换电脑后博客配置丢失等问题了。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><p>到此为止，我们已经完成了差不多所有的步骤。</p><ul><li>1.搭建博客</li><li>2.优化主题</li><li>3.部署收录</li></ul><p><strong>新问题：</strong></p><p>​ 现在博客只能在自己的电脑上更新，如果换电脑了就很麻烦。配置文件主题什么的都要重新弄。所以网上找了找多台电脑同时操作的办法，我们可以利用Github的分支功能。</p><p>​ 将博客文件夹下所有文件全<code>push</code>到<code>Github</code>。这样换电脑后直接<code>pull</code>就可以了。</p><h2 id="1-新建分支"><a href="#1-新建分支" class="headerlink" title="1. 新建分支"></a>1. 新建分支</h2><ul><li><p>1.在<code>Github</code>的<code>lillusory.github.io</code>（hexo仓库）上新建一个分支，例如<code>Hexo</code>，并切换到该分支.</p></li><li><p>2.并在该仓库<code>Settings-&gt;Branches-&gt;Default branch</code>中将默认分支设为<code>Hexo</code>.<code>Hexo</code>分支是博客的开发环境，用来写博客，保存原始文件,<code>master</code>分支用于显示，保存生产的静态文件。</p></li><li><p>3.新建分支后将博客目录下的所有文件上传到该分支，注意由于一个<code>git仓库</code>中不能包含其他仓库，所以需要删除掉主题文件夹中的<code>.git</code>目录。</p></li><li><p>4.如果按照前面的博文添加了背景，则需要删掉<code>站点目录\themes\next\source\lib\canvas-nest</code>文件夹中的<code>.git</code>目录。以后需要更新主题时，可以先克隆到本地在复制到相应目录.</p></li></ul><h2 id="2-写博客"><a href="#2-写博客" class="headerlink" title="2. 写博客"></a>2. 写博客</h2><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。</p><ul><li>依次执行<code>git add .</code>、<code>git commit -m &quot;这里写备注&quot;</code>、<code>git push origin 这里写分支名字</code>指令将改动推送到GitHub（此时当前分支应为hexo）。</li><li>然后才执行<code>hexo g -d</code>发布网站到master分支上。</li></ul><h2 id="3-博客转移"><a href="#3-博客转移" class="headerlink" title="3. 博客转移"></a>3. 博客转移</h2><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><ul><li>克隆仓库<ul><li>使用<code>git clone git@github.com:illusorycloud/illusorycloud.github.io.git</code>拷贝仓库（默认分支为hexo）；//修改成自己的</li></ul></li><li>安装插件 在前面克隆下的项目中安装插件<ul><li>执行命令<code>npm install hexo、npm install</code>、<code>npm install hexo-deployer-git</code></li></ul></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://blog.csdn.net/qq_25560423/article/details/53785707" target="_blank" rel="noopener">如何在多台电脑上更新博客</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本章主要记录了如何通过使用&lt;code&gt;Github&lt;/code&gt;的&lt;code&gt;分支功能&lt;/code&gt;解决更换电脑后博客更新不方便的问题，让你的博客能在各个电脑上灵活切换。在也不用担心换电脑后博客配置丢失等问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客之部署（三）</title>
    <link href="https://www.lixueduan.com/posts/41257.html"/>
    <id>https://www.lixueduan.com/posts/41257.html</id>
    <published>2018-12-25T04:00:00.000Z</published>
    <updated>2019-01-03T11:35:39.596Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --><p>本章主要记录了如何将博客部署至云端，怎么设置个性域名，怎么将自己的网站提交到百度Google。让自己的网站能够出现在各大搜索引擎的具体方法和过程，希望能对大家有帮助。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><h2 id="1-购买个性域名"><a href="#1-购买个性域名" class="headerlink" title="1. 购买个性域名"></a>1. 购买个性域名</h2><p>估计大家折腾了这么久也就是为 了拥有一个自己的个性站点,所以强烈建议大家为自己的博客站点配置一个独一无二的个性域名.我这里选择阿里旗下的<a href="https://wanwang.aliyun.com/?spm=5176.8142029.735711.62.f0586d3eFXYcmo" target="_blank" rel="noopener">万网</a>。我的域名是<a href="https://www.lixueduan.com">www.lixueduan.com</a></p><p>大家可以选择一个自己喜欢的域名。等部署完毕就可以通过域名访问自己的博客了。</p><p><strong>问题：</strong></p><ul><li><p><strong>GithubPages/CodingPages</strong></p><ul><li>Github Pages是<a href="https://github.com/" target="_blank" rel="noopener">Github</a>免费提供给开发者的一款托管个人网站的产品。</li><li>Coding Pages也是<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>免费提供给开发者的一款托管个人网站的产品。</li></ul></li><li><p><strong>关于为什么要部署两次</strong></p><blockquote><p>虽然可以根据自定义域名来访问自己的博客了，但是百度谷歌上都搜索不到，那岂不是很难受<code>╮(╯▽╰)╭</code>。</p><p>所以接下来为了让自己的博客能够被搜索出来，就需要让百度谷歌收录我们的网站。在部署收录过程中发现，<strong><code>Github</code>屏蔽了百度的爬虫</strong>，所以搭建上<code>GithubPages</code>的话无法提交至百度，只有Google可以收录。</p><p>所以为了让百度收录我们网站，就得在Coding上也搭建一个。</p><p>同时在搭建的过程中发现如果先搭建在Github上，然后再搭建Coding时会出现<code>DNS解析</code>冲突。所以需要：<strong>先搭建Coding上的，再搭建Github上的，国外的访问则走<code>Github</code>，国内的访问会走<code>Coding</code>，完美</strong></p></blockquote></li></ul><h2 id="2-部署到CodingPages"><a href="#2-部署到CodingPages" class="headerlink" title="2. 部署到CodingPages"></a>2. 部署到CodingPages</h2><h3 id="2-1-注册coding账户"><a href="#2-1-注册coding账户" class="headerlink" title="2.1 注册coding账户"></a>2.1 注册coding账户</h3><p>点击这里注册Coding](<a href="https://coding.net/" target="_blank" rel="noopener">https://coding.net/</a>)</p><h3 id="2-2-创建新项目"><a href="#2-2-创建新项目" class="headerlink" title="2.2 创建新项目"></a>2.2 创建新项目</h3><ul><li>注册好后创建一个项目用来部署个人博客，项目路径和项目名称最好和用户名一致</li><li><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-deploy-coding1.png" alt=""></li></ul><h3 id="2-3-开启CodingPages"><a href="#2-3-开启CodingPages" class="headerlink" title="2.3 开启CodingPages"></a>2.3 开启CodingPages</h3><ul><li><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-deploy-coding2.png" alt=""></p><p>点击Pages服务，然后一键开启。</p></li></ul><p>部署master分支</p><p>自定义域名 可以填两个 <code>www.xxx.com</code> 和<code>xxx.com</code></p><p>绑定自定义域名的时候需要在买域名的地方(我这里是阿里的万网)配置DNS解析</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-coding-dns.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加两条CNAME解析</span><br><span class="line">主机记录</span><br><span class="line">一个@，一个www<span class="comment">//@就是无前缀，xxx.com, www就是www.xxx.com</span></span><br><span class="line">解析路线</span><br><span class="line">默认就行</span><br><span class="line">记录值</span><br><span class="line">lillusory.coding.me <span class="comment">//这里改成自己的</span></span><br></pre></td></tr></table></figure><p>然后可以开启Https访问。</p><p>到这里就可以通过个性域名访问啦。不过现在博客代码还没有<code>push</code>到项目里。</p><h3 id="2-4-Push代码到Coding"><a href="#2-4-Push代码到Coding" class="headerlink" title="2.4 Push代码到Coding"></a>2.4 Push代码到Coding</h3><p><strong>配置SSH key</strong></p><p>首先需要配置一个<code>SSHkey</code>，<code>Git</code>有<code>Http</code>协议和<code>Git</code>协议两种。我们这里使用<code>Git</code>协议就需要配置一个<code>SSH key</code>,等会部署到<code>Github</code>上也需要配置这个。</p><p>具体配置方法如下：</p><p><a href="https://www.lixueduan.com/categories/Git/">Git 配置及SSH key</a></p><p><strong>修改站点配置文件</strong></p><p>这里只配置了Coding，可以先把Github的注释掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Deployment 部署到云端相关配置</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">   github: git<span class="meta">@github</span>.com:illusorycloud/illusorycloud.github.io.git</span><br><span class="line">   coding: git<span class="meta">@git</span>.coding.net:illusorycloud/illusorycloud.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>地址在这里：</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-deploy-coding3.png" alt=""></p><p>配置好后，运行<code>hexo g时就可以把博客部署到Coding上了，也可以通过个性域名访问了。</code></p><h2 id="3-收录到百度"><a href="#3-收录到百度" class="headerlink" title="3. 收录到百度"></a>3. 收录到百度</h2><h3 id="3-1-网站添加"><a href="#3-1-网站添加" class="headerlink" title="3.1 网站添加"></a>3.1 网站添加</h3><p>直接百度搜索你的域名,比如我的<code>www.lixueduan.com</code> ，如果没有收录就会提示暂未收录，点击<code>提交网址</code>。</p><p>点击这个链接进入百度站长平台，登录成功后选择`用户中心–&gt;站点管理–&gt;添加网站</p><p>输入自己的网站，如<code>www.lixueduan.com</code> 协议头如果开启了<code>https</code>就选<code>https</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-baidu1-add.png" alt=""></p><h3 id="3-2-网站验证"><a href="#3-2-网站验证" class="headerlink" title="3.2 网站验证"></a>3.2 网站验证</h3><p>然后会验证这个网站是不是你的，选CNAME验证</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-baidu2-verfication.png" alt=""></p><p>然后去域名哪里添加一条解析即可。</p><p>记录类型–&gt;<code>CNAME</code></p><p>主机记录—&gt;前面那一串<code>l3rUDBLOMX</code></p><p>记录值–&gt;后面那个<code>ziyuan.baidu.com</code></p><p>其他的都按默认的就行了，添加后别删除，需要一直留着。</p><h3 id="3-3-站点地图"><a href="#3-3-站点地图" class="headerlink" title="3.3 站点地图"></a>3.3 站点地图</h3><p>接下来我们需要生成网站地图<code>sitemap</code>,使用sitemap方式向百度提交我们的网址</p><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p><ul><li>先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save  #sitemap.xml适合提交给谷歌搜素引擎</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save  #baidusitemap.xml适合提交百度搜索引擎</span><br></pre></td></tr></table></figure><ul><li>在<code>站点配置文件</code>中添加如下代码</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-baidu-sitemap</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure><p>在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了.</p><p>然后将博客重新部署后就可以直接访问站点地图了。如<code>https://www.lixueduan.com/baidusitemap.xml</code></p><p>然后将这个<code>站点地图</code>提交到百度</p><p><code>站点管理--&gt;站点属性--&gt;链接提交--&gt;自动提交--&gt;sitemap</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-baidu3-sitemap.png" alt=""></p><p>完成后就算是提交成功了，百度比较慢，要好几天才能收录。</p><h2 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4. 部署到GitHub"></a>4. 部署到GitHub</h2><p>步骤和Coding差不多的。</p><h3 id="4-1-注册Github账号"><a href="#4-1-注册Github账号" class="headerlink" title="4.1 注册Github账号"></a>4.1 注册Github账号</h3><p><a href="https://github.com/" target="_blank" rel="noopener">点这里注册Github账号</a></p><h3 id="4-2-创建新仓库"><a href="#4-2-创建新仓库" class="headerlink" title="4.2 创建新仓库"></a>4.2 创建新仓库</h3><p>也是名字必须和用户名一样，必须按照这个格式<code>username.github.io</code>，例如<code>lillusorycloud.github.io</code></p><p>创建好仓库后找到<code>Setings</code> 往下拉，找到<code>Github Pages</code> 设置<code>Custom domain</code>填下自定义域名，如<code>www.lixueduan.com</code>.如果有<code>Enforce HTTPS</code>选项也可以勾上。</p><h3 id="4-3-Push代码到Github"><a href="#4-3-Push代码到Github" class="headerlink" title="4.3 Push代码到Github"></a>4.3 Push代码到Github</h3><p><strong>配置SSH key</strong></p><p>首先需要配置一个<code>SSHkey</code>，<code>Git</code>有<code>Http</code>协议和<code>Git</code>协议两种。我们这里使用<code>Git</code>协议就需要配置一个<code>SSH key</code>,等会部署到<code>Github</code>上也需要配置这个。</p><p>具体配置方法：</p><p><a href="https://www.lixueduan.com/categories/Git/">Git 配置及SSH key</a></p><p><strong>修改站点配置文件</strong></p><p><code>repository</code>中添加一个<code>github</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Deployment 部署到云端相关配置</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">    github: git<span class="meta">@github</span>.com:illusorycloud/illusorycloud.github.io.git</span><br><span class="line">    coding: git<span class="meta">@git</span>.coding.net:illusorycloud/illusorycloud.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>配置好后，运行<code>hexo g时就可以把博客同时部署到Coding和Github上了，也可以通过个性域名访问了。</code></p><h2 id="5-收录到Google"><a href="#5-收录到Google" class="headerlink" title="5. 收录到Google"></a>5. 收录到Google</h2><p>和百度差不多。</p><h3 id="5-1-网站添加"><a href="#5-1-网站添加" class="headerlink" title="5.1 网站添加"></a>5.1 网站添加</h3><p>首先进入<a href="https://www.google.com/webmasters/#?modal_active=none" target="_blank" rel="noopener">Google站点平台</a></p><p>然后添加资源，注意<code>http</code>和<code>https</code></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-add.png" alt=""></p><h3 id="5-2-验证所有权"><a href="#5-2-验证所有权" class="headerlink" title="5.2 验证所有权"></a>5.2 验证所有权</h3><p>然后验证所有权,选择DNS供应商</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-verfication1.png" alt=""></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-verfication2.png" alt=""></p><p>供应商选择其他，然后选择添加CNAME记录，在域名解析中添加一条记录。也是添加后不要删除。</p><h3 id="5-3-站点地图"><a href="#5-3-站点地图" class="headerlink" title="5.3 站点地图"></a>5.3 站点地图</h3><p>验证后就可以添加站点地图了</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/hexo/2018-12-28-google-sitemap.png" alt=""></p><p>提交成功后,我们的站点就已经被Google收录了.大概一天就能收录成功，比百度块一些。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文主要讲了怎么将博客部署到<code>Coding</code>和<code>Github</code>和怎么让<code>百度</code>,<code>Google</code>收录我们的网站。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><p><a href="https://www.jianshu.com/p/cc902b54d493" target="_blank" rel="noopener">基于Hexo的个人博客</a></p><p><a href="https://blog.csdn.net/qq_35561857/article/details/81590953" target="_blank" rel="noopener">Hex博客搭建</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本章主要记录了如何将博客部署至云端，怎么设置个性域名，怎么将自己的网站提交到百度Google。让自己的网站能够出现在各大搜索引擎的具体方法和过程，希望能对大家有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客之优化（二）</title>
    <link href="https://www.lixueduan.com/posts/58273.html"/>
    <id>https://www.lixueduan.com/posts/58273.html</id>
    <published>2018-12-22T14:00:00.000Z</published>
    <updated>2019-01-03T11:32:08.985Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --><p>本章主要包含了博客主题优化相关内容，第三方服务和插件的配置与使用。如：炫酷头像动态背景、链接变色、鼠标点击效果、站点字数、访客数统计等。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><h3 id="0-选择主题"><a href="#0-选择主题" class="headerlink" title="0. 选择主题"></a>0. 选择主题</h3><p>你可以点击这里选择你喜欢的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Themes</a>,里面有大量美观的主题</p><p>我这里用的是简约著称的<code>Next</code>主题.</p><ul><li>下载主题<ul><li>使用<code>git</code>命令下载该主题到本地.</li><li><code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></li><li>clone成功后,你的Themes文件夹下就会有next主题文件了.</li></ul></li><li>Hexo配置文件:<ul><li>都叫<code>_config.yml</code></li><li>一份位于站点根目录下，主要包含 Hexo 本身的配置,称为 <code>站点配置文件</code></li><li>另一份位于主题目录下主要用于配置主题相关的选项,称为<code>主题配置文件</code></li></ul></li><li>开启主题<ul><li><code>站点配置文件</code>进行修改: 将<code>theme: landscape</code>修改为 <code>theme: next</code></li></ul></li></ul><h3 id="1-侧边栏头像设置"><a href="#1-侧边栏头像设置" class="headerlink" title="1. 侧边栏头像设置"></a>1. 侧边栏头像设置</h3><p>新版next注意引入了该功能,直接在<code>主题配置文件</code>修改即可,如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar 头像</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line"><span class="attr">  url:</span> <span class="string">/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># 圆形头像</span></span><br><span class="line"><span class="attr">  rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 透明度 0~1之间</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 头像旋转</span></span><br><span class="line"><span class="attr">  rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-设置个人社交图标链接"><a href="#2-设置个人社交图标链接" class="headerlink" title="2. 设置个人社交图标链接"></a>2. 设置个人社交图标链接</h3><p>直接在<code>主题配置文件</code>修改即可,如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Social Links. 社交链接 前面为链接地址 后面是图标 </span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/illusorycloud</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  E-Mail:</span> <span class="attr">mailto:xueduan.li@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"><span class="comment"># 图标配置 </span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="comment">#是否显示图标</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#是否只显示图标</span></span><br><span class="line"><span class="attr">  icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#是否开启图标变化(就是刷新后会变颜色)</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="3-添加菜单项"><a href="#3-添加菜单项" class="headerlink" title="3. 添加菜单项"></a>3. 添加菜单项</h3><p>1.先在<code>主题配置文件</code>修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  AAAAA:</span> <span class="string">/BBBBB/</span> <span class="string">||</span> <span class="string">CCC</span></span><br><span class="line"><span class="string">其中AAA</span> <span class="string">为菜单项的名字,BBB是路径,CCC是菜单项显示的图标</span></span><br></pre></td></tr></table></figure><p><code>next</code> 使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 提供的图标 ,在这里可以选择自己喜欢的图标.</p><p>2.生成上述路径的文件</p><p><code>git</code>命令行输入</p><p><code>hexo new page BBB</code> –其中BBB替换为具体的名字,会在<code>站点目录\source</code>下新增一个BBB文件夹,文件夹中有一个<code>index.md</code>文件，需要在文件头中增加一句<code>type: XXX</code>,例如<code>type: categories</code>。这样就会在这个页面显示所有的分类了。</p><p>3.修改主题文件下的对应语言的配置文件,这里是中文就修改<code>zh-CN.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">首页</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="string">AAAA</span> <span class="string">:</span> <span class="string">XXXX</span></span><br><span class="line"><span class="string">AAA为上边的菜单项名字,XXX为中文的名字</span></span><br></pre></td></tr></table></figure><h3 id="4-添加RSS"><a href="#4-添加RSS" class="headerlink" title="4. 添加RSS"></a>4. 添加RSS</h3><ul><li><p>1.安装插件</p><ul><li><p>首先在Git中运行<code>npm install --save hexo-generator-feed</code>命令,安装插件,插件会放在</p><p><code>node_modules</code>文件夹里面.</p></li></ul></li><li><p>2.修改<code>站点配置文件</code></p><ul><li>安装好插件后,打开站点配置文件_config.yml`,在末尾加入以下代码:</li></ul></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br></pre></td></tr></table></figure><ul><li>3.修改<code>主题配置文件</code><ul><li>打开主题配置文件<code>_config.yml</code>,找到<code>rss</code> 添加配置:<code>rss: /atom.xml</code></li></ul></li></ul><h3 id="5-设置酷炫动态背景"><a href="#5-设置酷炫动态背景" class="headerlink" title="5. 设置酷炫动态背景"></a>5. 设置酷炫动态背景</h3><p>next主题提供了两种背景可以选择.</p><ul><li>第一种背景（我是用的这种）</li></ul><p>新版本的next主题的话直接在主题配置文件中,找到<code>canvas-nest</code> 修改为<code>canvas-nest: true</code>,</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  onmobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile or not</span></span><br><span class="line"><span class="attr">  color:</span> <span class="string">'0,0,255'</span> <span class="comment"># RGB values, use ',' to separate</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">0.5</span> <span class="comment"># the opacity of line: 0~1</span></span><br><span class="line"><span class="attr">  zIndex:</span> <span class="bullet">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line"><span class="attr">  count:</span> <span class="number">99</span> <span class="comment"># the number of lines</span></span><br></pre></td></tr></table></figure><p>进入theme/next目录</p><p>执行命令<code>git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</code></p><ul><li>第二种背景</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>也是需要下载依赖</p><ol><li>进入theme/next目录</li><li>执行命令：<code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></li></ol><p><strong>4个背景中只能开启一种背景,不然会出错</strong></p><h3 id="6-设置网站logo"><a href="#6-设置网站logo" class="headerlink" title="6. 设置网站logo"></a>6. 设置网站logo</h3><p>把你的图片放在<code>themes/next/source/images</code>里</p><p>打开<code>主题配置文件</code>_config.yml ,找到字段<code>favicon:</code> 都修改为对应路径</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line"><span class="attr">  small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line"><span class="attr">  medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line"><span class="attr">  apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line"><span class="attr">  safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br></pre></td></tr></table></figure><h3 id="7-实现点击出现桃心效果"><a href="#7-实现点击出现桃心效果" class="headerlink" title="7. 实现点击出现桃心效果"></a>7. 实现点击出现桃心效果</h3><p><code>themes/next/source/js/src</code>里面 新建一个love.js,</p><p>复制下面的代码进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>然后打开<code>\themes\next\layout\_layout.swig</code>文件,在末尾 添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-修改文章内链接文本样式"><a href="#8-修改文章内链接文本样式" class="headerlink" title="8. 修改文章内链接文本样式"></a>8. 修改文章内链接文本样式</h3><p>鼠标移动到连接上变颜色</p><p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式，：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-设置顶部滚动加载条"><a href="#9-设置顶部滚动加载条" class="headerlink" title="9. 设置顶部滚动加载条"></a>9. 设置顶部滚动加载条</h3><p>打开<code>next\layout\_partials\head</code>文件，在文件末尾添加以下代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#1E92FB</span>; <span class="comment">/*进度条颜色*/</span></span></span><br><span class="line"><span class="undefined">        height: 3px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress-inner</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#1E92FB</span>, 0 0 5<span class="selector-tag">px</span>     <span class="selector-id">#1E92FB</span>; <span class="comment">/*阴影颜色*/</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-activity</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-top-color</span>: <span class="selector-id">#1E92FB</span>;    <span class="comment">/*上边框颜色*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-left-color</span>: <span class="selector-id">#1E92FB</span>;    <span class="comment">/*左边框颜色*/</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="10-在每篇文章末尾统一添加“本文结束”标记"><a href="#10-在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="10. 在每篇文章末尾统一添加“本文结束”标记"></a>10. 在每篇文章末尾统一添加“本文结束”标记</h3><p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>page-end-tag.swig</code> 文件,并添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文字可以自己修改--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #A2CD5A;font-size:15px;"</span>&gt;</span>------------------本文到此结束<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您的阅读------------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后， <code>post-footer</code> 之前添加下面的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include 'page-end-tag.swig' %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后打开主题配置文件（<code>_config.yml</code>),在末尾添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">page_end_tag:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="11-静态资源压缩"><a href="#11-静态资源压缩" class="headerlink" title="11. 静态资源压缩"></a>11. 静态资源压缩</h3><p>Hexo自动生成的html中有很多空白的地方,会影响加载速度,所以最好还是压缩一下.</p><p>这里使用<code>hexo-neat</code>插件来压缩。</p><ul><li><p>安装插件</p><ul><li><code>npm install hexo-neat --save</code></li></ul></li><li><p>在<code>站点配置文件</code>添加配置</p><ul><li><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line"><span class="comment"># 博文压缩</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩html</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 压缩css  跳过min.css</span></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.css'</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 压缩js 跳过min.js</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  mangle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  output:</span></span><br><span class="line"><span class="attr">  compress:</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.js'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/jquery.fancybox.pack.js'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/index.js'</span>  </span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/love.js'</span></span><br><span class="line"><span class="comment"># 压缩博文配置结束</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.使用</p><ul><li>以后再执行<code>hexo g</code>命令时就会自动压缩了</li></ul></li></ul><h3 id="12-主页文章添加阴影效果"><a href="#12-主页文章添加阴影效果" class="headerlink" title="12. 主页文章添加阴影效果"></a>12. 主页文章添加阴影效果</h3><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: <span class="number">60</span>px;</span><br><span class="line">   margin-bottom: <span class="number">60</span>px;</span><br><span class="line">   padding: <span class="number">25</span>px;</span><br><span class="line">   -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>);</span><br><span class="line">   -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="13-修改文章底部的的标签样式"><a href="#13-修改文章底部的的标签样式" class="headerlink" title="13. 修改文章底部的的标签样式"></a>13. 修改文章底部的的标签样式</h3><p>打开模板文件<code>/themes/next/layout/_macro/post.swig</code>，找到<code>rel=&quot;tag&quot;&gt;#</code>字段， 将<code># 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>,其中tag是你选择标签图标的名字,也是可以自定义的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(tag.path) &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"tag"</span>&gt;</span> <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="14-实现文章字数统计和预计阅读时间"><a href="#14-实现文章字数统计和预计阅读时间" class="headerlink" title="14. 实现文章字数统计和预计阅读时间"></a>14. 实现文章字数统计和预计阅读时间</h3><p>1.在站点根目录下使用<code>GitBash</code>命令安装 <code>hexo-wordcoun</code>t插件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>2.在全局配置文件<code>_config.yml</code>中激活插件:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">    symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>3.在主题的配置文件<code>_config.yml</code>中进行如下配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_total:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><p>到此,我们就实现了文章字数统计和预估时间的显示功能</p><h3 id="15-在文章底部增加版权信息"><a href="#15-在文章底部增加版权信息" class="headerlink" title="15. 在文章底部增加版权信息"></a>15. 在文章底部增加版权信息</h3><p>修改<code>主题配置文件</code>,找到<code>creative_commons</code>字段</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="comment">#选择一个License</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="comment">#是否在侧边栏显示</span></span><br><span class="line"><span class="attr">  sidebar:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="comment">#是否在文章末尾显示</span></span><br><span class="line"><span class="attr">  post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="16-文章置顶"><a href="#16-文章置顶" class="headerlink" title="16. 文章置顶"></a>16. 文章置顶</h3><p>打开文件：<code>node_modules/hexo-generator-index/lib/generator.js</code>,将原来的代码用下面的代码替换掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写文章的时候,在标题加上top值,数值越大排在越前面.</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag: hexo </span><br><span class="line">copyright: true</span><br><span class="line">password: xxx</span><br><span class="line">top: 150</span><br></pre></td></tr></table></figure><h3 id="17-在网站底部加上访问量"><a href="#17-在网站底部加上访问量" class="headerlink" title="17. 在网站底部加上访问量"></a>17. 在网站底部加上访问量</h3><p><strong>Next主题配置这个就比较方便了</strong></p><p>打开<code>主题配置文件</code>，找到如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_views_icon:</span> <span class="string">eye</span></span><br><span class="line"><span class="attr">  post_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure><p>将<code>enable</code>的值由<code>false</code>改为<code>true</code>，便可以看到页脚出现访问量.</p><p>另外本地预览时访客数异常是正常的,部署至云端后就不会出现这样的问题.</p><h3 id="18-网站搜索功能"><a href="#18-网站搜索功能" class="headerlink" title="18. 网站搜索功能"></a>18. 网站搜索功能</h3><p>1.安装插件</p><p>​ 站点目录下执行命令<code>npm install hexo-generator-searchdb --save</code></p><p>2.修改<code>站点配置文件</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>3.修改<code>主题配置文件</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="string">enable</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># unescape html strings to the readable one</span></span><br><span class="line"><span class="attr">  unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>重新开启服务后即可看到效果。</p><h3 id="TODO开启留言评论功能"><a href="#TODO开启留言评论功能" class="headerlink" title="TODO开启留言评论功能"></a>TODO开启留言评论功能</h3><p>//TODO 待更新</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next官方文档</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本章主要包含了博客主题优化相关内容，第三方服务和插件的配置与使用。如：炫酷头像动态背景、链接变色、鼠标点击效果、站点字数、访客数统计等。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客之搭建（一）</title>
    <link href="https://www.lixueduan.com/posts/18973.html"/>
    <id>https://www.lixueduan.com/posts/18973.html</id>
    <published>2018-12-20T14:00:00.000Z</published>
    <updated>2019-01-03T11:30:11.122Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --><p>本文主要记录了如何搭建自己的博客。基于Hexo框架在本地搭建自己博客的全过程，包括了环境准备到Hexo初始化，再到服务的开启等。</p><a id="more"></a><blockquote><p>这是一个基于Hexo的个人博客的教程，包含了从博客搭建到主题优化，最后部署到云端的全过程。</p><p><a href="https://www.lixueduan.com/tags/Hexo/">点击阅读更多系列文章</a></p></blockquote><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><ul><li>Git <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下载地址</a></li><li>Node.js <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js下载地址</a></li></ul><p>小白式安装，一直下一步就ok了。</p><p>都安装好后就可以开始安装Hexo啦.</p><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h2><ul><li>1.新建一个文件夹,用于安装Hexo,以后这个就是放博客文件的.</li><li>2.在此文件夹右键,<code>Git Bash Here</code>,打开Git</li><li>3.安装Hexo 命令<code>npm install -g hexo</code></li><li>4.初始化Hexo 命令<code>hexo init</code></li><li>5.安装组件 命令<code>npm install</code></li></ul><p>到此为止,Hexo就算是安装完成了。</p><h2 id="3-开启服务"><a href="#3-开启服务" class="headerlink" title="3. 开启服务"></a>3. 开启服务</h2><ul><li><p>1.<code>hexo generate</code>或者简写<code>hexo g</code> 编译,生成静态文件,就是生成一个个html文件.</p></li><li><p>2.开启服务<code>hexo server</code>或者<code>hexo s</code> 成功开启后就可以在本地访问了。 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><ul><li>假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，<code>hexo server -p 端口号</code>来改变端口号</li><li>如<code>hexo server -p 5000</code> 将端口号换为<code>5000</code>,默认是<code>4000</code></li></ul></li><li>3.常用命令<ul><li><code>hexo clean</code> 清除缓存文件</li><li><code>hexo deploy</code>或者<code>hexo d</code> 部署网站到云端,这个后面再讲。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 19:35:50 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要记录了如何搭建自己的博客。基于Hexo框架在本地搭建自己博客的全过程，包括了环境准备到Hexo初始化，再到服务的开启等。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://www.lixueduan.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.lixueduan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(五)--从输入URL到页面加载的过程中发生了什么</title>
    <link href="https://www.lixueduan.com/posts/5863.html"/>
    <id>https://www.lixueduan.com/posts/5863.html</id>
    <published>2018-11-15T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.253Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本文主要对用户从浏览器输入URL到页面加载的这一过程进行了具体分析与叙述。包括：<code>DNS解析</code>、<code>发送HTTP请求</code>、<code>TCP连接</code>、<code>服务器响应</code>、<code>浏览器解析渲染页面</code>等。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><p>总体来说分为以下几个过程:</p><ul><li>1.DNS解析</li><li>2.TCP连接</li><li>3.发送HTTP请求</li><li>4.服务器处理请求并返回HTTP报文</li><li>5.浏览器解析渲染页面</li><li>6.连接结束</li></ul><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcpip-http-relation-about.jpg" alt=""></p><h2 id="1-DNS解析"><a href="#1-DNS解析" class="headerlink" title="1. DNS解析"></a>1. DNS解析</h2><p>解析域名，找到主机IP。如百度对应的IP为<code>180.97.33.108</code> ,浏览器输入IP也可以访问到百度。</p><p>（1）浏览器会缓存DNS一段时间，一般2-30分钟不等。如果有缓存，直接返回IP，否则下一步。</p><p>（2）缓存中无法找到IP，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回IP，否则下一步。（在计算机本地目录etc下有一个hosts文件，hosts文件中保存有域名与IP的对应解析，通常也可以修改hosts科学上网或破解软件。）</p><p>（3）进行了（1）（2）本地查询无果，只能借助于网络。路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这时一般都能够得到相应的IP。如果还是无果，只能借助于DNS递归解析了。</p><p>（4）这时，ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com顶级域名服务器，到baidu的域名服务器。</p><p>到这里，浏览器就获得了IP。在DNS解析过程中，常常会解析出不同的IP。比如，电信的是一个IP，网通的是另一个IP。这是采取了智能DNS的结果，降低运营商间访问延时，在多个运营商设置主机房，就近访问主机。电信用户返回电信主机IP，网通用户返回网通主机IP。当然，劫持DNS，也可以屏蔽掉一部分网点的访问，某防火长城也加入了这一特性。</p><h2 id="2-TCP连接"><a href="#2-TCP连接" class="headerlink" title="2. TCP连接"></a>2. TCP连接</h2><p>浏览器与网站建立TCP连接</p><p>浏览器利用IP直接与网站主机通信。浏览器发出TCP（SYN标志位为1）连接请求，主机返回TCP（SYN，ACK标志位均为1）应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认。浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP链接建立完成。</p><h2 id="3-发送HTTP请求"><a href="#3-发送HTTP请求" class="headerlink" title="3. 发送HTTP请求"></a>3. 发送HTTP请求</h2><p>浏览器发起HTTP请求</p><p>其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: <strong>请求行</strong>, <strong>请求报头</strong>和<strong>请求正文</strong>。</p><p><strong>请求行</strong></p><p>请求行包括：请求方法，URL ， 协议版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求行：请求方法    URL    协议版本</span><br><span class="line">    eg:GET   index.html HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><p><strong>请求报头</strong></p><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br>常见的请求报头有: <code>Accept</code>,<code>Accept-Charset</code>,<code>Accept-Encoding</code>,<code>Accept-Language,</code> <code>Content-Type</code>, <code>Authorization</code>, <code>Cookie</code>, <code>User-Agent</code>等。</p><p><strong>请求正文</strong></p><p>当使用<code>POST</code>, <code>PUT</code>等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置<code>Content-Type: application/json</code></p><p>浏览器向主机发起一个HTTP请求。请求中包含访问的URL，也就是<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a> ，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。</p><h2 id="4-服务器响应"><a href="#4-服务器响应" class="headerlink" title="4. 服务器响应"></a>4. 服务器响应</h2><p>服务器对请求做出响应并返回HTTP响应报文。自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，例如Tomcat。</p><p>HTTP响应报文也是由三部分组成: <strong>响应行</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p><p><strong>响应行</strong></p><p>响应行包括：协议版本 状态码 状态码描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应行包括：协议版本   状态码 状态码描述</span><br><span class="line">    eg:  HTTP/<span class="number">1.1</span>  <span class="number">200</span>    OK</span><br></pre></td></tr></table></figure><p><strong>响应报头</strong></p><p>常见的响应报头字段有: Server, Connection…。</p><p><strong>响应报文</strong></p><p>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。</p><h2 id="5-浏览器解析渲染页面"><a href="#5-浏览器解析渲染页面" class="headerlink" title="5. 浏览器解析渲染页面"></a>5. 浏览器解析渲染页面</h2><p>返回状态码200 OK，表示服务器可以相应请求，返回报文，由于在报头中<code>Content-type:“text/html”</code>，浏览器以HTML形式呈现，而不是下载文件。</p><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的?</p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p><p><strong>重定向 负载均衡</strong></p><p>但是，对于大型网站存在多个主机站点，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200 OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。</p><p>补充一点的就是，重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于<a href="lixueduan.com">lixueduan.com</a>，<a href="www.lixueduan.com">www.lixueduan.com</a>会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。</p><h2 id="6-连接结束"><a href="#6-连接结束" class="headerlink" title="6. 连接结束"></a>6. 连接结束</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><h2 id="7-计算机网络常见问题"><a href="#7-计算机网络常见问题" class="headerlink" title="7. 计算机网络常见问题"></a>7. 计算机网络常见问题</h2><p>看完系列文章，下面这些问题应该也不是问题了。</p><ul><li>1.TCP三次握手和四次挥手</li><li>2.在浏览器中输入url地址-&gt;&gt;显示主页的过程</li><li>3.HTTP和HTTPS的区别</li><li>4.TCP、UDP协议的区别</li><li>5.常见的状态码。</li></ul><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h2><p><code>https://segmentfault.com/a/1190000006879700</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要对用户从浏览器输入URL到页面加载的这一过程进行了具体分析与叙述。包括：&lt;code&gt;DNS解析&lt;/code&gt;、&lt;code&gt;发送HTTP请求&lt;/code&gt;、&lt;code&gt;TCP连接&lt;/code&gt;、&lt;code&gt;服务器响应&lt;/code&gt;、&lt;code&gt;浏览器解析渲染页面&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(四)--HTTP与HTTPS</title>
    <link href="https://www.lixueduan.com/posts/21307.html"/>
    <id>https://www.lixueduan.com/posts/21307.html</id>
    <published>2018-11-12T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本文主要介绍了<code>HTTP</code>、<code>HTTPS</code>的基本概念及两者的区别，<code>HTTPS</code>的工作原理及优缺点，最后介绍了HTTP的响应状态码。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h2 id="1-HTTP和HTTPS基本概念"><a href="#1-HTTP和HTTPS基本概念" class="headerlink" title="1. HTTP和HTTPS基本概念"></a>1. HTTP和HTTPS基本概念</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以<strong>安全</strong>为目标的HTTP通道，简单讲是<strong>HTTP的安全版</strong>，即HTTP下加入<strong>SSL层</strong>，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP--&gt; HTTP--&gt;TCP--&gt;IP</span><br><span class="line">HTTPS-&gt; HTTP--&gt;SSL--&gt;TCP--&gt;IP</span><br></pre></td></tr></table></figure><p>HTTPS协议的<strong>主要作用</strong>：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="2-HTTP与HTTPS的区别"><a href="#2-HTTP与HTTPS的区别" class="headerlink" title="2. HTTP与HTTPS的区别"></a>2. HTTP与HTTPS的区别</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用<strong>HTTP协议传输隐私信息非常不安全</strong>，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，<strong>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全</strong>。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/https-key-lvalue.jpg" alt=""></p><p><strong>HTTPS和HTTP的区别:</strong></p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="3-HTTPS工作原理"><a href="#3-HTTPS工作原理" class="headerlink" title="3. HTTPS工作原理"></a>3. HTTPS工作原理</h2><p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p><strong>SSL协议的握手过程</strong></p><p>分为五个步骤:</p><p>第一步，客户端给出SSL协议版本号、一个客户端生成的随机数1（Client random），以及客户端支持的加密方法。</p><p>第二步，服务端根据客服端支持的加密方法选出双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数2（Server random）。</p><p>第三步，客户端确认数字证书有效，然后生成一个新的随机数3（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。</p><p>第四步，服务端使用自己的私钥，获取客户端发来的随机数3（即Premaster secret）。到这里双方都拥有三个随机数了，为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。</p><p>第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</p><p>第六步，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。</p><p>第七步，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p><p>到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/https-ssl-connection.png" alt="https握手过程"></p><h2 id="4-HTTPS的优缺点"><a href="#4-HTTPS的优缺点" class="headerlink" title="4. HTTPS的优缺点"></a>4. HTTPS的优缺点</h2><p><strong>优点:</strong></p><p>（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”</p><p><strong>缺点:</strong></p><p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h2 id="5-HTTP响应状态码"><a href="#5-HTTP响应状态码" class="headerlink" title="5. HTTP响应状态码"></a>5. HTTP响应状态码</h2><p>状态码以3位数字和原因短语组成，例如 200 OK 。</p><p>数字的第一位指定了响应类型，后两位无分类。响应类别一共有5种：</p><ul><li>1XX Informational(信息性状态码)</li><li>2XX Success(成功状态码)</li><li>3XX Redirection(重定向状态码)</li><li>4XX Client Error(客户端错误状态码)</li><li>5XX Server Error(服务器错误状态码)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span>：请求成功      处理方式：获得响应的内容，进行处理 </span><br><span class="line"></span><br><span class="line"><span class="number">201</span>：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到 </span><br><span class="line"></span><br><span class="line"><span class="number">202</span>：请求被接受，但处理尚未完成    处理方式：阻塞等待 </span><br><span class="line"></span><br><span class="line"><span class="number">204</span>：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃</span><br><span class="line"></span><br><span class="line"><span class="number">300</span>：该状态码不被HTTP/<span class="number">1.0</span>的应用程序直接使用， 只是作为<span class="number">3</span>XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃</span><br><span class="line"><span class="number">301</span>：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL</span><br><span class="line"><span class="number">302</span>：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL </span><br><span class="line"></span><br><span class="line"><span class="number">304</span> 请求的资源未更新     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">400</span> 非法请求     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">401</span> 未授权     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">403</span> 禁止     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">404</span> 没有找到     处理方式：丢弃 </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>XX 回应代码以“<span class="number">5</span>”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求    处理方式：丢弃</span><br></pre></td></tr></table></figure><h2 id="6-HTTP长连接、短连接"><a href="#6-HTTP长连接、短连接" class="headerlink" title="6. HTTP长连接、短连接"></a>6. HTTP长连接、短连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p><strong>https加密是在传输层</strong></p><p>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的<strong>header域</strong>也好，body域也罢都是会被加密的。</p><p>当使用<strong>tcpdump或者wireshark</strong>之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用<strong>Charels(Mac)、Fildder(Windows)</strong>抓包工具，那当然看到是明文的。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><code>https://www.cnblogs.com/qiangxia/p/5261813.html</code></p><p><code>https://www.cnblogs.com/wqhwe/p/5407468.html</code></p><p><code>http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍了&lt;code&gt;HTTP&lt;/code&gt;、&lt;code&gt;HTTPS&lt;/code&gt;的基本概念及两者的区别，&lt;code&gt;HTTPS&lt;/code&gt;的工作原理及优缺点，最后介绍了HTTP的响应状态码。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.lixueduan.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(三)--TCP如何保证传输可靠性</title>
    <link href="https://www.lixueduan.com/posts/18422.html"/>
    <id>https://www.lixueduan.com/posts/18422.html</id>
    <published>2018-11-08T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.257Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本文主要叙述了TCP协议是如何保证传输的可靠性的，主要保证手段包括：<code>序列号</code>、<code>校验和</code></p><p>、<code>流量控制</code>、<code>拥塞控制</code>、<code>停止等待协议</code>、<code>超时重传</code>、<code>连接管理</code>等。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h2 id="1-主要保证方式"><a href="#1-主要保证方式" class="headerlink" title="1. 主要保证方式"></a>1. 主要保证方式</h2><ol><li><strong>序列号:</strong>应用数据被分割成 TCP 认为最适合发送的数据块,同时给每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>停止等待协议(确认应答)</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li><strong>连接管理:</strong> 三次握手四次挥手,保证可靠的连接，是保证可靠性的前提。</li></ol><h2 id="2-停止等待协议"><a href="#2-停止等待协议" class="headerlink" title="2. 停止等待协议"></a>2. 停止等待协议</h2><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><p><strong>1) 无差错情况:</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-normal.jpg" alt="normal"></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong> [<img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-tiemout.jpg" alt="timeout"></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong>：当确认消息在传输过程丢失 <img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-lost.jpg" alt="lost">A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：<ol><li>丢弃这个重复的M1消息，不向上层交付。</li><li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li></ol></li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到 [<img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-send-late.jpg" alt="late">A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：<ol><li>A收到重复的确认后，直接丢弃。</li><li>B收到重复的M1后，也直接丢弃重复的M1。</li></ol></li></ul><h2 id="3-ARQ协议"><a href="#3-ARQ协议" class="headerlink" title="3. ARQ协议"></a>3. ARQ协议</h2><p>即自动重传请求 ARQ 协议(Automatic Repeat reQuest )，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。</p><p><strong>优点：</strong> 简单</p><p><strong>缺点：</strong> 信道利用率低</p><h2 id="4-连续ARQ协议"><a href="#4-连续ARQ协议" class="headerlink" title="4. 连续ARQ协议"></a>4. 连续ARQ协议</h2><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h2 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5. 流量控制"></a>5. 流量控制</h2><ul><li>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</li><li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</li><li><strong>TCP 利用滑动窗口实现流量控制的机制。</strong></li><li><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></li><li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</li></ul><h2 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h2><p><strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</strong></p><p>拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降</p><p>拥塞控制所要做的都有一个<strong>前提：网络能够承受现有的网络负荷。</strong>拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p><p>几种拥塞控制方法</p><p>​ 慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><p><strong>慢开始和拥塞避免</strong></p><p>​ 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p><p>​ 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p><strong>慢开始算法：</strong>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p><strong>拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p><strong>快重传与快恢复</strong></p><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><code>https://blog.csdn.net/liuchenxia8/article/details/80428157</code></p><p><code>https://blog.csdn.net/yangbodong22011/article/details/48473183</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要叙述了TCP协议是如何保证传输的可靠性的，主要保证手段包括：&lt;code&gt;序列号&lt;/code&gt;、&lt;code&gt;校验和&lt;/code&gt;&lt;/p&gt;&lt;p&gt;、&lt;code&gt;流量控制&lt;/code&gt;、&lt;code&gt;拥塞控制&lt;/code&gt;、&lt;code&gt;停止等待协议&lt;/code&gt;、&lt;code&gt;超时重传&lt;/code&gt;、&lt;code&gt;连接管理&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://www.lixueduan.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(二)--TCP三次握手四次挥手</title>
    <link href="https://www.lixueduan.com/posts/25338.html"/>
    <id>https://www.lixueduan.com/posts/25338.html</id>
    <published>2018-11-05T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.260Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本文主要介绍了<code>TCP/IP</code>的三次握手和四次挥手具体步骤及其原因分析。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h3 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h3><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-connection-three.jpg" alt=""></p><p><code>step1:第一次握手</code><br>建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入<strong>SYN_SENT</strong>状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。</p><p><code>step2:第二次握手</code><br>服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入<strong>SYN_RCVD</strong>状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。</p><p><code>step3:第三次握手</code></p><p>客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入<strong>ESTABLISHED </strong>(TCP连接成功)**状态，完成三次握手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">建立连接前要确认客户端和服务端的接收和发送功能是否正常。</span><br><span class="line">第一次客户端发送SYN时 什么也确认不了</span><br><span class="line">第二次服务端发送SYN+ACK 可以确认服务端发送功能正常</span><br><span class="line">第三次 客户端收到服务端发送的YSN+ACK 可以确认客户端发送接收功能正常</span><br><span class="line">最后客户端发送ACK 服务端接收到后 可以确认服务端发送功能正常</span><br><span class="line">到此就确认完毕了。</span><br></pre></td></tr></table></figure><h3 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h3><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-close-connection-four.jpg" alt=""></p><p><code>step1：第一次挥手</code><br>首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。 <strong>客户端</strong>进入<strong>FIN_WAIT1</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我（Client端）没有数据要发给你（Server端）了&quot;，但是如果你（Server端）还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK</span><br></pre></td></tr></table></figure><p><code>step2：第二次挥手</code><br><strong>服务器</strong>收到这个FIN进入<strong>CLOSE_WAIT</strong>状态，然后它给客户端发送一个ACK，确认ack为收到的序号加一。</p><p><strong>客户端</strong>收到ACK应答后进入<strong>FIN_WAIT2</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">告诉Client端，你的请求我收到了，但是我（Server端）还没准备好，请继续你等我的消息&quot;</span><br></pre></td></tr></table></figure><p><code>step3：第三次挥手</code><br>服务端关闭服务器到客户端的连接，发送一个FIN给客户端。<strong>服务端</strong>进入<strong>LAST_ACK</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">告诉Client端，好了，我（Server端）这边数据发完了，准备好关闭连接了</span><br></pre></td></tr></table></figure><p><code>step4：第四次挥手</code></p><p><strong>客户端</strong>收到FIN后，进入<strong>TIME_WAIT</strong>状态 并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。</p><p>服务端收到客户端回复的ACK后立即关闭，服务端进入<strong>CLOASED</strong>状态</p><p>而客户端要等待2MSL后关闭 进入<strong>CLOASED</strong>状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client端收到FIN报文后，&quot;就知道可以关闭连接了，所以发送ACK。但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后没有立即，而是进入TIME_WAIT状态，如果Server端没有收到ACK那么自己还可以重传。Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</span><br></pre></td></tr></table></figure><h3 id="3-TIME-WAIT状态详解"><a href="#3-TIME-WAIT状态详解" class="headerlink" title="3. TIME-WAIT状态详解"></a>3. TIME-WAIT状态详解</h3><p>为什么Client端要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？</p><p><strong>保证TCP协议的全双工连接能够可靠关闭，保证这次连接的重复数据段从网络中消失</strong></p><p>假设由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，Client端在等待2MSL时间后都没收到信息，说明Server端已经收到自己发送的ACK并且成功关闭了。<br><strong>假设CLient端直接关闭了：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待<span class="number">2</span>倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</span><br></pre></td></tr></table></figure><p><strong>2MSL:Maximum Segment Lifetime 即数据在网络中保存的最大时间。</strong></p><p><em>简单易懂的说法:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</span><br></pre></td></tr></table></figure><h3 id="4-TCP-的有限状态机"><a href="#4-TCP-的有限状态机" class="headerlink" title="4. TCP 的有限状态机"></a>4. TCP 的有限状态机</h3><p>红色为客户端 蓝色为服务端 细箭头为异常变化</p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-status-map.png" alt="TCP"></p><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><code>https://www.baidu.com/link?url=_mlor11BLttd1jmMU4k9OP0gqcjNKhZQ9fJuvbMOhkuH9-lVeB-y3VIVK1neZURi_tmR3rg1lj2lfgvvGhTV-q&amp;wd=&amp;eqid=d0144c250007b69c000000035bfdfafc</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍了&lt;code&gt;TCP/IP&lt;/code&gt;的三次握手和四次挥手具体步骤及其原因分析。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://www.lixueduan.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(一)--OSI七层模型</title>
    <link href="https://www.lixueduan.com/posts/25470.html"/>
    <id>https://www.lixueduan.com/posts/25470.html</id>
    <published>2018-11-03T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.240Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本文主要通过OSI七层模型与常用TCP/IP5层模型介绍了各层的主要作用，包括<code>应用层</code>，<code>运输层</code>，<code>网络层</code>，<code>数据链路层</code>，<code>物理层</code>等。</p><a id="more"></a><blockquote><p>计算机网络系列文章</p><ul><li><a href="https://www.lixueduan.com/computer-network/one-network-model/">计算机网络(一)–OSI七层模型</a></li><li><a href="https://www.lixueduan.com/computer-network/two-tcp-connection/">计算机网络(二)–TCP三次握手四次挥手</a></li><li><a href="https://www.lixueduan.com/computer-network/three-tcp-reliability/">计算机网络(三)–TCP如何保证传输可靠性</a></li><li><a href="https://www.lixueduan.com/computer-network/four-http-https/">计算机网络(四)–HTTP与HTTPS</a></li><li><a href="计算机网络(五">计算机网络(五)–从输入URL到页面加载的过程中发生了什么</a>–从输入URL到页面加载的过程中发生了什么)</li></ul></blockquote><h2 id="OSI与TCP-IP模型"><a href="#OSI与TCP-IP模型" class="headerlink" title="OSI与TCP/IP模型"></a>OSI与TCP/IP模型</h2><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/osi-tcp-ip-model.png" alt="Model"></p><p><strong><code>应用层:</code>通过应用进程间的交互来完成特定网络应用。</strong></p><p><strong><code>运输层：</code>向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。</strong></p><p><strong><code>网络层：</code>通过路由算法，为报文或分组通过通信子网选择最适当的路径。</strong></p><p><strong><code>数据链路层：</code>其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</strong></p><p><strong><code>物理层：</code>利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。</strong></p><p><img src="https://github.com/illusorycloud/illusorycloud.github.io/raw/hexo/myImages/network/tcp-ip-model.gif" alt=""></p><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><p><strong>主要作用:通过应用进程间的交互来完成特定网络应用。</strong></p><p><strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><h3 id="2-运输层"><a href="#2-运输层" class="headerlink" title="2. 运输层"></a>2. 运输层</h3><p><strong>主要任务：向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。</strong></p><p><strong>主要作用</strong>：向高层屏蔽下层数据通信的具体细节，即向用户透明的传送报文。</p><p>主要用到的协议：</p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h4 id="2-1-UDP"><a href="#2-1-UDP" class="headerlink" title="2.1 UDP"></a>2.1 UDP</h4><ol><li>UDP 是无连接的；</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li><li>UDP 是面向报文的；</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li><li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ol><h4 id="2-2-TCP"><a href="#2-2-TCP" class="headerlink" title="2.2 TCP"></a>2.2 TCP</h4><ol><li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li><li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ol><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><p><strong>主要任务：通过路由算法，为报文或分组通过通信子网选择最适当的路径。</strong>该层控制数据链路层与物理层之间的信息转发，建立、维持与终止网络的连接。具体的说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p><p><strong>一般的，数据链路层是解决统一网络内节点之间的通信，而网络层主要解决不同子网之间的通信。例如路由选择问题。</strong></p><p>在实现网络层功能时，需要解决的主要问题如下：</p><p><strong>寻址</strong>：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一 个唯一的地址。由于各个子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）</p><p><strong>交换：</strong>规定不同的交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者包括报文转发技术和分组转发技术。<br><strong>路由算法：</strong>当源节点和路由节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径，由发送端传送的接受端。<br><strong>连接服务：</strong>与数据链路层的流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测</p><h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h3><p><strong>其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</strong></p><p><strong>主要功能</strong>：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p><p><strong>具体工作</strong>：接受来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上一层的数据帧，拆装为位流形式的数据转发到物理层；并且还负责处理接受端发回的确认帧的信息，以便提供可靠的数据传输。</p><p>该层通常又被分为 介质访问控制(MAC)和逻辑链路控制(LLC)两个子层：<br><strong>MAC子层</strong>的主要任务是<strong>解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制。</strong><br><strong>LLC子层</strong>的主要任务是<strong>建立和维护网络连接，执行差错校验、流量控制和链路控制。</strong></p><h3 id="5-物理层"><a href="#5-物理层" class="headerlink" title="5. 物理层"></a>5. 物理层</h3><p><strong>主要功能：利用传输介质为数据链路层提供屋里连接，实现比特流的透明传输。</strong></p><p><strong>作用</strong>：实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质与物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p><p><strong>透明传输的意义就是：不管传的是什么，所采用的设备只是起一个通道作用，把要传输的内容完好的传到对方！</strong></p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><h3 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h3><p><code>https://blog.csdn.net/yaopeng_2005/article/details/7064869</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要通过OSI七层模型与常用TCP/IP5层模型介绍了各层的主要作用，包括&lt;code&gt;应用层&lt;/code&gt;，&lt;code&gt;运输层&lt;/code&gt;，&lt;code&gt;网络层&lt;/code&gt;，&lt;code&gt;数据链路层&lt;/code&gt;，&lt;code&gt;物理层&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.lixueduan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://www.lixueduan.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（三）--建造者模式</title>
    <link href="https://www.lixueduan.com/posts/52453.html"/>
    <id>https://www.lixueduan.com/posts/52453.html</id>
    <published>2018-10-12T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.243Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本文主要介绍了Java23种设计模式中的<code>建造者模式</code>，并结合实例描述了建造者模式的具体实现和优缺点及建造者模式和工厂模式的差别分析等。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-建造者模式介绍"><a href="#1-建造者模式介绍" class="headerlink" title="1. 建造者模式介绍"></a>1. 建造者模式介绍</h2><blockquote><p>建造者模式是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。。</p></blockquote><p>建造者模式通常包括下面几个角色：</p><p>（1） <code>Builder</code>：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。</p><p>（2） <code>ConcreteBuilder</code>：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。</p><p>（3）<code>Director</code>：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p><p>（4）<code>Product</code>：要创建的复杂对象</p><h2 id="2-建造者模式实例"><a href="#2-建造者模式实例" class="headerlink" title="2. 建造者模式实例"></a>2. 建造者模式实例</h2><p>以创建一个Person为例：</p><p>Product（要创建的对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个Person对象，简单的一些属性和get，set方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder（给出一个抽象接口，以规范产品对象的各个组成成分的建造 ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//然后创建一个接口 建造对象的标准</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">builderName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">builderAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">builderAge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">builderPerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteBuilder（实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接着创建一个构造具体对象的类，实现前面的标准（接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildMe</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法创建一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuildMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后为对象添加各种属性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setName(<span class="string">"lillusory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAddress(<span class="string">"重庆"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAge(<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后返回该对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">builderPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里可以根据不同的逻辑或需求，实现不同的（产品）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildZhangSan</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuildZhangSan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setName(<span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAddress(<span class="string">"北京"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setAge(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">builderPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director（调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建 ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最后创建一个Director指导者？类来创建对象</span></span><br><span class="line"><span class="comment">//只负责保证对象各部分完整创建 不知道具体细节</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">construcPerson</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.builderName();</span><br><span class="line">        builder.builderAddress();</span><br><span class="line">        builder.builderAge();</span><br><span class="line">        <span class="keyword">return</span> builder.builderPerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        Person person = director.construcPerson(<span class="keyword">new</span> BuildMe());</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">        System.out.println(person.getAddress());</span><br><span class="line">        System.out.println(person.getAge());</span><br><span class="line"></span><br><span class="line">        cPerson zhangSan = director.construcPerson(<span class="keyword">new</span> BuildZhangSan());</span><br><span class="line">        System.out.println(zhangSan.getName());</span><br><span class="line">        System.out.println(zhangSan.getAddress());</span><br><span class="line">        System.out.println(zhangSan.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">        lillusory</span><br><span class="line">        重庆</span><br><span class="line">        <span class="number">22</span></span><br><span class="line">        张三</span><br><span class="line">        北京</span><br><span class="line">        <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>建造者模式优点：</strong></p><p>1.将对象本身与对象的创建过程解耦，使得相同的创建过程可以创建不同的对象。</p><p>2.可以更加精细地控制产品的创建过程</p><p>3.增加新的具体建造者无须修改原有类库的代码，符合开闭原则</p><p><strong>与工厂模式的区别：</strong></p><p>工厂模式注重的是整体对象的创建方法，只为了获取对象，关注整体</p><p>建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象，关注细节。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍了Java23种设计模式中的&lt;code&gt;建造者模式&lt;/code&gt;，并结合实例描述了建造者模式的具体实现和优缺点及建造者模式和工厂模式的差别分析等。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（二）--工厂模式</title>
    <link href="https://www.lixueduan.com/posts/34710.html"/>
    <id>https://www.lixueduan.com/posts/34710.html</id>
    <published>2018-10-10T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.246Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本章主要介绍了设计模式中的工厂模式，并结合实例描述了工厂模式的具体实现和使用场景。包括：<code>普通工厂模式</code>、<code>工厂方法模式</code>、<code>抽象工厂模式</code>等。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-工厂模式介绍"><a href="#1-工厂模式介绍" class="headerlink" title="1. 工厂模式介绍"></a>1. 工厂模式介绍</h2><p>工厂模式可以分为普通工厂模、工厂方法模式和抽象工厂模式。</p><p><strong>简单工厂模式：</strong>建立一个工厂类，根据传入的参数对实现了同一接口的一些类进行实例的创建。</p><p><strong>工厂方法模式：</strong>是对普通工厂方法模式的改进，提供多个工厂方法，分别创建对象。</p><p><strong>抽象工厂模式：</strong>创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p><p><strong>工厂模式优点：</strong></p><p>(1) <code>解耦</code>：把对象的创建和使用的过程分开</p><p>(2)<code>减少重复代码</code>: 若创建对象的过程很复杂，有一定的代码量，且很多地方都要用到，那么就会有很多重复代码。</p><p>(3) <code>降低维护成本</code> ：创建过程都由工厂统一管理，发生业务逻辑变化，只需要在工厂里修改即可。</p><p><strong>适用场景</strong></p><p>（1）需要创建的对象较少。</p><p>（2）客户端不关心对象的创建过程。</p><h2 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//水果工厂 根据不同参数创建不同的水果对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">creatFruit</span><span class="params">(String fruit)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (fruit.equals(<span class="string">"Apple"</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fruit.equals(<span class="string">"Orange"</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Orange();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"error unknow fruit ~"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fruit apple = FruitFactory.creatFruit(<span class="string">"Apple"</span>);</span><br><span class="line">        apple.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象水果工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Fruit <span class="title">creatFruit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//苹果工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">creatFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//橘子工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">implements</span> <span class="title">FrutiFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">creatFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Orange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AppleFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        Fruit apple = appleFactory.creatFruit();</span><br><span class="line">        apple.eat();</span><br><span class="line">        OrangeFactory orangeFactory = <span class="keyword">new</span> OrangeFactory();</span><br><span class="line">        Fruit orange = orangeFactory.creatFruit();</span><br><span class="line">        orange.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4. 抽象工厂模式"></a>4. 抽象工厂模式</h2><blockquote><p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个接口 Fruit Juice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Juice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//四个对象 苹果 橘子 苹果汁 橘子汁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleJuice</span> <span class="keyword">implements</span> <span class="title">Juice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AppleJuice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeJuice</span> <span class="keyword">implements</span> <span class="title">Juice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrangeJuice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂 生产水果和果汁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">     <span class="function">Fruit <span class="title">creatFruit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function">Juice <span class="title">creatJuice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂 生产苹果相关产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">creatFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Juice <span class="title">creatJuice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppleJuice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂 生产橘子相关产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">creatFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Orange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Juice <span class="title">creatJuice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrangeJuice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AppleFactory appleFactory=<span class="keyword">new</span> AppleFactory();</span><br><span class="line">        Fruit apple =  appleFactory.creatFruit();</span><br><span class="line">        Juice appleJuice=  appleFactory.creatJuice();</span><br><span class="line">        apple.eat();</span><br><span class="line">        appleJuice.drink();</span><br><span class="line">        OrangeFactory orangeFactory=<span class="keyword">new</span> OrangeFactory();</span><br><span class="line">        Fruit orange=  orangeFactory.creatFruit();</span><br><span class="line">        Juice orangeJuice=  orangeFactory.creatJuice();</span><br><span class="line">        orange.eat();</span><br><span class="line">        orangeJuice.drink();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><strong>工厂模式的优点？为什么要使用工厂模式</strong></p><ul><li>工厂都是用来封装对象的具体创建过程，减少重复代码，降低对象变化时的维护成本，将对象创建过程和使用相解耦。</li><li>工厂方法模式使用继承，抽象工厂使用对象组合；两者利用抽象的原则，将具体的实例化过程延迟到子类。</li><li>工厂利用的最重要和基本的原则——依赖抽象，不要依赖具体类。</li></ul><p><strong>应用场景</strong></p><p>简单工厂：适合创建同一级别的不同对象。</p><p>工厂方法：为每种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品。</p><p>抽象工厂模式：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><p><code>https://blog.csdn.net/d1562901685/article/details/77623237</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本章主要介绍了设计模式中的工厂模式，并结合实例描述了工厂模式的具体实现和使用场景。包括：&lt;code&gt;普通工厂模式&lt;/code&gt;、&lt;code&gt;工厂方法模式&lt;/code&gt;、&lt;code&gt;抽象工厂模式&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（一）--单例模式</title>
    <link href="https://www.lixueduan.com/posts/53093.html"/>
    <id>https://www.lixueduan.com/posts/53093.html</id>
    <published>2018-10-08T14:00:00.000Z</published>
    <updated>2019-01-03T10:29:16.263Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --><p>本文主要介绍了设计模式的六大原则，并结合实例描述了各种单例模式的具体实现和性能分析测试。包括：<code>饿汉式</code>、<code>静态内部类</code>、<code>懒汉式</code>、<code>双重校验锁</code>、<code>枚举</code>等。</p><a id="more"></a><blockquote><p>设计模式系列文章</p><p><a href="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java23种设计模式</a></p></blockquote><h2 id="1-设计模式的六大原则"><a href="#1-设计模式的六大原则" class="headerlink" title="1. 设计模式的六大原则"></a>1. 设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><blockquote><p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p></blockquote><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><blockquote><p>其官方描述比较抽象，可自行百度。实际上可以这样理解：</p><p>（1）子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。</p><p>（2）返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。</p><p>（3）还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。而不能声明抛出父类没有声明的异常。</p></blockquote><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><blockquote><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。</p></blockquote><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><blockquote><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p></blockquote><p><strong>5、迪米特法则（最少知道原则）（Demeter Principle）</strong></p><blockquote><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></blockquote><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><blockquote><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p></blockquote><p>Java 中一般认为有 23 种设计模式，总体来说设计模式分为三大类：</p><p><code>创建型模式</code>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p><code>结构型模式</code>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><code>行为型模式</code>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录</p><p>模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>比较常用的有：工厂方法模式、抽象工厂模式、单例模式、建造者模式、适配器模式、代理模式、享元模式、策略模式、观察者模式。</p><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h2><h3 id="2-1-单利模式介绍"><a href="#2-1-单利模式介绍" class="headerlink" title="2.1 单利模式介绍"></a>2.1 单利模式介绍</h3><p><strong>作用：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 2、避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>应用场景：</strong> 1.配置文件访问类，不用每次使用时都new一个 2.数据库连接池 保证项目中只有一个连接池存在。</p><h3 id="2-2-单利模式实现"><a href="#2-2-单利模式实现" class="headerlink" title="2.2 单利模式实现"></a>2.2 单利模式实现</h3><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//类变量在类准备阶段就初始化了然后放在&lt;clinit&gt;构造方法中</span></span><br><span class="line">    <span class="comment">//一旦外部调用了静态方法，那么就会初始化完成。</span></span><br><span class="line">    <span class="comment">//一个类的&lt;clinit&gt;只会执行一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   　　 <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式实现的单例：类加载时就创建实例。由<code>classloder</code>保证了线程安全。</p><h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    　　<span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式实现的单例：实现了<code>lazy loading</code> 使用时才创建实例，由<code>classloder</code>保证了线程安全。</p><p><strong>饿汉式/静态内部类是如何保证线程安全的：</strong></p><p>在《深入理解JAVA虚拟机》中，有这么一句话:</p><blockquote><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p></blockquote><h4 id="3-懒汉式"><a href="#3-懒汉式" class="headerlink" title="3. 懒汉式"></a>3. 懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">   　　 <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式实现的单例：实现了<code>lazy loading</code> 使用时才创建实例。<code>synchronized</code>保证了线程安全，但效率低。</p><h4 id="4-双重校验锁"><a href="#4-双重校验锁" class="headerlink" title="4. 双重校验锁"></a>4. 双重校验锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();<span class="comment">//非原子操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//singleton = new Singleton(); 非原子操作 分为三步</span></span><br><span class="line"><span class="comment">// 1.给singleton分配内存</span></span><br><span class="line"><span class="comment">// 2.调用 Singleton 的构造函数来初始化成员变量</span></span><br><span class="line"><span class="comment">// 3.将给singleton对象指向分配的内存空间（此时singleton才不为null）</span></span><br><span class="line"><span class="comment">// 指令重排序--&gt;执行命令时虚拟机可能会对以上3个步骤交换位置 最后可能是132这种 分配内存并修改指针后未初始化 多线程获取时可能会出现问题。</span></span><br><span class="line"><span class="comment">//volatile关键字会禁止指令重排序 即可避免这种问题。</span></span><br></pre></td></tr></table></figure><p>这种方式实现的单例：实现了<code>lazy loading</code> 使用时才创建实例。<code>synchronized</code>保证了线程安全，<code>volatile</code>禁止指令重排序保证了多线程获取时不为空。但要JDK1.5以上才行。</p><h4 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5. 枚举"></a>5. 枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"> <span class="comment">//定义一个枚举的元素，它就是 Singleton 的一个实例</span></span><br><span class="line">    INSTANCE;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     System.out.println(<span class="string">"枚举方法实现单例"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Singleton singleton = Singleton.INSTANCE;</span><br><span class="line">singleton.doSomeThing();<span class="comment">//output:枚举方法实现单例</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式也是《Effective Java 》以及《Java与模式》的作者推荐的方式，不过工作中却很少看到用。</p><h2 id="3-性能测试"><a href="#3-性能测试" class="headerlink" title="3. 性能测试"></a>3. 性能测试</h2><p>五种单例实现方式，在100个线程下，每个线程访问1千万次实例的用时.</p><table><thead><tr><th>Tables</th><th>实现方式</th><th>用时(毫秒)</th></tr></thead><tbody><tr><td>1</td><td>饿汉式</td><td>13</td></tr><tr><td>2</td><td>懒汉式</td><td>10778</td></tr><tr><td>3</td><td>双重检查</td><td>15</td></tr><tr><td>4</td><td>静态内部类</td><td>14</td></tr><tr><td>5</td><td>枚举</td><td>12</td></tr></tbody></table><p>(*注意:由于不同电脑之间的性能差异，测试的结果可能不同)</p><p>根据不同场合选择具体的实现方式，一般情况下我是使用的<strong>静态内部类</strong>或者<strong>DCL双重校验锁</strong>方式。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><strong>为什么要使用单例模式？什么场景适合使用单例模式?单例模式有什么好处</strong></p><ul><li>1.单例模式能够保证一个类仅有唯一的实例，避免创建多个实例。并提供一个全局访问点，优化和共享资源访问。</li><li>2.当一个对象需要频繁创建和销毁时使用单例模式能节省系统资源。</li></ul><p><strong>应用场景：</strong></p><ul><li><p>1.配置文件访问类，不用每次使用时都new一个</p></li><li><p>2.数据库连接池 保证项目中只有一个连接池存在。</p></li></ul><p><strong>单例模式的缺点：</strong></p><ul><li>单例模式一般没有接口，扩展很困难，若要扩展只能修改代码。</li></ul><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p><a href="https://blog.csdn.net/qq_22706515/article/details/74202814" target="_blank" rel="noopener">单例模式性能分析</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 03 2019 18:29:47 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍了设计模式的六大原则，并结合实例描述了各种单例模式的具体实现和性能分析测试。包括：&lt;code&gt;饿汉式&lt;/code&gt;、&lt;code&gt;静态内部类&lt;/code&gt;、&lt;code&gt;懒汉式&lt;/code&gt;、&lt;code&gt;双重校验锁&lt;/code&gt;、&lt;code&gt;枚举&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.lixueduan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lixueduan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://www.lixueduan.com/tags/Java/"/>
    
  </entry>
  
</feed>
